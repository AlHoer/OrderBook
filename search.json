[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction à Python !",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "index.html#rémi-genet",
    "href": "index.html#rémi-genet",
    "title": "Introduction à Python !",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "content/Cours_1/6-IDEs.html",
    "href": "content/Cours_1/6-IDEs.html",
    "title": "Les IDEs",
    "section": "",
    "text": "A. Définition et Objectif des IDE\n\nQu’est-ce qu’un IDE ?\n\nUn Environnement de Développement Intégré (IDE) est une application logicielle qui fournit des outils complets et intégrés pour le développement de logiciels.\nIl combine un éditeur de code, un compilateur ou interpréteur, un débogueur, et souvent des outils supplémentaires dans une interface unifiée.\n\nObjectif d’un IDE\n\nL’objectif principal d’un IDE est de maximiser la productivité du développeur en simplifiant le processus de développement avec des outils intégrés et une interface utilisateur conviviale.\nIl vise à réduire la complexité de configuration des différents outils nécessaires au développement.\n\n\n\n\nB. Fonctionnalités Clés des IDE pour Python\n\nÉditeur de Code\n\nPropose la coloration syntaxique, l’auto-complétion, et la refactorisation du code pour faciliter la lecture et l’écriture du code Python.\n\nDébogueur\n\nIntègre des fonctionnalités pour exécuter le code pas à pas, inspecter les variables, et identifier les erreurs, rendant le débogage plus intuitif.\n\nGestion des Projets\n\nOffre des outils pour organiser et gérer les fichiers de code, ressources, et dépendances, améliorant la structure et la maintenabilité des projets.\n\nIntégration de Contrôle de Version\n\nIntègre des systèmes de contrôle de version comme Git, facilitant la gestion des versions et la collaboration entre développeurs.\n\nConsole et Terminal Intégrés\n\nPermet l’exécution de scripts Python et l’interaction avec l’interpréteur directement dans l’IDE, offrant une expérience de développement fluide.\n\nSupport des Frameworks et Bibliothèques\n\nFournit une intégration avec des frameworks de développement web, de science des données, et d’autres bibliothèques Python, facilitant le développement dans des domaines spécifiques.\n\n\n\n\nC. Rôle des IDE dans le Développement Python\n\nProductivité et Efficacité\n\nLes IDE accélèrent le processus de développement en automatisant les tâches répétitives et en fournissant des raccourcis pratiques.\n\nQualité et Cohérence du Code\n\nLes fonctionnalités comme la vérification de syntaxe, la refactorisation et le formatage du code contribuent à maintenir une haute qualité et une cohérence du code.\n\nApprentissage et Accessibilité\n\nPour les débutants, les IDE peuvent simplifier l’apprentissage du langage Python en offrant une interface plus accessible et des outils d’aide à la programmation.\n\nCollaboration et Travail d’Équipe\n\nLes outils intégrés de gestion de versions et de collaboration facilitent le travail en équipe, en particulier sur de grands projets avec de nombreux contributeurs.\n\n\n\n\nD. Choisir un IDE pour Python\nLe choix d’un IDE dépend de plusieurs facteurs : - Niveau d’Expérience : Certains IDE sont mieux adaptés aux débutants avec des interfaces plus simples, tandis que d’autres offrent des fonctionnalités avancées pour les développeurs expérimentés. - Type de Projet : Selon le projet (développement web, data science, scripts), certains IDE offrent des outils et intégrations spécifiques plus adaptés. - Préférences Personnelles : L’interface utilisateur, la configuration et les extensions disponibles peuvent influencer le choix d’un IDE.\nLes IDEs jouent un rôle essentiel dans le développement moderne en fournissant un environnement riche et intégré pour le codage, le test, le débogage et le déploiement de logiciels. Pour les développeurs Python, le choix d’un IDE adapté peut grandement affecter l’efficacité et la qualité du processus de développement.\nPycharm Spyder VsCode\n\n\n\n\n Back to top",
    "crumbs": [
      "Les IDEs"
    ]
  },
  {
    "objectID": "content/Cours_1/TP-ConstruireSonPython.html",
    "href": "content/Cours_1/TP-ConstruireSonPython.html",
    "title": "TP - Construire son python depuis la source",
    "section": "",
    "text": "TP - Construire Python depuis la Source\nAfin de vous aider pour réaliser ce TP, vous trouverez une fiche sur l’utilisation de git ici, ainsi qu’une fiche sur les commandes de base du terminal Linux pour ceux qui n’en ont pas l’habitude ici. Pour ceux ayant déjà fait du C ce TP devrait être assez simple, pour les autres, il vous faudra un peu plus de temps pour comprendre les différentes étapes.\n\nPartie 1 : Préparation et Clonage du Répertoire Git de CPython\nLe but de cette première partie est de préparer votre environnement pour la compilation de Python et de cloner le répertoire Git de CPython.\n\nPréparation de l’Environnement :\n\nAvant de cloner le répertoire, assurez-vous que Git est installé sur votre système. Sous Linux et MacOS, Git est souvent préinstallé. Sous Windows, vous devrez peut-être l’installer manuellement.\nVérifiez également que vous disposez des outils de compilation nécessaires. Sous Linux, il s’agit généralement du package build-essential. Sous MacOS, vous aurez besoin de Xcode ou des outils de ligne de commande pour Xcode.\n\nClonage du Répertoire Git de CPython :\n\nOuvrez un terminal ou une invite de commande.\nExécutez la commande suivante pour cloner le répertoire Git de CPython :\ngit clone https://github.com/python/cpython.git\nCette commande télécharge le code source de Python dans un dossier cpython sur votre machine.\nVous pouvez choisir une branche spécifique si vous le souhaitez, mais la branche par défaut vous donnera accès à la dernière version de développement.\n\n\n\n\nPartie 2 : Configuration du Build\nCette partie implique de configurer le code source pour la compilation.\n\nNavigation dans le Dossier :\n\nAccédez au dossier cloné en utilisant la commande cd cpython.\n\nConfiguration du Build :\n\nDans le dossier cpython, exécutez la commande ./configure.\nCette étape vérifie les outils et bibliothèques disponibles sur votre système. Elle configure le processus de build pour qu’il soit adapté à votre environnement spécifique.\nLa commande ./configure peut être personnalisée avec diverses options, telles que l’activation ou la désactivation de certaines fonctionnalités de Python.\n\n\n\n\nPartie 3 : Compilation de Python\nLa compilation est le processus de transformation du code source en un exécutable.\nLancement de la Compilation : - Dans le même dossier, exécutez la commande make. - Cette commande compile le code source de Python. Selon la puissance de votre machine, cela peut prendre un certain temps.\n\n\nPartie 4 : Installation de Python\nAprès avoir compilé le code source, l’étape suivante est d’installer Python sur votre système.\n\nInstallation :\n\nExécutez make install dans le terminal. Cette commande copiera les fichiers exécutables et les bibliothèques dans les répertoires appropriés sur votre système.\nSi vous ne souhaitez pas écraser la version Python existante, vous pouvez utiliser make altinstall à la place.\n\nVérification de l’Installation :\n\nUne fois l’installation terminée, vérifiez que Python est correctement installé en exécutant python --version ou python3 --version dans votre terminal. Vous devriez voir la version que vous venez de compiler.\n\n\n\n\nPartie 5 : Personnalisation et Observations pendant la Compilation\nLors de la compilation de Python, plusieurs aspects peuvent être personnalisés pour répondre à des besoins spécifiques ou optimiser le build.\n\nVariables d’Environnement et Options de Compilation :\n\nCC : Vous pouvez définir la variable d’environnement CC pour spécifier le compilateur à utiliser. Par exemple, export CC=gcc utilise GCC.\nFlags d’Optimisation : Les flags comme -O2 ou -O3 peuvent être ajoutés pour optimiser le build. Ces flags peuvent être définis en modifiant la variable CFLAGS.\nExemple : export CFLAGS=\"-O3\" pour une optimisation de niveau 3.\n\nModification du Makefile :\n\nLe Makefile généré par ./configure peut être modifié pour un contrôle plus fin sur le processus de build.\nVous pouvez ouvrir le Makefile dans un éditeur de texte et examiner les différents targets de build, les variables et les options configurées.\n\nObserver le Processus de Compilation :\n\nPendant la compilation avec make, observez les sorties dans le terminal. Elles fournissent des informations sur les fichiers en cours de compilation, les avertissements, et les erreurs éventuelles.\nLes messages d’erreur, en particulier, peuvent vous aider à identifier des problèmes spécifiques liés aux dépendances ou à la configuration de votre système.\n\n\n\n\nConseils Supplémentaires et Ressources pour la Compilation de Python\nAprès avoir compilé et installé votre version personnalisée de Python, voici quelques conseils et ressources supplémentaires pour approfondir vos connaissances et compétences en matière de compilation.\n\nExploration Approfondie du Makefile :\n\nPrenez le temps d’étudier le Makefile généré par ./configure. Il contient des informations précieuses sur les processus de build et les targets.\nExplorer le Makefile vous aidera à comprendre comment les différentes parties de Python sont compilées et liées ensemble.\n\nPersonnalisation Avancée :\n\nEn plus des flags d’optimisation et du choix du compilateur, envisagez d’explorer d’autres options de configuration. Par exemple, vous pouvez activer ou désactiver des modules spécifiques de Python lors de la compilation.\nLes options de configuration peuvent être explorées en exécutant ./configure --help.\n\nGestion des Dépendances :\n\nAssurez-vous que toutes les dépendances nécessaires sont installées sur votre système. Certaines fonctionnalités de Python peuvent nécessiter des bibliothèques externes.\nLes erreurs lors de la compilation sont souvent dues à l’absence de certaines bibliothèques de développement.\n\nRessources et Documentation :\n\nLa documentation officielle de Python est une ressource précieuse pour comprendre les différents aspects de la compilation de Python.\nDes forums et des communautés en ligne, comme Stack Overflow et les groupes Python, peuvent être des lieux d’échange d’informations et de conseils. #### Conclusion\n\n\nCompiler Python depuis la source offre non seulement une compréhension approfondie du fonctionnement interne de Python, mais permet également une personnalisation avancée du build. Cela peut être particulièrement utile pour les développeurs souhaitant contribuer au code source de Python ou nécessitant des versions spécifiques pour leurs projets.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Construire son python depuis la source"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/VsCode.html",
    "href": "content/Cours_1/IDEs/VsCode.html",
    "title": "VsCode - L’IDE Flexible et Polyvalent",
    "section": "",
    "text": "Présentation Générale de Visual Studio Code (VS Code)\nVisual Studio Code, communément appelé VS Code, est un IDE largement adopté par la communauté des développeurs Python. Sa réputation repose sur sa légèreté, sa flexibilité et ses capacités de personnalisation. Examinons en détail les caractéristiques qui font de VS Code un choix privilégié pour le développement Python.\n\n\n\n1. Caractéristiques Principales de VS Code\n\nÉditeur Polyvalent :\n\nVS Code est un éditeur de code source léger et performant, supportant Python ainsi que de nombreux autres langages de programmation.\nSon interface utilisateur épurée et réactive convient aussi bien aux petits scripts qu’aux grands projets.\n\nExtensions et Personnalisation :\n\nLa force de VS Code réside dans sa capacité à intégrer une multitude d’extensions, dont une extension Python officielle qui enrichit l’IDE de fonctionnalités dédiées à Python.\nLes utilisateurs peuvent personnaliser presque tous les aspects de l’IDE, des thèmes visuels aux fonctionnalités spécifiques grâce à des extensions.\n\nIntégration Git :\n\nVS Code intègre nativement le support de Git, offrant un contrôle de version efficace et directement accessible depuis l’interface de l’IDE.\n\n\n\n\n2. Débogage et Tests\n\nFonctionnalités Avancées de Débogage :\n\nVS Code propose des outils de débogage sophistiqués pour Python, permettant l’inspection de code, le suivi des variables, et l’exécution pas à pas.\nCes outils de débogage facilitent la résolution des erreurs et des problèmes complexes dans le code.\n\nSupport des Frameworks de Test :\n\nL’IDE prend en charge divers frameworks de test unitaire pour Python, permettant de créer, d’exécuter et de visualiser les résultats des tests directement dans l’interface.\n\n\n\n\n3. Gestion des Environnements Virtuels\n\nVS Code détecte automatiquement les environnements virtuels Python, les rendant facilement accessibles pour la gestion des dépendances et l’exécution du code.\n\n\n\n4. Personnalisation et Productivité\n\nLes utilisateurs peuvent personnaliser VS Code selon leurs préférences, avec des thèmes, des raccourcis clavier, et une multitude de réglages pour optimiser l’expérience de développement.\nDes fonctionnalités comme l’auto-complétion, la navigation intelligente dans le code et les snippets personnalisés augmentent la productivité des développeurs.\n\n\n\n5. Support pour la Data Science et le Développement Web\n\nData Science :\n\nVS Code intègre des outils pour la data science, notamment le support pour Jupyter Notebooks, offrant une expérience de travail interactive avec les données.\n\nDéveloppement Web :\n\nL’IDE fournit un support exhaustif pour les technologies web, facilitant le développement tant sur le front-end que le back-end.\n\n\n\n\n\n6. Communauté Active et Mises à Jour Constantes\n\nAvec une communauté dynamique et des mises à jour régulières, VS Code continue d’évoluer, ajoutant continuellement de nouvelles fonctionnalités et améliorations.\n\n\n\nConclusion\nVisual Studio Code se distingue comme un environnement de développement hautement personnalisable et polyvalent, adapté à une vaste gamme de projets Python. Que ce soit pour la data science, le développement web, ou des applications générales, VS Code offre un ensemble d’outils et de fonctionnalités qui répondent aux besoins des développeurs de tous niveaux.\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "VsCode - L'IDE Flexible et Polyvalent"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html",
    "href": "content/Cours_1/4-Path.html",
    "title": "Le PATH",
    "section": "",
    "text": "PATH est une variable d’environnement utilisée par le système d’exploitation pour localiser les fichiers exécutables requis pour lancer des programmes ou des commandes.\nElle contient une liste de répertoires séparés par un délimiteur spécifique au système d’exploitation : point-virgule (;) pour Windows et deux-points (:) pour Unix/Linux.\n\n\n\n\n\nLorsqu’une commande est saisie dans le terminal ou l’invite de commande, le système parcourt les répertoires listés dans PATH à la recherche d’un fichier exécutable correspondant au nom de la commande.\nSi le fichier est trouvé, il est exécuté. Sinon, un message d’erreur indique que la commande est introuvable.\n\n\n\n\n\n\n\nAjouter de nouveaux chemins à PATH est souvent nécessaire après l’installation de nouveaux logiciels ou scripts pour permettre leur exécution depuis n’importe quel répertoire.\nLa modification de PATH facilite l’accès à ces programmes sans avoir besoin de naviguer vers leur répertoire d’installation ou de spécifier leur chemin complet.\n\n\n\n\n\nSous Windows, PATH peut être modifié via les Propriétés Système ou l’Éditeur de Registre.\nSous Unix/Linux et MacOS, PATH est généralement modifié en éditant les fichiers de configuration de l’interpréteur de commandes, tels que .bashrc, .bash_profile, ou .zshrc.\n\n\n\n\n\n\n\n\nPATH permet de lancer des applications et des scripts facilement depuis n’importe quel répertoire dans le terminal, en supprimant le besoin de saisir des chemins complets.\n\n\n\n\n\nUne gestion efficace de PATH aide à maintenir une organisation claire des programmes et scripts fréquemment utilisés, en centralisant leur accès.\n\n\n\n\nRisques de Sécurité - Ajouter des répertoires non sécurisés ou de sources inconnues à PATH peut exposer le système à des risques de sécurité. Des exécutables malveillants dans ces répertoires pourraient être lancés involontairement.\nBonnes Pratiques - Il est recommandé de n’ajouter que des répertoires de confiance à PATH et de vérifier régulièrement son contenu pour éviter des risques de sécurité.\n\n\n\n\n\n\n\nAccès à PATH : Accessible via Panneau de configuration &gt; Système &gt; Paramètres système avancés &gt; Variables d’environnement.\nModification : Ajouter ou modifier les valeurs dans la variable Path sous Variables d’environnement.\nApplication des Changements : Les modifications prennent effet après redémarrage de l’invite de commande ou redémarrage du système.\n\n\n\n\n\nFichiers de Configuration : .bashrc, .bash_profile, ou .profile dans le répertoire personnel de l’utilisateur.\nModification : Ajouter export PATH=\"/nouveau/chemin:$PATH\" au fichier correspondant.\nApplication des Changements : Exécuter source ~/.bashrc ou ouvrir un nouveau terminal.\n\n\n\n\n\nSimilaire à Linux, MacOS utilise .bash_profile ou .zshrc pour les utilisateurs de zsh.\nLa modification et l’application des changements sont identiques à celles de Linux.\n\n\n\n\nLa configuration de la variable PATH pour une version de Python compilée manuellement est un processus essentiel pour s’assurer que le système utilise la bonne version de Python. Voici des instructions spécifiques pour Windows, Linux et MacOS.\n\n\n\nLocalisation de l’Exécutable Python:\n\nTrouvez le chemin où Python a été compilé et installé, par exemple, C:\\Users\\VotreNom\\mon_python.\n\nModification de PATH:\n\nOuvrez les Propriétés Système &gt; Variables d’environnement.\nSous “Variables système”, trouvez et sélectionnez la variable Path, puis cliquez sur Modifier.\nAjoutez le chemin vers le dossier contenant l’exécutable Python, par exemple, C:\\Users\\VotreNom\\mon_python.\nCliquez sur OK pour fermer les fenêtres.\n\nApplication des Changements:\n\nOuvrez une nouvelle invite de commande pour que les changements prennent effet.\nTapez python --version pour vérifier que la bonne version de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nSupposons que Python soit installé dans ~/mon_python/.\n\nModification de PATH:\n\nOuvrez le fichier .bashrc ou .bash_profile dans votre répertoire personnel avec un éditeur de texte.\nAjoutez la ligne export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier.\nEnregistrez et fermez le fichier.\n\nApplication des Changements:\n\nExécutez source ~/.bashrc ou redémarrez le terminal.\nVérifiez avec python --version que la version correcte de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nComme pour Linux, identifiez où Python a été installé, par exemple, ~/mon_python/.\n\nModification de PATH:\n\nSi vous utilisez Bash, modifiez .bash_profile ; si vous utilisez Zsh, modifiez .zshrc.\nAjoutez export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier correspondant.\nSauvegardez et fermez l’éditeur de texte.\n\nApplication des Changements:\n\nExécutez source ~/.bash_profile ou source ~/.zshrc, selon l’interpréteur de commandes que vous utilisez.\nUtilisez python --version pour confirmer que le système utilise la version Python compilée manuellement.\n\n\n\n\n\n\n\nOrdre dans PATH : L’ordre des chemins dans PATH est crucial. Le système recherche les exécutables dans l’ordre où les chemins apparaissent. Si vous voulez que votre version compilée de Python soit prioritaire, assurez-vous qu’elle apparaisse en premier dans la liste.\nSécurité : Soyez prudent lors de la modification de PATH, surtout sous Unix/Linux et MacOS, car une mauvaise configuration peut affecter le fonctionnement du système.\nVersion par Défaut : Si plusieurs versions de Python sont installées, la version exécutée par défaut sera celle trouvée en premier dans PATH.\n\nEn suivant ces étapes, vous pouvez configurer votre système pour utiliser une version spécifique de Python, vous offrant ainsi une plus grande flexibilité et contrôle sur votre environnement de développement.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.1---définition-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.1---définition-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "PATH est une variable d’environnement utilisée par le système d’exploitation pour localiser les fichiers exécutables requis pour lancer des programmes ou des commandes.\nElle contient une liste de répertoires séparés par un délimiteur spécifique au système d’exploitation : point-virgule (;) pour Windows et deux-points (:) pour Unix/Linux.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.2---fonctionnement-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.2---fonctionnement-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "Lorsqu’une commande est saisie dans le terminal ou l’invite de commande, le système parcourt les répertoires listés dans PATH à la recherche d’un fichier exécutable correspondant au nom de la commande.\nSi le fichier est trouvé, il est exécuté. Sinon, un message d’erreur indique que la commande est introuvable.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.3---modification-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.3---modification-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "Ajouter de nouveaux chemins à PATH est souvent nécessaire après l’installation de nouveaux logiciels ou scripts pour permettre leur exécution depuis n’importe quel répertoire.\nLa modification de PATH facilite l’accès à ces programmes sans avoir besoin de naviguer vers leur répertoire d’installation ou de spécifier leur chemin complet.\n\n\n\n\n\nSous Windows, PATH peut être modifié via les Propriétés Système ou l’Éditeur de Registre.\nSous Unix/Linux et MacOS, PATH est généralement modifié en éditant les fichiers de configuration de l’interpréteur de commandes, tels que .bashrc, .bash_profile, ou .zshrc.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.4---importance-et-utilisation-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.4---importance-et-utilisation-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "PATH permet de lancer des applications et des scripts facilement depuis n’importe quel répertoire dans le terminal, en supprimant le besoin de saisir des chemins complets.\n\n\n\n\n\nUne gestion efficace de PATH aide à maintenir une organisation claire des programmes et scripts fréquemment utilisés, en centralisant leur accès.\n\n\n\n\nRisques de Sécurité - Ajouter des répertoires non sécurisés ou de sources inconnues à PATH peut exposer le système à des risques de sécurité. Des exécutables malveillants dans ces répertoires pourraient être lancés involontairement.\nBonnes Pratiques - Il est recommandé de n’ajouter que des répertoires de confiance à PATH et de vérifier régulièrement son contenu pour éviter des risques de sécurité.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.5---configuration-de-path-pour-windows-linux-et-macos",
    "href": "content/Cours_1/4-Path.html#section-4.5---configuration-de-path-pour-windows-linux-et-macos",
    "title": "Le PATH",
    "section": "",
    "text": "Accès à PATH : Accessible via Panneau de configuration &gt; Système &gt; Paramètres système avancés &gt; Variables d’environnement.\nModification : Ajouter ou modifier les valeurs dans la variable Path sous Variables d’environnement.\nApplication des Changements : Les modifications prennent effet après redémarrage de l’invite de commande ou redémarrage du système.\n\n\n\n\n\nFichiers de Configuration : .bashrc, .bash_profile, ou .profile dans le répertoire personnel de l’utilisateur.\nModification : Ajouter export PATH=\"/nouveau/chemin:$PATH\" au fichier correspondant.\nApplication des Changements : Exécuter source ~/.bashrc ou ouvrir un nouveau terminal.\n\n\n\n\n\nSimilaire à Linux, MacOS utilise .bash_profile ou .zshrc pour les utilisateurs de zsh.\nLa modification et l’application des changements sont identiques à celles de Linux.\n\n\n\n\nLa configuration de la variable PATH pour une version de Python compilée manuellement est un processus essentiel pour s’assurer que le système utilise la bonne version de Python. Voici des instructions spécifiques pour Windows, Linux et MacOS.\n\n\n\nLocalisation de l’Exécutable Python:\n\nTrouvez le chemin où Python a été compilé et installé, par exemple, C:\\Users\\VotreNom\\mon_python.\n\nModification de PATH:\n\nOuvrez les Propriétés Système &gt; Variables d’environnement.\nSous “Variables système”, trouvez et sélectionnez la variable Path, puis cliquez sur Modifier.\nAjoutez le chemin vers le dossier contenant l’exécutable Python, par exemple, C:\\Users\\VotreNom\\mon_python.\nCliquez sur OK pour fermer les fenêtres.\n\nApplication des Changements:\n\nOuvrez une nouvelle invite de commande pour que les changements prennent effet.\nTapez python --version pour vérifier que la bonne version de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nSupposons que Python soit installé dans ~/mon_python/.\n\nModification de PATH:\n\nOuvrez le fichier .bashrc ou .bash_profile dans votre répertoire personnel avec un éditeur de texte.\nAjoutez la ligne export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier.\nEnregistrez et fermez le fichier.\n\nApplication des Changements:\n\nExécutez source ~/.bashrc ou redémarrez le terminal.\nVérifiez avec python --version que la version correcte de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nComme pour Linux, identifiez où Python a été installé, par exemple, ~/mon_python/.\n\nModification de PATH:\n\nSi vous utilisez Bash, modifiez .bash_profile ; si vous utilisez Zsh, modifiez .zshrc.\nAjoutez export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier correspondant.\nSauvegardez et fermez l’éditeur de texte.\n\nApplication des Changements:\n\nExécutez source ~/.bash_profile ou source ~/.zshrc, selon l’interpréteur de commandes que vous utilisez.\nUtilisez python --version pour confirmer que le système utilise la version Python compilée manuellement.\n\n\n\n\n\n\n\nOrdre dans PATH : L’ordre des chemins dans PATH est crucial. Le système recherche les exécutables dans l’ordre où les chemins apparaissent. Si vous voulez que votre version compilée de Python soit prioritaire, assurez-vous qu’elle apparaisse en premier dans la liste.\nSécurité : Soyez prudent lors de la modification de PATH, surtout sous Unix/Linux et MacOS, car une mauvaise configuration peut affecter le fonctionnement du système.\nVersion par Défaut : Si plusieurs versions de Python sont installées, la version exécutée par défaut sera celle trouvée en premier dans PATH.\n\nEn suivant ces étapes, vous pouvez configurer votre système pour utiliser une version spécifique de Python, vous offrant ainsi une plus grande flexibilité et contrôle sur votre environnement de développement.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html",
    "href": "content/Cours_1/2-Python_Execution.html",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’apprentissage de la programmation en Python ne nécessite pas de connaissances préalables en informatique, mais comprendre comment un programme est exécuté est essentiel. Cette compréhension aide à gérer les packages, à résoudre les problèmes de version et à collaborer efficacement.\nUn programme est une série d’instructions écrites dans un langage compréhensible par un ordinateur, connu sous le nom de langage machine, composé de séquences binaires (0 et 1). Pour traduire un langage de haut niveau en langage machine, un processus de compilation est nécessaire.\n\n\n\nLa compilation est le processus qui consiste à traduire le code source en code machine, mais cela ne fait pas “que” cela, il va aussi vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, le compilateur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur de compilation. C’est une erreur qui se produit avant l’exécution du programme.\nMais la compilation va également permettre d’optimiser le code source. C’est à dire qu’il va le rendre plus rapide à l’exécution. Durant cette phase le compilateur va, en fonction des options choisi par le développeur, optimiser le code source, en supprimant par exemple les lignes de code qui ne sont pas utilisées, en supprimant des boucles ou recursion, en réduisant le nombre de variables, en réduisant le nombre d’instructions, en réduisant le nombre de sauts, en réduisant le nombre d’opérations, en réduisant le nombre de tests, en réduisant le nombre de fonctions, en réduisant le nombre de paramètres, en réduisant le nombre de variables locales, …\nC’est optimisation prennent cependant du temps, et ne sont pas toutes sans risques et les erreurs de compilations peuvent être nombreuses sur des programmes complexes, et la compilations peut demander un temps considérable à chaque fois que l’on apporte une modification.\nMais en Python, il n’y a pas de compilation ! Magie ?\n\n\n\nPython, comme tout les programmes qui s’execute sur l’ordinateur, provient bien d’un code qui a été compilé à un moment. La différence vient du fait que c’est l’interpreteur qui a été compilé, et qui est un programme va être capable de lire le code python et de le transformé au fur et à mesure en code machine. C’est ce que l’on appelle l’interprétation. C’est un processus qui se fait en deux étapes.\nLa première étape est l’analyse lexicale. C’est à dire que l’interpreteur va lire le code source et le découper en morceaux. C’est ce que l’on appelle les tokens. Il va ensuite les analyser pour vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, l’interpreteur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur d’analyse lexicale. C’est une erreur qui se produit avant l’exécution du programme.\nEn Python, l’interpreteur va alors produire un Bytecode. C’est un code intermédiaire qui est plus proche du language machine que le code source, mais qui n’est pas encore du language machine. C’est ce que l’on appelle parfois la compilation, mais cette étape est presque instantanée. Toutefois l’interpreteur stocke quand même ce bytecode pour ne pas le recalculer à chaque fois, vous le verrez dans le dossier pycache de vos projets python, qui sera crée automatiquement dès que vous lancerez un code.\nL’interpréteur exécute ce bytecode, ce qui entraîne l’exécution des instructions écrites dans le fichier source. Ce processus diffère de celui des langages compilés comme C ou Java, où le code source est d’abord entièrement transformé en code machine avant l’exécution. En Python, la compilation en bytecode et l’exécution sont des étapes dynamiques, ce qui confère au langage sa flexibilité et sa facilité de débogage, mais aussi impacte sa vitesse d’exécution.\n\n\n\nL’exécution d’un programme Python implique l’utilisation d’un binaire compilé de l’interpréteur Python. Ce processus est fondamental pour comprendre comment Python fonctionne sous le capot.\n\nLe Binaire Compilé: Lorsqu’on installe Python, on télécharge en fait un binaire compilé de l’interpréteur Python, ou selon les cas l’ensemble des morceaux necessaire pour que notre machine le construise. Ce binaire est spécifique à chaque système d’exploitation et architecture matérielle. Par exemple, les binaires pour Windows diffèrent de ceux pour Linux ou MacOS, comme les binaires des Mac M1 sont très différents de ceux des Mac avec les anciens processeurs Intel.\nAvantages du Binaire Compilé: Le fait d’avoir un binaire compilé spécifique à chaque plateforme permet à Python d’être portable et facile à déployer. Les développeurs peuvent écrire un script Python et s’attendre à ce qu’il fonctionne de la même manière sur différentes machines, à condition que l’interpréteur Python approprié soit installé.\n\nCe mécanisme d’interprétation via un binaire compilé est une caractéristique clé de Python, contribuant à sa polyvalence et sa facilité d’utilisation dans divers environnements de développement.\nMais donc, qui produit se binaire ? Y’en a-t-il une seule implémentation ? Puis-je le compiler moi même ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.1---un-programme---comment-ca-marche",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.1---un-programme---comment-ca-marche",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’apprentissage de la programmation en Python ne nécessite pas de connaissances préalables en informatique, mais comprendre comment un programme est exécuté est essentiel. Cette compréhension aide à gérer les packages, à résoudre les problèmes de version et à collaborer efficacement.\nUn programme est une série d’instructions écrites dans un langage compréhensible par un ordinateur, connu sous le nom de langage machine, composé de séquences binaires (0 et 1). Pour traduire un langage de haut niveau en langage machine, un processus de compilation est nécessaire.",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.2---la-compilation",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.2---la-compilation",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "La compilation est le processus qui consiste à traduire le code source en code machine, mais cela ne fait pas “que” cela, il va aussi vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, le compilateur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur de compilation. C’est une erreur qui se produit avant l’exécution du programme.\nMais la compilation va également permettre d’optimiser le code source. C’est à dire qu’il va le rendre plus rapide à l’exécution. Durant cette phase le compilateur va, en fonction des options choisi par le développeur, optimiser le code source, en supprimant par exemple les lignes de code qui ne sont pas utilisées, en supprimant des boucles ou recursion, en réduisant le nombre de variables, en réduisant le nombre d’instructions, en réduisant le nombre de sauts, en réduisant le nombre d’opérations, en réduisant le nombre de tests, en réduisant le nombre de fonctions, en réduisant le nombre de paramètres, en réduisant le nombre de variables locales, …\nC’est optimisation prennent cependant du temps, et ne sont pas toutes sans risques et les erreurs de compilations peuvent être nombreuses sur des programmes complexes, et la compilations peut demander un temps considérable à chaque fois que l’on apporte une modification.\nMais en Python, il n’y a pas de compilation ! Magie ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.3---linterprétation",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.3---linterprétation",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "Python, comme tout les programmes qui s’execute sur l’ordinateur, provient bien d’un code qui a été compilé à un moment. La différence vient du fait que c’est l’interpreteur qui a été compilé, et qui est un programme va être capable de lire le code python et de le transformé au fur et à mesure en code machine. C’est ce que l’on appelle l’interprétation. C’est un processus qui se fait en deux étapes.\nLa première étape est l’analyse lexicale. C’est à dire que l’interpreteur va lire le code source et le découper en morceaux. C’est ce que l’on appelle les tokens. Il va ensuite les analyser pour vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, l’interpreteur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur d’analyse lexicale. C’est une erreur qui se produit avant l’exécution du programme.\nEn Python, l’interpreteur va alors produire un Bytecode. C’est un code intermédiaire qui est plus proche du language machine que le code source, mais qui n’est pas encore du language machine. C’est ce que l’on appelle parfois la compilation, mais cette étape est presque instantanée. Toutefois l’interpreteur stocke quand même ce bytecode pour ne pas le recalculer à chaque fois, vous le verrez dans le dossier pycache de vos projets python, qui sera crée automatiquement dès que vous lancerez un code.\nL’interpréteur exécute ce bytecode, ce qui entraîne l’exécution des instructions écrites dans le fichier source. Ce processus diffère de celui des langages compilés comme C ou Java, où le code source est d’abord entièrement transformé en code machine avant l’exécution. En Python, la compilation en bytecode et l’exécution sont des étapes dynamiques, ce qui confère au langage sa flexibilité et sa facilité de débogage, mais aussi impacte sa vitesse d’exécution.",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.4---binaire-compilé-et-interprétation-du-code-python",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.4---binaire-compilé-et-interprétation-du-code-python",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’exécution d’un programme Python implique l’utilisation d’un binaire compilé de l’interpréteur Python. Ce processus est fondamental pour comprendre comment Python fonctionne sous le capot.\n\nLe Binaire Compilé: Lorsqu’on installe Python, on télécharge en fait un binaire compilé de l’interpréteur Python, ou selon les cas l’ensemble des morceaux necessaire pour que notre machine le construise. Ce binaire est spécifique à chaque système d’exploitation et architecture matérielle. Par exemple, les binaires pour Windows diffèrent de ceux pour Linux ou MacOS, comme les binaires des Mac M1 sont très différents de ceux des Mac avec les anciens processeurs Intel.\nAvantages du Binaire Compilé: Le fait d’avoir un binaire compilé spécifique à chaque plateforme permet à Python d’être portable et facile à déployer. Les développeurs peuvent écrire un script Python et s’attendre à ce qu’il fonctionne de la même manière sur différentes machines, à condition que l’interpréteur Python approprié soit installé.\n\nCe mécanisme d’interprétation via un binaire compilé est une caractéristique clé de Python, contribuant à sa polyvalence et sa facilité d’utilisation dans divers environnements de développement.\nMais donc, qui produit se binaire ? Y’en a-t-il une seule implémentation ? Puis-je le compiler moi même ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html",
    "href": "content/Cours_1/3-ManyPythons.html",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Python, en tant que langage, existe sous différentes implémentations, chacune ayant des caractéristiques uniques adaptées à des besoins spécifiques. Voici quelques-unes des plus connues :\n\n\n\nDescription: C’est l’implémentation standard et la plus répandue de Python, écrite en C. CPython est souvent le choix par défaut pour le développement général en Python, bien qu’il soit limité par le Global Interpreter Lock (GIL).\nUtilisation: Idéal pour des applications générales, CPython est souvent utilisé pour le développement de logiciels et l’écriture de scripts.\nCaractéristiques: Il offre un bon équilibre entre performance et facilité d’utilisation et possède le plus grand nombre de bibliothèques tierces disponibles. Mais, comme vu dans la partie 1, c’est aussi une version qui repose actuellement sur le GIL.\n\n\n\n\n\nDescription: Jython est conçu pour la machine virtuelle Java (JVM), permettant l’intégration avec des environnements Java. Contrairement à CPython, Jython n’est pas restreint par le GIL, ce qui le rend plus adapté pour des applications nécessitant du multithreading.\nUtilisation: Elle permet aux développeurs d’utiliser des bibliothèques Java dans leurs programmes Python et vice-versa.\nCaractéristiques: Jython est particulièrement utile pour les applications nécessitant l’intégration de Python avec des environnements Java existants.\n\n\n\n\n\nDescription: IronPython est conçu pour être compatible avec le Common Language Runtime (CLR) de Microsoft .NET.\nUtilisation: Cette implémentation permet d’utiliser des bibliothèques .NET dans des programmes Python et d’intégrer Python dans des applications .NET.\nCaractéristiques: IronPython est idéal pour les développeurs travaillant dans l’écosystème .NET et souhaitant utiliser Python.\n\n\n\n\n\nDescription: PyPy est une implémentation de Python axée sur la performance et l’efficacité.\nUtilisation: Utilisée principalement lorsque la vitesse d’exécution est critique.\nCaractéristiques: PyPy utilise la compilation JIT (Just-In-Time) pour accélérer l’exécution des programmes Python. Cela peut entraîner des performances nettement meilleures, en particulier pour les programmes lourds en calcul. Attention toutefois à ne pas confondre vitesse et précipitations, cette versions repose toutefois toujours sur le GIL.\n\nChaque implémentation a ses avantages et peut être choisie selon les exigences spécifiques d’un projet. CPython reste l’implémentation dominante, mais les autres offrent des alternatives précieuses pour divers cas d’utilisation.\n\n\n\n\nUne question vient évidemment, pourquoi si PyPy offre des améliorations significatives en termes de performance, alors ne remplace-t-il pas CPython ? Bien que grâce à son approche JIT (Just-In-Time), il y a plusieurs raisons pour lesquelles il ne remplace pas complètement CPython :\n\n\n\nCPython: Étant l’implémentation de référence, CPython jouit d’une excellente compatibilité avec les extensions écrites en C. Ces extensions sont largement utilisées dans l’écosystème Python pour améliorer les performances et pour l’interaction avec des systèmes de bas niveau.\nPyPy: PyPy a des difficultés à intégrer certaines extensions C, notamment celles qui sont étroitement liées aux détails internes de CPython. Cette limitation peut poser des problèmes de compatibilité avec des bibliothèques importantes.\n\n\n\n\n\nCPython: Fournit des performances stables et prévisibles sur une large gamme d’applications. Pour des tâches spécifiques, en particulier celles qui impliquent beaucoup d’appels à des bibliothèques C, CPython peut être plus rapide.\nPyPy: Excellente performance pour les programmes Python purs, mais peut être moins performant dans des scénarios mixtes (Python et C) ou pour des scripts courts où l’overhead de JIT n’est pas amorti.\n\n\n\n\n\nPyPy: En raison de sa nature JIT, PyPy peut consommer plus de mémoire que CPython, en particulier pour des programmes de longue durée où le compilateur JIT génère et stocke de nombreuses versions optimisées de morceaux de code.\n\n\n\n\n\nCPython: Bénéficie d’une adoption massive et d’un support étendu de la part de la communauté Python. La plupart des développements, des tutoriels, et des supports se concentrent sur CPython.\nPyPy: Bien que gagnant en popularité, PyPy ne jouit pas du même niveau de support communautaire, et certains développeurs peuvent être moins familiers avec ses particularités.\n\n\n\n\n\nPyPy: Idéal pour des applications à longue durée d’exécution et intensives en calcul, où les avantages de JIT peuvent être pleinement exploités.\nCPython: Mieux adapté pour des applications générales, des scripts de courte durée, et des cas où la compatibilité avec l’écosystème existant est cruciale.\n\nEn résumé, bien que PyPy soit une alternative puissante à CPython, surtout en termes de vitesse d’exécution pour certains types de programmes, il ne peut pas remplacer complètement CPython en raison de problèmes de compatibilité, de différences de performance dans certains scénarios, et de la prévalence de CPython dans la communauté Python.\n\n\n\n\nBien que ces versions n’offrent pas toujours les même possibilités, le language reste strictement le même. Ainsi, dans certains cas où le besoin de performance est plus important, le fait de simplement changé d’interpreteur peut si il n’y a pas de conflit permettre de gagner de très nombreuses heures d’optimisation!\n\n\n\nNous avons vu la théorie, mais dans la pratique, très peu de développeur ont recompiler leur binaire de python. Mais, où trouver le code ? Le compilateur ? Y-a-t-il un interet à compiler Python soit même, dans la vie de tout les jours du développeur NON, l’intérêt reste marginale, mais pour autant: - Il y a un interet pédagogique - cela permet de comprendre comment compiler depuis la source (le code brut), installer un binaire etc… Ainsi cela peut vous permettre d’ajouter par exemple sans droit administrateur des versions de python de votre choix, par exemple à l’université ! - Cela peut permettre d’améliorer la performance de votre intepreteur, celui-ci étant alors compilé spécficiquement pour votre PC, les compilateurs proposant par exemple l’utilisation de la PGO (Profile Guided Optimization), où l’interet est d’améliorer le premier binaire créer après l’avoir fait tourner sur la machine sur une charge de travail représentative pour le rendre plus performant. - Profiter des améliorations de Python qui n’ont pas encore été intégré - possiblements des mois avant qu’ils ne soient disponibles\n\n\n\nCompiler Python à partir du code source permet de comprendre le processus sous-jacent et d’adapter l’installation aux besoins spécifiques. Les étapes sont détaillé dans le TP Constuire son python",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.1---les-différentes-saveurs-de-python-cpython-jython-ironpython-pypy",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.1---les-différentes-saveurs-de-python-cpython-jython-ironpython-pypy",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Python, en tant que langage, existe sous différentes implémentations, chacune ayant des caractéristiques uniques adaptées à des besoins spécifiques. Voici quelques-unes des plus connues :\n\n\n\nDescription: C’est l’implémentation standard et la plus répandue de Python, écrite en C. CPython est souvent le choix par défaut pour le développement général en Python, bien qu’il soit limité par le Global Interpreter Lock (GIL).\nUtilisation: Idéal pour des applications générales, CPython est souvent utilisé pour le développement de logiciels et l’écriture de scripts.\nCaractéristiques: Il offre un bon équilibre entre performance et facilité d’utilisation et possède le plus grand nombre de bibliothèques tierces disponibles. Mais, comme vu dans la partie 1, c’est aussi une version qui repose actuellement sur le GIL.\n\n\n\n\n\nDescription: Jython est conçu pour la machine virtuelle Java (JVM), permettant l’intégration avec des environnements Java. Contrairement à CPython, Jython n’est pas restreint par le GIL, ce qui le rend plus adapté pour des applications nécessitant du multithreading.\nUtilisation: Elle permet aux développeurs d’utiliser des bibliothèques Java dans leurs programmes Python et vice-versa.\nCaractéristiques: Jython est particulièrement utile pour les applications nécessitant l’intégration de Python avec des environnements Java existants.\n\n\n\n\n\nDescription: IronPython est conçu pour être compatible avec le Common Language Runtime (CLR) de Microsoft .NET.\nUtilisation: Cette implémentation permet d’utiliser des bibliothèques .NET dans des programmes Python et d’intégrer Python dans des applications .NET.\nCaractéristiques: IronPython est idéal pour les développeurs travaillant dans l’écosystème .NET et souhaitant utiliser Python.\n\n\n\n\n\nDescription: PyPy est une implémentation de Python axée sur la performance et l’efficacité.\nUtilisation: Utilisée principalement lorsque la vitesse d’exécution est critique.\nCaractéristiques: PyPy utilise la compilation JIT (Just-In-Time) pour accélérer l’exécution des programmes Python. Cela peut entraîner des performances nettement meilleures, en particulier pour les programmes lourds en calcul. Attention toutefois à ne pas confondre vitesse et précipitations, cette versions repose toutefois toujours sur le GIL.\n\nChaque implémentation a ses avantages et peut être choisie selon les exigences spécifiques d’un projet. CPython reste l’implémentation dominante, mais les autres offrent des alternatives précieuses pour divers cas d’utilisation.",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.2---pourquoi-pypy-ne-remplace-pas-complètement-cpython-différences-et-limitations",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.2---pourquoi-pypy-ne-remplace-pas-complètement-cpython-différences-et-limitations",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Une question vient évidemment, pourquoi si PyPy offre des améliorations significatives en termes de performance, alors ne remplace-t-il pas CPython ? Bien que grâce à son approche JIT (Just-In-Time), il y a plusieurs raisons pour lesquelles il ne remplace pas complètement CPython :\n\n\n\nCPython: Étant l’implémentation de référence, CPython jouit d’une excellente compatibilité avec les extensions écrites en C. Ces extensions sont largement utilisées dans l’écosystème Python pour améliorer les performances et pour l’interaction avec des systèmes de bas niveau.\nPyPy: PyPy a des difficultés à intégrer certaines extensions C, notamment celles qui sont étroitement liées aux détails internes de CPython. Cette limitation peut poser des problèmes de compatibilité avec des bibliothèques importantes.\n\n\n\n\n\nCPython: Fournit des performances stables et prévisibles sur une large gamme d’applications. Pour des tâches spécifiques, en particulier celles qui impliquent beaucoup d’appels à des bibliothèques C, CPython peut être plus rapide.\nPyPy: Excellente performance pour les programmes Python purs, mais peut être moins performant dans des scénarios mixtes (Python et C) ou pour des scripts courts où l’overhead de JIT n’est pas amorti.\n\n\n\n\n\nPyPy: En raison de sa nature JIT, PyPy peut consommer plus de mémoire que CPython, en particulier pour des programmes de longue durée où le compilateur JIT génère et stocke de nombreuses versions optimisées de morceaux de code.\n\n\n\n\n\nCPython: Bénéficie d’une adoption massive et d’un support étendu de la part de la communauté Python. La plupart des développements, des tutoriels, et des supports se concentrent sur CPython.\nPyPy: Bien que gagnant en popularité, PyPy ne jouit pas du même niveau de support communautaire, et certains développeurs peuvent être moins familiers avec ses particularités.\n\n\n\n\n\nPyPy: Idéal pour des applications à longue durée d’exécution et intensives en calcul, où les avantages de JIT peuvent être pleinement exploités.\nCPython: Mieux adapté pour des applications générales, des scripts de courte durée, et des cas où la compatibilité avec l’écosystème existant est cruciale.\n\nEn résumé, bien que PyPy soit une alternative puissante à CPython, surtout en termes de vitesse d’exécution pour certains types de programmes, il ne peut pas remplacer complètement CPython en raison de problèmes de compatibilité, de différences de performance dans certains scénarios, et de la prévalence de CPython dans la communauté Python.",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.3---et-pour-vous-comment-utiliser-cette-information",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.3---et-pour-vous-comment-utiliser-cette-information",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Bien que ces versions n’offrent pas toujours les même possibilités, le language reste strictement le même. Ainsi, dans certains cas où le besoin de performance est plus important, le fait de simplement changé d’interpreteur peut si il n’y a pas de conflit permettre de gagner de très nombreuses heures d’optimisation!",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.4---compiler-un-code-python-cloner-et-construire-cpython",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.4---compiler-un-code-python-cloner-et-construire-cpython",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Nous avons vu la théorie, mais dans la pratique, très peu de développeur ont recompiler leur binaire de python. Mais, où trouver le code ? Le compilateur ? Y-a-t-il un interet à compiler Python soit même, dans la vie de tout les jours du développeur NON, l’intérêt reste marginale, mais pour autant: - Il y a un interet pédagogique - cela permet de comprendre comment compiler depuis la source (le code brut), installer un binaire etc… Ainsi cela peut vous permettre d’ajouter par exemple sans droit administrateur des versions de python de votre choix, par exemple à l’université ! - Cela peut permettre d’améliorer la performance de votre intepreteur, celui-ci étant alors compilé spécficiquement pour votre PC, les compilateurs proposant par exemple l’utilisation de la PGO (Profile Guided Optimization), où l’interet est d’améliorer le premier binaire créer après l’avoir fait tourner sur la machine sur une charge de travail représentative pour le rendre plus performant. - Profiter des améliorations de Python qui n’ont pas encore été intégré - possiblements des mois avant qu’ils ne soient disponibles",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.5---les-étapes",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.5---les-étapes",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Compiler Python à partir du code source permet de comprendre le processus sous-jacent et d’adapter l’installation aux besoins spécifiques. Les étapes sont détaillé dans le TP Constuire son python",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La Programmation Orientée Objet (POO) est un paradigme de programmation basé sur le concept d’« objets », qui peuvent contenir des données sous forme d’attributs, et du code sous forme de méthodes. En Python, la POO offre une approche flexible et puissante pour structurer et concevoir des applications.\n\n\n\nEncapsulation: Regroupe les données et les méthodes qui manipulent ces données au sein d’une unité appelée « classe ». Cela permet de cacher la représentation interne des données à l’extérieur de la classe, une pratique connue sous le nom de “cachette d’information”.\nHéritage: Permet à une classe de hériter des attributs et méthodes d’une autre classe. Cela facilite la réutilisation du code et la création d’une hiérarchie de classes.\nPolymorphisme: Signifie que des fonctions ou des méthodes peuvent être utilisées avec des objets de différents types. Il s’appuie sur l’héritage pour fournir cette flexibilité.\n\n\n\n\n\nPython est un langage multi-paradigme qui supporte à la fois la programmation procédurale et la POO. Ce qui le rend particulièrement puissant est sa capacité à offrir une syntaxe claire et une grande flexibilité dans la conception de classes et d’objets.\nContrairement à d’autres langages où les objets et les types de base sont distincts, en Python, tout est un objet. Cela inclut les types de base comme les nombres, les chaînes et les listes. Cette uniformité rend le langage cohérent et élégant.\n\n\n  a = 10\n  print(a.__class__)  # Affiche &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;\n\n\n\nEn Python, même les fonctions sont des objets. Cela permet des concepts avancés comme les décorateurs et les fonctions de première classe.\n\n\n\n\n\nLa POO offre plusieurs avantages qui la rendent idéale pour un large éventail d’applications de programmation.\n\n\n\nModularité et Réutilisation du Code**: La POO en Python permet de créer des modules et des bibliothèques réutilisables. Les classes peuvent être conçues comme des composants réutilisables dans différents projets.\nSimplicité et Clarté: La structure de classe en POO permet une organisation claire du code. Cela facilite la maintenance et la mise à jour des applications.\nExtensibilité: La capacité à étendre les classes existantes via l’héritage rend le code adaptable et évolutif.\nAdaptabilité à de Multiples Domaines: De la conception de jeux à l’intelligence artificielle et au développement web, la POO est utilisée dans de nombreux domaines, reflétant sa polyvalence et son adaptabilité.\n\n\n\n\n\nPython ajoute une touche de flexibilité et de simplicité à la POO, rendant l’apprentissage et l’utilisation de ce paradigme plus accessibles par rapport à des langages plus stricts et formels.\nLes mécanismes avancés de Python, tels que le duck typing et les méthodes magiques, ouvrent des possibilités de conception et d’implémentation qui vont au-delà des approches traditionnelles de la POO.\nL’écosystème riche de Python en frameworks et bibliothèques orientés objet (comme Django pour le web ou Pandas pour la manipulation de données) montre l’efficacité et la popularité de la POO dans la communauté Python.\n\n\n\n\n\n\nLes classes sont au cœur de la POO en Python. Elles servent de modèle pour créer des objets (instances).\n\n\n\nUne classe en Python est définie en utilisant le mot-clé class. Elle peut contenir des attributs (variables) et des méthodes (fonctions).\n\n\nclass Voiture:\n    def __init__(self, marque, modele):\n        self.marque = marque\n        self.modele = modele\n\n    def afficher_info(self):\n        print(f\"Marque: {self.marque}, Modèle: {self.modele}\")\n\n# Création d'une instance de Voiture\nma_voiture = Voiture(\"Toyota\", \"Corolla\")\nma_voiture.afficher_info()  # Affiche \"Marque: Toyota, Modèle: Corolla\"\n\nMarque: Toyota, Modèle: Corolla\n\n\n\nLa méthode __init__ est un constructeur. Elle est appelée lors de la création d’une nouvelle instance de la classe.\n\n\n\n\n\nAprès avoir défini une classe, vous pouvez créer des instances (objets) et accéder à leurs attributs et méthodes.\n\n\n# Création d'une autre instance de Voiture\nautre_voiture = Voiture(\"Honda\", \"Civic\")\nautre_voiture.afficher_info()  # Affiche \"Marque: Honda, Modèle: Civic\"\n\nMarque: Honda, Modèle: Civic\n\n\n\n\n\n\nL’héritage permet à une classe de hériter des attributs et méthodes d’une autre classe.\n\n\n\nEn Python, une classe peut hériter d’une autre classe, ce qui lui permet de reprendre ses attributs et méthodes.\n\n\nclass VehiculeElectrique(Voiture):\n    def __init__(self, marque, modele, autonomie):\n        super().__init__(marque, modele)\n        self.autonomie = autonomie\n\n    def afficher_autonomie(self):\n        print(f\"Autonomie: {self.autonomie} km\")\n\ntesla = VehiculeElectrique(\"Tesla\", \"Model S\", 600)\ntesla.afficher_info()        # Hérité de la classe Voiture\ntesla.afficher_autonomie()   # Spécifique à VehiculeElectrique\n\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction super() est utilisée pour appeler le constructeur de la classe parente.\n\n\n\n\n\nLe polymorphisme permet d’utiliser des objets de différentes classes de manière interchangeable.\n\n\n\nLe polymorphisme se manifeste lorsqu’une interface commune (comme une méthode) est implémentée de différentes manières par différentes classes.\n\n\ndef afficher_details_vehicule(vehicule):\n    vehicule.afficher_info()\n    if isinstance(vehicule, VehiculeElectrique):\n        vehicule.afficher_autonomie()\n\nafficher_details_vehicule(ma_voiture)      # Affiche les détails de la voiture\nafficher_details_vehicule(tesla)           # Affiche les détails du véhicule électrique\n\nMarque: Toyota, Modèle: Corolla\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction isinstance() est utilisée pour vérifier le type d’une instance.\n\n\n\n\n\n\nL’encapsulation et l’abstraction sont des principes de POO essentiels pour créer des modèles financiers robustes et flexibles.\n\n\n\nL’encapsulation consiste à regrouper les données et les méthodes qui les manipulent, et à restreindre l’accès direct aux données d’une classe. Cela est crucial pour la sécurité et l’intégrité des modèles financiers.\n\n\nclass Obligation:\n    def __init__(self, principal, taux_interet, maturite):\n        self.__principal = principal          # Encapsulé (attribut privé)\n        self.__taux_interet = taux_interet    # Encapsulé\n        self.__maturite = maturite            # Encapsulé\n\n    def calculer_prix(self):\n        # Méthode pour calculer le prix de l'obligation\n        # Utilise les attributs encapsulés\n        return self.__principal * (1 + self.__taux_interet) ** self.__maturite\n\nobligation = Obligation(1000, 0.05, 5)\nprint(obligation.calculer_prix())  # Affiche le prix calculé\n\n1276.2815625000003\n\n\n\nLes attributs précédés de __ sont considérés comme privés et ne sont pas accessibles directement en dehors de la classe.\n\n\n\n\n\nL’abstraction permet de créer des modèles simplifiés en ne retenant que les détails pertinents. Elle est utile pour modéliser des produits financiers complexes.\n\nPar exemple, une classe abstraite ProduitFinancier peut définir une interface pour le calcul du prix, tandis que les sous-classes concrétisent ces calculs pour différents produits.\n\n\n\n\n\n\nUtilisons la POO pour modéliser un scénario financier concret, comme le pricing d’obligations.\n\n\n\nImaginons que nous devons calculer le prix de différentes obligations avec des caractéristiques variées. Nous pouvons utiliser des classes pour modéliser ces obligations et effectuer les calculs nécessaires.\n\n\nclass Obligation:\n    def __init__(self, nominal, coupon, maturite):\n        self.nominal = nominal\n        self.coupon = coupon\n        self.maturite = maturite\n\n    def prix(self, taux_marche):\n        cash_flows = [self.coupon * self.nominal for _ in range(self.maturite)]\n        cash_flows[-1] += self.nominal\n        return sum(cf / (1 + taux_marche)**t for t, cf in enumerate(cash_flows, 1))\n\n# Exemple d'utilisation\nobligation1 = Obligation(1000, 0.05, 3)\nobligation2 = Obligation(1000, 0.06, 5)\nprint(\"Prix Obligation 1:\", obligation1.prix(0.04))\nprint(\"Prix Obligation 2:\", obligation2.prix(0.04))\n\nPrix Obligation 1: 1027.7509103322711\nPrix Obligation 2: 1089.036446620324\n\n\n\nDans cet exemple, chaque instance de Obligation représente une obligation distincte. La méthode prix calcule le prix actuel de l’obligation en actualisant ses flux de trésorerie futurs au taux du marché.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.1-introduction-à-la-poo-et-son-application-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.1-introduction-à-la-poo-et-son-application-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La Programmation Orientée Objet (POO) est un paradigme de programmation basé sur le concept d’« objets », qui peuvent contenir des données sous forme d’attributs, et du code sous forme de méthodes. En Python, la POO offre une approche flexible et puissante pour structurer et concevoir des applications.\n\n\n\nEncapsulation: Regroupe les données et les méthodes qui manipulent ces données au sein d’une unité appelée « classe ». Cela permet de cacher la représentation interne des données à l’extérieur de la classe, une pratique connue sous le nom de “cachette d’information”.\nHéritage: Permet à une classe de hériter des attributs et méthodes d’une autre classe. Cela facilite la réutilisation du code et la création d’une hiérarchie de classes.\nPolymorphisme: Signifie que des fonctions ou des méthodes peuvent être utilisées avec des objets de différents types. Il s’appuie sur l’héritage pour fournir cette flexibilité.\n\n\n\n\n\nPython est un langage multi-paradigme qui supporte à la fois la programmation procédurale et la POO. Ce qui le rend particulièrement puissant est sa capacité à offrir une syntaxe claire et une grande flexibilité dans la conception de classes et d’objets.\nContrairement à d’autres langages où les objets et les types de base sont distincts, en Python, tout est un objet. Cela inclut les types de base comme les nombres, les chaînes et les listes. Cette uniformité rend le langage cohérent et élégant.\n\n\n  a = 10\n  print(a.__class__)  # Affiche &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;\n\n\n\nEn Python, même les fonctions sont des objets. Cela permet des concepts avancés comme les décorateurs et les fonctions de première classe.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.2-lintérêt-et-les-avantages-de-la-poo-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.2-lintérêt-et-les-avantages-de-la-poo-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La POO offre plusieurs avantages qui la rendent idéale pour un large éventail d’applications de programmation.\n\n\n\nModularité et Réutilisation du Code**: La POO en Python permet de créer des modules et des bibliothèques réutilisables. Les classes peuvent être conçues comme des composants réutilisables dans différents projets.\nSimplicité et Clarté: La structure de classe en POO permet une organisation claire du code. Cela facilite la maintenance et la mise à jour des applications.\nExtensibilité: La capacité à étendre les classes existantes via l’héritage rend le code adaptable et évolutif.\nAdaptabilité à de Multiples Domaines: De la conception de jeux à l’intelligence artificielle et au développement web, la POO est utilisée dans de nombreux domaines, reflétant sa polyvalence et son adaptabilité.\n\n\n\n\n\nPython ajoute une touche de flexibilité et de simplicité à la POO, rendant l’apprentissage et l’utilisation de ce paradigme plus accessibles par rapport à des langages plus stricts et formels.\nLes mécanismes avancés de Python, tels que le duck typing et les méthodes magiques, ouvrent des possibilités de conception et d’implémentation qui vont au-delà des approches traditionnelles de la POO.\nL’écosystème riche de Python en frameworks et bibliothèques orientés objet (comme Django pour le web ou Pandas pour la manipulation de données) montre l’efficacité et la popularité de la POO dans la communauté Python.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.3-définition-et-utilisation-des-classes-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.3-définition-et-utilisation-des-classes-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Les classes sont au cœur de la POO en Python. Elles servent de modèle pour créer des objets (instances).\n\n\n\nUne classe en Python est définie en utilisant le mot-clé class. Elle peut contenir des attributs (variables) et des méthodes (fonctions).\n\n\nclass Voiture:\n    def __init__(self, marque, modele):\n        self.marque = marque\n        self.modele = modele\n\n    def afficher_info(self):\n        print(f\"Marque: {self.marque}, Modèle: {self.modele}\")\n\n# Création d'une instance de Voiture\nma_voiture = Voiture(\"Toyota\", \"Corolla\")\nma_voiture.afficher_info()  # Affiche \"Marque: Toyota, Modèle: Corolla\"\n\nMarque: Toyota, Modèle: Corolla\n\n\n\nLa méthode __init__ est un constructeur. Elle est appelée lors de la création d’une nouvelle instance de la classe.\n\n\n\n\n\nAprès avoir défini une classe, vous pouvez créer des instances (objets) et accéder à leurs attributs et méthodes.\n\n\n# Création d'une autre instance de Voiture\nautre_voiture = Voiture(\"Honda\", \"Civic\")\nautre_voiture.afficher_info()  # Affiche \"Marque: Honda, Modèle: Civic\"\n\nMarque: Honda, Modèle: Civic",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.4-héritage-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.4-héritage-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "L’héritage permet à une classe de hériter des attributs et méthodes d’une autre classe.\n\n\n\nEn Python, une classe peut hériter d’une autre classe, ce qui lui permet de reprendre ses attributs et méthodes.\n\n\nclass VehiculeElectrique(Voiture):\n    def __init__(self, marque, modele, autonomie):\n        super().__init__(marque, modele)\n        self.autonomie = autonomie\n\n    def afficher_autonomie(self):\n        print(f\"Autonomie: {self.autonomie} km\")\n\ntesla = VehiculeElectrique(\"Tesla\", \"Model S\", 600)\ntesla.afficher_info()        # Hérité de la classe Voiture\ntesla.afficher_autonomie()   # Spécifique à VehiculeElectrique\n\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction super() est utilisée pour appeler le constructeur de la classe parente.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.5-polymorphisme-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.5-polymorphisme-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Le polymorphisme permet d’utiliser des objets de différentes classes de manière interchangeable.\n\n\n\nLe polymorphisme se manifeste lorsqu’une interface commune (comme une méthode) est implémentée de différentes manières par différentes classes.\n\n\ndef afficher_details_vehicule(vehicule):\n    vehicule.afficher_info()\n    if isinstance(vehicule, VehiculeElectrique):\n        vehicule.afficher_autonomie()\n\nafficher_details_vehicule(ma_voiture)      # Affiche les détails de la voiture\nafficher_details_vehicule(tesla)           # Affiche les détails du véhicule électrique\n\nMarque: Toyota, Modèle: Corolla\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction isinstance() est utilisée pour vérifier le type d’une instance.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.6-encapsulation-et-abstraction-dans-la-modélisation-financière",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.6-encapsulation-et-abstraction-dans-la-modélisation-financière",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "L’encapsulation et l’abstraction sont des principes de POO essentiels pour créer des modèles financiers robustes et flexibles.\n\n\n\nL’encapsulation consiste à regrouper les données et les méthodes qui les manipulent, et à restreindre l’accès direct aux données d’une classe. Cela est crucial pour la sécurité et l’intégrité des modèles financiers.\n\n\nclass Obligation:\n    def __init__(self, principal, taux_interet, maturite):\n        self.__principal = principal          # Encapsulé (attribut privé)\n        self.__taux_interet = taux_interet    # Encapsulé\n        self.__maturite = maturite            # Encapsulé\n\n    def calculer_prix(self):\n        # Méthode pour calculer le prix de l'obligation\n        # Utilise les attributs encapsulés\n        return self.__principal * (1 + self.__taux_interet) ** self.__maturite\n\nobligation = Obligation(1000, 0.05, 5)\nprint(obligation.calculer_prix())  # Affiche le prix calculé\n\n1276.2815625000003\n\n\n\nLes attributs précédés de __ sont considérés comme privés et ne sont pas accessibles directement en dehors de la classe.\n\n\n\n\n\nL’abstraction permet de créer des modèles simplifiés en ne retenant que les détails pertinents. Elle est utile pour modéliser des produits financiers complexes.\n\nPar exemple, une classe abstraite ProduitFinancier peut définir une interface pour le calcul du prix, tandis que les sous-classes concrétisent ces calculs pour différents produits.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.7-exemple-pratique-en-finance-de-marché",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.7-exemple-pratique-en-finance-de-marché",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Utilisons la POO pour modéliser un scénario financier concret, comme le pricing d’obligations.\n\n\n\nImaginons que nous devons calculer le prix de différentes obligations avec des caractéristiques variées. Nous pouvons utiliser des classes pour modéliser ces obligations et effectuer les calculs nécessaires.\n\n\nclass Obligation:\n    def __init__(self, nominal, coupon, maturite):\n        self.nominal = nominal\n        self.coupon = coupon\n        self.maturite = maturite\n\n    def prix(self, taux_marche):\n        cash_flows = [self.coupon * self.nominal for _ in range(self.maturite)]\n        cash_flows[-1] += self.nominal\n        return sum(cf / (1 + taux_marche)**t for t, cf in enumerate(cash_flows, 1))\n\n# Exemple d'utilisation\nobligation1 = Obligation(1000, 0.05, 3)\nobligation2 = Obligation(1000, 0.06, 5)\nprint(\"Prix Obligation 1:\", obligation1.prix(0.04))\nprint(\"Prix Obligation 2:\", obligation2.prix(0.04))\n\nPrix Obligation 1: 1027.7509103322711\nPrix Obligation 2: 1089.036446620324\n\n\n\nDans cet exemple, chaque instance de Obligation représente une obligation distincte. La méthode prix calcule le prix actuel de l’obligation en actualisant ses flux de trésorerie futurs au taux du marché.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html",
    "href": "content/Cours_3/3-MachineLearning.html",
    "title": "Machine Learning",
    "section": "",
    "text": "Machine Learning\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html",
    "href": "content/Cours_3/1-Dataframes.html",
    "title": "Les DataFrames",
    "section": "",
    "text": "Dataframes en Python\n\n\nIntroduction aux Dataframes\nDéfinition et Rôle des Dataframes : Un dataframe est une structure de données bidimensionnelle, souvent comparée à une feuille de calcul Excel ou une table de base de données SQL. Il est utilisé pour stocker et manipuler des ensembles de données organisées en lignes et colonnes. Chaque colonne représente une variable, et chaque ligne représente une observation.\nLes dataframes sont cruciaux en analyse de données, statistiques, science des données et machine learning pour le traitement et l’analyse de grands ensembles de données. Ils facilitent la manipulation des données, notamment le tri, le filtrage, la transformation et l’agrégation.\nLibrairies Python pour Dataframes : Les deux principales librairies en Python pour travailler avec des dataframes sont Pandas et NumPy.\n\nPandas : C’est la librairie la plus populaire pour la manipulation de données en Python. Pandas offre une API riche et intuitive pour la création, la manipulation et l’analyse de dataframes.\nNumPy : Bien que principalement utilisé pour les calculs sur des tableaux multidimensionnels, NumPy est souvent employé en tandem avec Pandas, surtout pour les opérations numériques.\n\n\n\nUtilisation de Pandas pour les Dataframes\nCréation d’un Dataframe : Pour créer un dataframe avec Pandas, on peut utiliser diverses méthodes, notamment à partir d’un dictionnaire, d’un fichier CSV, ou d’un tableau NumPy.\nExemple de Code - Création d’un Dataframe :\nimport pandas as pd\n\n# Création d'un dataframe à partir d'un dictionnaire\ndata = {'Nom': ['Alice', 'Bob', 'Charlie'], 'Age': [25, 30, 35], 'Ville': ['New York', 'Paris', 'Berlin']}\ndf = pd.DataFrame(data)\n\nprint(df)\nManipulation de Dataframes : Les opérations courantes sur les dataframes incluent le filtrage, le tri, la manipulation de colonnes, et l’agrégation de données.\nExemple de Code - Manipulation de Dataframe :\n# Sélection de colonnes\ndf_age_ville = df[['Age', 'Ville']]\n\n# Filtrage des données\ndf_filtré = df[df['Age'] &gt; 30]\n\n# Tri des données\ndf_trié = df.sort_values(by='Age')\n\nprint(df_filtré)\nprint(df_trié)\n\n\nExercice Pratique\nObjectif : Créer et manipuler un dataframe avec Pandas.\n\nCréer un DataFrame : Utilisez un dictionnaire pour créer un dataframe contenant trois colonnes : ‘Produit’, ‘Quantité’ et ‘Prix’.\nFiltrer les Données : Sélectionnez les produits dont la quantité est supérieure à 10.\nTrier les Données : Triez le dataframe en fonction du prix, par ordre décroissant.\n\nSolution :\nimport pandas as pd\n\n# Création du dataframe\ndata = {'Produit': ['Pommes', 'Bananes', 'Oranges'], 'Quantité': [12, 5, 20], 'Prix': [1.5, 0.5, 0.75]}\ndf = pd.DataFrame(data)\n\n# Filtrage\ndf_filtré = df[df['Quantité'] &gt; 10]\n\n# Tri\ndf_trié = df.sort_values(by='Prix', ascending=False)\n\nprint(df_filtré)\nprint(df_trié)\nDans le prochain message, nous approfondirons l’analyse des données avec les dataframes, en explorant des fonctions avancées telles que les opérations de groupement et de fusion.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html",
    "href": "content/Cours_3/5-Feed_Internet.html",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Python - Aussi un language pour servir des données\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Annexes/LinuxTerminal.html",
    "href": "content/Annexes/LinuxTerminal.html",
    "title": "Utiliser le terminal Linux - les bases de bash",
    "section": "",
    "text": "Document de Cours : Commandes de Base Linux pour le Terminal\n\nIntroduction\nCe document vise à fournir une compréhension de base des commandes Linux utilisées couramment dans le terminal. Connaître ces commandes est essentiel pour naviguer efficacement dans les systèmes basés sur Unix/Linux, et pour la réalisation de diverses tâches de développement, notamment en Python.\n\n\n1. Navigation dans le Système de Fichiers\n\npwd (Print Working Directory) : Affiche le chemin complet du répertoire courant.\nls : Liste les fichiers et dossiers dans le répertoire courant. Utilisez ls -l pour un affichage détaillé ou ls -a pour inclure les fichiers cachés.\ncd [chemin] : Change le répertoire courant. Utilisez cd .. pour remonter d’un niveau, ou cd pour retourner au répertoire personnel.\n\n\n\n2. Gestion des Fichiers et Dossiers\n\nmkdir [nom_dossier] : Crée un nouveau dossier.\nrmdir [nom_dossier] : Supprime un dossier vide. Pour supprimer des dossiers contenant des fichiers, utilisez rm -r [nom_dossier].\ntouch [nom_fichier] : Crée un nouveau fichier vide, ou met à jour la date de modification d’un fichier existant.\ncp [source] [destination] : Copie des fichiers ou dossiers. Utilisez cp -r pour copier des dossiers.\nmv [source] [destination] : Déplace ou renomme des fichiers ou dossiers.\nrm [nom_fichier] : Supprime un fichier. Utilisez rm -r [nom_dossier] pour supprimer un dossier et son contenu.\n\n\n\n3. Visualisation et Modification de Fichiers\n\ncat [nom_fichier] : Affiche le contenu d’un fichier dans le terminal.\nless [nom_fichier] : Permet de parcourir le contenu d’un fichier.\nnano [nom_fichier], vi [nom_fichier], ou vim [nom_fichier] : Ouvre un éditeur de texte dans le terminal pour modifier des fichiers.\n\n\n\n4. Gestion des Processus\n\nps : Affiche les processus en cours d’exécution. Utilisez ps aux pour une liste détaillée.\ntop : Affiche les processus en temps réel et l’utilisation des ressources.\nkill [PID] : Termine un processus spécifique. Le PID (Process ID) peut être trouvé via ps.\n\n\n\n5. Informations Système\n\ndf : Affiche l’utilisation des disques.\nfree : Montre la quantité de mémoire libre et utilisée sur le système.\nuname -a : Donne des informations sur le système, comme la version du noyau.\n\n\n\n6. Réseau\n\nping [adresse] : Vérifie la connectivité réseau avec une adresse (par exemple, un site web).\nifconfig ou ip addr : Affiche les détails de configuration réseau des interfaces.\n\n\n\n7. Gestion des Permissions\n\nchmod [permissions] [fichier] : Modifie les permissions d’un fichier ou dossier.\nchown [utilisateur]:[groupe] [fichier] : Change le propriétaire et/ou le groupe d’un fichier ou dossier.\n\n\n\n8. Aide et Documentation\n\nman [commande] : Affiche le manuel d’une commande.\ncommande --help ou commande -h : Affiche l’aide et les options disponibles pour la commande spécifiée.\n\n\n\nConclusion\nLa maîtrise de ces commandes de base est fondamentale pour travailler efficacement dans un environnement Linux. Ces commandes constituent la base pour une grande variété de tâches dans le développement de logiciels et la gestion des systèmes.\n\nCe document sert de guide de référence rapide pour les étudiants débutant avec Linux et le terminal. Avec la pratique, ces commandes deviendront des outils essentiels dans votre arsenal de développement.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Utiliser le terminal Linux - les bases de bash"
    ]
  },
  {
    "objectID": "content/Annexes/git_advanced.html",
    "href": "content/Annexes/git_advanced.html",
    "title": "Git - Pour aller plus loin",
    "section": "",
    "text": "Partie 1 : Gestion Avancée des Branches et Fusion\nLa maîtrise des branches et des techniques de fusion est essentielle pour une gestion efficace des projets complexes. Dans cette partie, nous allons explorer des stratégies de branching avancées et des méthodes de fusion.\n\nStratégies de Branching :\n\nGit Flow : Une approche populaire qui utilise des branches dédiées pour le développement, les fonctionnalités, les releases, et la maintenance.\nGitHub Flow : Une stratégie simplifiée, plus adaptée aux déploiements continus et aux projets qui évoluent rapidement.\n\nFusions Avancées :\n\nRebase : Utilisez git rebase pour appliquer les changements d’une branche sur une autre. Cela peut aider à maintenir un historique de projet propre.\nCherry-Pick : Permet de sélectionner et d’appliquer des commits spécifiques d’une branche à une autre.\n\nGestion des Conflits Avancée :\n\nUtilisez des outils de merge comme Meld ou KDiff3 pour résoudre visuellement les conflits.\nComprenez comment les conflits sont générés et apprenez à les prévenir en planifiant soigneusement les merges et les rebases.\n\n\n\n\nPartie 2 : Utilisation Avancée de Git - Sous modules, hooks, stash\nCette partie se concentre sur les techniques avancées de Git pour optimiser la gestion du code et le workflow.\n\nSous-modules et Sous-arbres :\n\nSous-modules : Utilisez git submodule pour intégrer et gérer des dépendances de projets externes.\nSous-arbres : Une alternative aux sous-modules, les sous-arbres permettent d’intégrer des dépôts externes tout en conservant la capacité de contribuer en retour.\n\nHooks Git :\n\nLes hooks Git sont des scripts qui s’exécutent avant ou après des événements dans un dépôt Git, comme les commits ou les merges.\nUtilisez les hooks pour automatiser des tâches comme les tests, la vérification du style de code ou les builds.\n\nStash Avancé :\n\nUtilisez git stash pour sauvegarder temporairement des modifications sans les committer.\nExplorez des options avancées comme le stash multiple et l’application sélective de stashs.\n\n\n\n\nPartie 3 : Optimisation du Workflow avec Git\nAméliorez votre efficacité et votre gestion de projet avec des pratiques avancées de Git.\n\nAlias Git :\n\nCréez des alias pour les commandes Git fréquemment utilisées. Par exemple, configurez un alias pour une sortie de log détaillée ou pour des opérations complexes de rebase.\n\nBisect pour la Détection de Bugs :\n\nUtilisez git bisect pour trouver rapidement le commit qui a introduit un bug. Cette commande utilise un algorithme de recherche binaire pour parcourir l’historique des commits.\n\nReflog pour la Récupération de Données :\n\ngit reflog est un outil puissant pour récupérer des données perdues, telles que des branches supprimées ou des commits égarés.\n\n\n\n\nDocument Avancé sur Git pour Utilisateurs Expérimentés (Suite)\n\nPartie 4 : Intégration Continue et Workflows Personnalisés avec Git\nL’intégration de Git avec des systèmes d’intégration continue (CI) et l’adaptation de Git à des workflows personnalisés peuvent considérablement améliorer l’efficacité et la qualité du développement logiciel.\n\nIntégration Continue (CI) avec Git :\n\nCI/CD Pipelines : Utilisez Git en conjonction avec des outils comme Jenkins, Travis CI, ou GitLab CI pour automatiser les tests et le déploiement de votre code.\nAutomatisation des Tests : Configurez des pipelines pour exécuter des suites de tests à chaque push ou pull request, assurant ainsi que le code intégré est toujours testé.\n\nWorkflows Personnalisés :\n\nScripts et Automatisations : Créez des scripts personnalisés qui s’exécutent avec des commandes Git pour adapter le système à vos besoins spécifiques.\nWorkflows de Collaboration : Développez des pratiques de collaboration qui s’alignent avec la culture et les processus de votre équipe, comme les revues de code et les stratégies de branching.\n\n\n\n\nPartie 5 : Gestion de Grandes Bases de Code avec Git\nGérer de grandes bases de code nécessite une approche stratégique pour maintenir l’efficacité et la maintenabilité.\n\nGit LFS (Large File Storage) :\n\nUtilisez Git LFS pour gérer efficacement de gros fichiers binaires sans alourdir le dépôt principal.\nGit LFS stocke les références aux gros fichiers dans le dépôt Git, tandis que les fichiers eux-mêmes sont stockés sur un serveur distant.\n\nTechniques de Partitionnement :\n\nEnvisagez de partitionner votre base de code en plusieurs dépôts plus petits si cela est logique pour votre projet. Cela peut rendre la gestion plus facile et plus agile.\n\nOptimisations de Performance :\n\nUtilisez des techniques comme le clonage superficiel (git clone --depth) pour réduire le temps et l’espace nécessaires pour cloner de grands dépôts.\nApprenez à gérer efficacement les branches et les tags pour éviter la surcharge du dépôt.\n\n\n\n\nConclusion et Ressources Additionnelles\nMaîtriser Git à un niveau avancé nécessite de la pratique, de l’expérience et une volonté d’expérimenter. N’hésitez pas à explorer les nombreuses ressources disponibles en ligne, telles que la documentation officielle de Git, les tutoriels avancés, et les forums de discussion.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Git - Pour aller plus loin"
    ]
  },
  {
    "objectID": "content/Annexes/git_basics.html",
    "href": "content/Annexes/git_basics.html",
    "title": "Git Basics",
    "section": "",
    "text": "Document de Cours : Guide Détaillé sur Git pour les Débutants\n\nIntroduction à Git\nGit est un système de contrôle de version distribué très populaire dans le monde du développement logiciel. Il permet aux développeurs de suivre et de gérer les modifications apportées aux codes sources au fil du temps. Ce guide vise à fournir une compréhension détaillée de Git pour les débutants.\n\n\n1. Principes de Base de Git\n\nRépertoires de travail et dépôts :\n\nUn répertoire de travail est un dossier sur votre ordinateur où vous travaillez sur votre projet.\nUn dépôt (repository) Git est une structure de données qui stocke les informations sur les modifications et l’historique de votre projet.\n\nCommit :\n\nUn commit est une capture instantanée de l’état de votre projet à un moment donné. Chaque commit a un identifiant unique appelé un hash SHA-1.\n\nBranches :\n\nLes branches permettent de développer des fonctionnalités, de corriger des bugs, ou d’expérimenter dans des contextes isolés. La branche principale par défaut est généralement appelée master ou main.\n\n\n\n\n2. Installation et Configuration de Git\n\nInstallation :\n\nGit peut être installé à partir de https://git-scm.com/. Suivez les instructions pour votre système d’exploitation.\n\nConfiguration Initiale :\n\nConfigurez votre nom et votre adresse email, qui seront utilisés dans vos commits :\ngit config --global user.name \"Votre Nom\"\ngit config --global user.email \"votre.email@example.com\"\n\n\n\n\n3. Création et Clonage d’un Dépôt Git\n\nInitialisation d’un Nouveau Dépôt :\n\nPour initialiser un nouveau dépôt dans un répertoire existant :\ncd /chemin/vers/votre/projet\ngit init\n\nClonage d’un Dépôt Existant :\n\nPour cloner (copier) un dépôt existant :\ngit clone https://adresse/du/depot.git\n\n\n\n\n4. Travail avec Git : Add, Commit, Push\n\nAdd :\n\nAjoute les modifications de fichiers dans l’index (zone de staging) :\ngit add &lt;fichier&gt;\ngit add .  # Ajoute tous les fichiers modifiés\n\nCommit :\n\nEnregistre les modifications dans l’historique du dépôt :\ngit commit -m \"Message décrivant le commit\"\n\nPush :\n\nEnvoie les commits locaux vers un dépôt distant :\ngit push origin &lt;nom_de_la_branche&gt;\n\n\n\n\n5. Branches et Fusion (Merge)\n\nCréation de Branches :\n\nPour créer une nouvelle branche :\ngit branch &lt;nom_de_la_branche&gt;\n\nChangement de Branches :\n\nPour changer de branche :\ngit checkout &lt;nom_de_la_branche&gt;\n\nFusion :\n\nFusionne les changements d’une branche dans une autre :\ngit merge &lt;nom_de_la_branche&gt;\n\n\n\n\n6. Gestion des Conflits\n\nLes conflits surviennent lorsque des modifications concurrentes sont apportées à la même partie d’un fichier. Git marque ces conflits dans les fichiers concernés, et il vous appartient de les résoudre manuellement.\n\n\n\n7. Autres Commandes Utiles\n\nStatus :\n\nAffiche l’état des fichiers (modifiés, indexés, non suivis) :\ngit status\n\nLog :\n\nAffiche l’historique des commits :\ngit log\n\nFetch et Pull :\n\ngit fetch télécharge les changements depuis le dépôt distant sans les fusionner.\ngit pull télécharge et fusionne automatiquement les changements.\n\n\n\n\nConclusion\nGit est un outil puissant pour la gestion des versions. La maîtrise des commandes de base et des concepts de Git est cruciale pour tout développeur. Commencez par expérimenter avec des projets simples, et au fur et à mesure, vous vous familiariserez avec des fonctionnalités plus avancées de Git.\n\nCe guide vous a introduit aux fondamentaux de Git. Pour devenir compétent, la pratique régulière et l’exploration des fonctionnalités avancées sont essentielles. N’hésitez pas à consulter la documentation officielle de Git pour approfondir vos connaissances.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Git Basics"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Visualisation.html",
    "href": "content/Cours_3/6-Visualisation.html",
    "title": "Visualiser et présenter ces données avec Python",
    "section": "",
    "text": "Visualisation de données avec Python\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Visualiser et présenter ces données avec Python"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Calcul Scientifique et Optimization\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Access_Internet.html",
    "href": "content/Cours_3/4-Access_Internet.html",
    "title": "Recupérer des données du net",
    "section": "",
    "text": "Recupérer des données du net\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Recupérer des données du net"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La syntaxe de Python est conçue pour être lisible et concise. Comprendre ses particularités peut vous aider à écrire du code plus efficace et expressif.\n\n\n\nExpressions : En Python, chaque ligne de code est généralement une expression, par exemple a = 5 ou print(a).\nIndentations : Python utilise l’indentation pour définir des blocs de code. Contrairement à d’autres langages qui utilisent des accolades, l’indentation en Python n’est pas seulement pour la lisibilité mais est syntaxiquement significative.\n\n\na=10\nif a &gt; 5:\n    print(\"a est supérieur à 5\")\n\na est supérieur à 5\n\n\n\n\n\n\nEn Python, les commentaires commencent par #. Tout ce qui suit # sur la ligne est ignoré par l’interpréteur.\n\n\n# Ceci est un commentaire\nprint(\"Hello, World!\")  # Ceci est un commentaire en fin de ligne\n\nHello, World!\n\n\n\nNB: L’utilisation du # est utilisé dans de nombreux langages de programmation, comme le C, le C++, le Java, le PHP, le Perl, le Ruby, le Python, etc. pour définir les commentaires\n\n\n\n\n\nNombres : Python supporte int, float, et plus rarement utilisés, complex.\nChaînes de Caractères : Déclarées avec des guillemets simples 'texte' ou doubles \"texte\". Le + peut concaténer des chaînes.\nBooléens : True et False. Intéressant, en Python, 0, None, un string vide '', et les collections vides comme [], {} sont considérés comme équivalents à False.\n\n\n\n\n\n\nLes variables en Python sont des identificateurs liés à des valeurs. Elles ne nécessitent pas de déclaration explicite de type.\n\n\n\nLes noms de variables doivent commencer par une lettre ou un underscore _, suivis de lettres, chiffres, ou underscores.\nLes conventions de nommage courantes incluent snake_case pour les variables et fonctions, CamelCase pour les classes.\n\nma_variable = 10\nuneAutreVariable = \"Bonjour\"\n\n\n\n\n\n\nPython offre une gamme complète d’opérateurs arithmétiques (+, -, *, /, // pour la division entière, % pour le modulo, ** pour la puissance) et de comparaison (==, !=, &gt;, &lt;, &gt;=, &lt;=).\n\n\n\n\n\nLes opérateurs logiques incluent and, or, et not.\n\n\n\n\n\nOpérateurs Bitwise : Opèrent sur des bits et incluent & (ET), | (OU), ^ (XOR), ~ (NON), &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite).\nOpérateur d’Identité : is et is not vérifient si deux variables pointent vers le même objet.\nOpérateur d’Appartenance : in et not in vérifient si une valeur est présente dans une séquence.\n\n\n\n\n\n\nLes structures de contrôle en Python permettent d’exécuter conditionnellement des blocs de code ou de répéter des opérations.\n\n\n\nif, else, elif permettent d’exécuter des blocs de code basés sur des conditions.\nif condition:\n    # code si condition est vraie\nelif autre_condition:\n    # code si autre_condition est vraie\nelse:\n    # code si aucune des conditions précédentes n'est vraie\n\n\n\n\n\nBoucle For : Itère sur une séquence (comme une liste, un tuple, un dictionnaire, un ensemble, ou une chaîne de caractères).\nfor element in sequence:\n    # code exécuté pour chaque élément\nBoucle While : Continue à exécuter un bloc de code tant qu’une condition est vraie.\nwhile condition:\n    # code exécuté tant que la condition est vraie\n\nCompréhensions de Liste\n\nUne façon concise de créer des listes. Par exemple, [x for x in range(10)] crée une liste des nombres de 0 à 9.\n\n\n\n\n\n\nLa gestion des erreurs est cruciale pour écrire des applications robustes. Python fournit un mécanisme de gestion des exceptions pour gérer les erreurs de manière contrôlée.\n\n\n\nUn bloc try permet de tester un bloc de code pour les erreurs, et le bloc except permet de gérer l’erreur.\n\ntry:\n    # Code à essayer d'exécuter\n    resultat = 10 / 0\nexcept ZeroDivisionError:\n    # Code exécuté en cas de ZeroDivisionError\n    print(\"Division par zéro!\")\n\nDivision par zéro!\n\n\n\n\n\n\nVous pouvez spécifier plusieurs blocs except pour gérer différentes exceptions.\ntry:\n    # Tentative d'exécution de code\nexcept TypeError:\n    # Gestion d'une TypeError\nexcept ValueError:\n    # Gestion d'une ValueError\n\n\n\nLe bloc finally est facultatif et exécuté quel que soit le résultat des blocs try et except.\ntry:\n    # Code à essayer\nexcept:\n    # Gestion d'une exception\nfinally:\n    # Code exécuté après les blocs try et except\n\n\n\n\nVoyons comment on peut combiner les concepts abordés précédemment dans un exemple pratique. Cet exemple utilise une boucle while, une instruction conditionnelle if, et gère une éventuelle exception.\n\n\nImaginons un scénario où nous avons deux variables x et y. Nous voulons exécuter une boucle qui continue tant que la somme de x et y est supérieure à 8. Dans la boucle, nous effectuons une opération qui peut potentiellement lever une exception.\nx = 10\ny = 1\n\nwhile x + y &gt; 8:\n    try:\n        # Si x est impair, essayez de diviser par zéro (pour générer une exception)\n        if x % 2 != 0:\n            resultat = x / 0\n        # Autrement, décrémentez x\n        else:\n            x -= 1\n    except ZeroDivisionError:\n        print(\"Tentative de division par zéro. 'x' était impair.\")\n        break\n    finally:\n        # Décrémentez y à chaque itération\n        y -= 1\n\nprint(f\"Fin de la boucle avec x = {x} et y = {y}\")\nDans cet exemple, la boucle while continue de s’exécuter tant que la condition x + y &gt; 8 est vraie. Si x est impair, le code essaie de diviser par zéro, ce qui lève une ZeroDivisionError. Dans ce cas, le message d’erreur est imprimé, et le mot-clé break interrompt la boucle. Le bloc finally est exécuté après chaque itération, peu importe les erreurs.\n\n\n\n\nPython offre plusieurs structures de données intégrées, comme les listes et les tuples, qui sont essentielles pour le stockage et la manipulation de données.\n\n\n\nLes listes en Python sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de différents types.\n\nma_liste = [1, 2, 3, \"Python\", True]\n\nOpérations de Base sur les Listes :\n\nAjout d’éléments (append, extend).\nSuppression d’éléments (remove, pop).\nAccès et slicing (ma_liste[0], ma_liste[1:3]).\n\n\n\n\n\n\nLes tuples sont similaires aux listes, mais ils sont immuables (leurs valeurs ne peuvent pas être modifiées après leur création).\n\nmon_tuple = (1, 2, 3, \"Python\")\n\nUtilisés pour des données qui ne doivent pas être modifiées, comme les clés dans les dictionnaires.\n\n\n\n\n\nLes dictionnaires et les ensembles sont des structures de données puissantes pour stocker et gérer des ensembles de données.\n\n\n\nLes dictionnaires stockent des paires clé-valeur. Ils sont mutables et non ordonnés.\n\nmon_dictionnaire = {\"nom\": \"Alice\", \"age\": 30, \"langage\": \"Python\"}\n\nManipulation de Dictionnaires :\n\nAjout et modification d’éléments (mon_dictionnaire[\"nom\"] = \"Bob\").\nSuppression d’éléments (del mon_dictionnaire[\"age\"], mon_dictionnaire.pop(\"langage\")).\nAccès sécurisé (get).\n\n\n\n\n\n\nLes ensembles sont des collections non ordonnées de valeurs uniques. Utiles pour les opérations mathématiques comme les unions, intersections, et différences.\n\nmon_ensemble = {1, 2, 3, 4, 5}\n\nOpérations sur les Ensembles :\n\nAjout (add) et suppression (remove) d’éléments.\nOpérations comme union, intersection, et difference.\n\n\n\n\n\n\nVoyons comment combiner listes, tuples, dictionnaires et ensembles dans un exemple pratique.\n\n\nSupposons que nous avons une liste de tuples, chaque tuple contenant le nom d’un étudiant et son score. Nous voulons créer un dictionnaire où chaque clé est un score unique, et la valeur est la liste des noms d’étudiants ayant ce score.\n::: {#5ab7be50 .cell execution_count=9} ``` {.python .cell-code} etudiants = [(“Alice”, 85), (“Bob”, 90), (“Eve”, 85), (“Dave”, 90), (“Carol”, 75)] scores = {}\nfor nom, score in etudiants: if score not in scores: scores[score] = [nom] else: scores[score].append(nom)\nprint(scores) # {85: [‘Alice’, ‘Eve’], 90: [‘Bob’, ‘Dave’], 75: [‘Carol’]} ```\n::: {.cell-output .cell-output-stdout} {85: ['Alice', 'Eve'], 90: ['Bob', 'Dave'], 75: ['Carol']} ::: :::\nDans cet exemple, nous parcourons la liste etudiants. Pour chaque tuple, nous vérifions si le score est déjà une clé dans le dictionnaire scores. Si ce n’est pas le cas, nous ajoutons une nouvelle clé avec le score et initialisons sa valeur avec une liste contenant le nom de l’étudiant. Si le score existe déjà, nous ajoutons simplement le nom de l’étudiant à la liste correspondante.\n\n\n\n\n\nLes compréhensions en Python sont un moyen concis et puissant de créer de nouvelles listes, dictionnaires ou ensembles à partir de séquences ou d’autres structures itérables.\n\n\n\nLes compréhensions de liste fournissent une façon concise de créer des listes. Elles consistent en une expression suivie par une clause for, puis zéro ou plusieurs clauses for ou if.\n\n# Création d'une liste des carrés des nombres de 0 à 9\ncarres = [x**2 for x in range(10)]\n\n\n\n\n\n\nSemblables aux compréhensions de liste, mais créent des dictionnaires. Elles sont entourées de {} avec une paire clé-valeur suivie d’une clause for.\n\n# Création d'un dictionnaire avec des nombres et leurs carrés\ncarres_dict = {x: x**2 for x in range(5)}\n\n\n\n\n\n\nUtilisées pour créer des ensembles de manière similaire aux compréhensions de liste, mais avec des éléments uniques.\n\n# Création d'un ensemble de carrés des nombres impairs\ncarres_impairs = {x**2 for x in range(10) if x % 2 != 0}\n\n\n\n\n\n\nLes compréhensions peuvent être particulièrement utiles pour transformer et filtrer des données. Voici un exemple qui utilise des compréhensions de liste et de dictionnaire pour traiter des données.\n\n\nImaginons que nous avons une liste de mots et que nous voulons créer un dictionnaire qui associe chaque mot à sa longueur, mais seulement pour les mots de plus de trois lettres.\n::: {#cb1fea3a .cell execution_count=13} ``` {.python .cell-code} mots = [“python”, “est”, “un”, “langage”, “puissant”] longueur_mots = {mot: len(mot) for mot in mots if len(mot) &gt; 3}\nprint(longueur_mots) # {‘python’: 6, ‘langage’: 7, ‘puissant’: 8} ```\n::: {.cell-output .cell-output-stdout} {'python': 6, 'langage': 7, 'puissant': 8} ::: :::\nDans cet exemple, la compréhension de dictionnaire parcourt la liste mots, incluant uniquement les mots dont la longueur dépasse trois lettres. Pour chaque mot éligible, le dictionnaire longueur_mots est construit avec le mot comme clé et sa longueur comme valeur.\n\n\n\n\nLes opérateurs ternaires et les expressions lambda en Python offrent des moyens concis d’effectuer des opérations conditionnelles et de créer de petites fonctions anonymes.\n\n\n\nLes opérateurs ternaires permettent d’écrire des instructions conditionnelles en une seule ligne. La syntaxe est : [valeur_si_vrai] if [condition] else [valeur_si_faux].\n\n# Exemple d'opérateur ternaire\nage = 20\nstatut = \"majeur\" if age &gt;= 18 else \"mineur\"\n\n\n\n\n\n\nLes expressions lambda permettent de créer de petites fonctions anonymes. Elles sont utiles pour des opérations simples nécessitant une fonction.\n\n# Exemple d'expression lambda\nadditionner = lambda x, y: x + y\nprint(additionner(5, 3))  # Affiche 8\n\n8\n\n\n\n\n\n\n\nPython fournit des outils puissants pour manipuler des listes, des tuples et d’autres séquences de manière expressive.\n\n\n\nLe slicing permet de sélectionner des sous-parties d’une séquence. En plus des bases, Python permet des slicings plus complexes.\n\nma_liste = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsous_liste = ma_liste[::2]  # Sélectionne chaque élément pair\n\n\n\n\n\n\nLes listes et dictionnaires peuvent être imbriqués pour créer des structures de données complexes.\n\n# Exemple de dictionnaire contenant des listes\ninformations = {\n    \"nom\": \"Alice\",\n    \"hobbies\": [\"programmation\", \"jeux vidéo\", \"lecture\"]\n}\n\n\n\n\n\n\nPour conclure ce chapitre, combinons plusieurs des concepts abordés dans un exemple illustrant leur utilité pratique.\n\n\nSupposons que nous avons une liste de dictionnaires représentant des livres, et nous voulons extraire les titres des livres publiés après 2000.\n::: {#16bfb00d .cell execution_count=18} ``` {.python .cell-code} livres = [ {“titre”: “Python 101”, “année”: 1999}, {“titre”: “Le Guide du Voyageur Galactique”, “année”: 1979}, {“titre”: “Apprendre la Programmation”, “année”: 2015} ]\ntitres_recent = [livre[“titre”] for livre in livres if livre[“année”] &gt; 2000] print(titres_recent) # Affiche [‘Apprendre la Programmation’] ```\n::: {.cell-output .cell-output-stdout} ['Apprendre la Programmation'] ::: :::\nDans cet exemple, une compréhension de liste est utilisée pour parcourir livres, en extrayant le titre de chaque livre dont l’année est supérieure à 2000. Cela démontre comment les compréhensions de liste peuvent être utilisées pour filtrer et transformer des données de manière concise et lisible. ```",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.1-les-bases-de-la-syntaxe-python",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.1-les-bases-de-la-syntaxe-python",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La syntaxe de Python est conçue pour être lisible et concise. Comprendre ses particularités peut vous aider à écrire du code plus efficace et expressif.\n\n\n\nExpressions : En Python, chaque ligne de code est généralement une expression, par exemple a = 5 ou print(a).\nIndentations : Python utilise l’indentation pour définir des blocs de code. Contrairement à d’autres langages qui utilisent des accolades, l’indentation en Python n’est pas seulement pour la lisibilité mais est syntaxiquement significative.\n\n\na=10\nif a &gt; 5:\n    print(\"a est supérieur à 5\")\n\na est supérieur à 5\n\n\n\n\n\n\nEn Python, les commentaires commencent par #. Tout ce qui suit # sur la ligne est ignoré par l’interpréteur.\n\n\n# Ceci est un commentaire\nprint(\"Hello, World!\")  # Ceci est un commentaire en fin de ligne\n\nHello, World!\n\n\n\nNB: L’utilisation du # est utilisé dans de nombreux langages de programmation, comme le C, le C++, le Java, le PHP, le Perl, le Ruby, le Python, etc. pour définir les commentaires\n\n\n\n\n\nNombres : Python supporte int, float, et plus rarement utilisés, complex.\nChaînes de Caractères : Déclarées avec des guillemets simples 'texte' ou doubles \"texte\". Le + peut concaténer des chaînes.\nBooléens : True et False. Intéressant, en Python, 0, None, un string vide '', et les collections vides comme [], {} sont considérés comme équivalents à False.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.2-variables-et-opérateurs",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.2-variables-et-opérateurs",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les variables en Python sont des identificateurs liés à des valeurs. Elles ne nécessitent pas de déclaration explicite de type.\n\n\n\nLes noms de variables doivent commencer par une lettre ou un underscore _, suivis de lettres, chiffres, ou underscores.\nLes conventions de nommage courantes incluent snake_case pour les variables et fonctions, CamelCase pour les classes.\n\nma_variable = 10\nuneAutreVariable = \"Bonjour\"\n\n\n\n\n\n\nPython offre une gamme complète d’opérateurs arithmétiques (+, -, *, /, // pour la division entière, % pour le modulo, ** pour la puissance) et de comparaison (==, !=, &gt;, &lt;, &gt;=, &lt;=).\n\n\n\n\n\nLes opérateurs logiques incluent and, or, et not.\n\n\n\n\n\nOpérateurs Bitwise : Opèrent sur des bits et incluent & (ET), | (OU), ^ (XOR), ~ (NON), &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite).\nOpérateur d’Identité : is et is not vérifient si deux variables pointent vers le même objet.\nOpérateur d’Appartenance : in et not in vérifient si une valeur est présente dans une séquence.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.3-structures-de-contrôle",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.3-structures-de-contrôle",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les structures de contrôle en Python permettent d’exécuter conditionnellement des blocs de code ou de répéter des opérations.\n\n\n\nif, else, elif permettent d’exécuter des blocs de code basés sur des conditions.\nif condition:\n    # code si condition est vraie\nelif autre_condition:\n    # code si autre_condition est vraie\nelse:\n    # code si aucune des conditions précédentes n'est vraie\n\n\n\n\n\nBoucle For : Itère sur une séquence (comme une liste, un tuple, un dictionnaire, un ensemble, ou une chaîne de caractères).\nfor element in sequence:\n    # code exécuté pour chaque élément\nBoucle While : Continue à exécuter un bloc de code tant qu’une condition est vraie.\nwhile condition:\n    # code exécuté tant que la condition est vraie\n\nCompréhensions de Liste\n\nUne façon concise de créer des listes. Par exemple, [x for x in range(10)] crée une liste des nombres de 0 à 9.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.4-gestion-des-erreurs-et-exceptions",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.4-gestion-des-erreurs-et-exceptions",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La gestion des erreurs est cruciale pour écrire des applications robustes. Python fournit un mécanisme de gestion des exceptions pour gérer les erreurs de manière contrôlée.\n\n\n\nUn bloc try permet de tester un bloc de code pour les erreurs, et le bloc except permet de gérer l’erreur.\n\ntry:\n    # Code à essayer d'exécuter\n    resultat = 10 / 0\nexcept ZeroDivisionError:\n    # Code exécuté en cas de ZeroDivisionError\n    print(\"Division par zéro!\")\n\nDivision par zéro!\n\n\n\n\n\n\nVous pouvez spécifier plusieurs blocs except pour gérer différentes exceptions.\ntry:\n    # Tentative d'exécution de code\nexcept TypeError:\n    # Gestion d'une TypeError\nexcept ValueError:\n    # Gestion d'une ValueError\n\n\n\nLe bloc finally est facultatif et exécuté quel que soit le résultat des blocs try et except.\ntry:\n    # Code à essayer\nexcept:\n    # Gestion d'une exception\nfinally:\n    # Code exécuté après les blocs try et except",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.5-exemple-concret-mélangeant-les-concepts",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.5-exemple-concret-mélangeant-les-concepts",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Voyons comment on peut combiner les concepts abordés précédemment dans un exemple pratique. Cet exemple utilise une boucle while, une instruction conditionnelle if, et gère une éventuelle exception.\n\n\nImaginons un scénario où nous avons deux variables x et y. Nous voulons exécuter une boucle qui continue tant que la somme de x et y est supérieure à 8. Dans la boucle, nous effectuons une opération qui peut potentiellement lever une exception.\nx = 10\ny = 1\n\nwhile x + y &gt; 8:\n    try:\n        # Si x est impair, essayez de diviser par zéro (pour générer une exception)\n        if x % 2 != 0:\n            resultat = x / 0\n        # Autrement, décrémentez x\n        else:\n            x -= 1\n    except ZeroDivisionError:\n        print(\"Tentative de division par zéro. 'x' était impair.\")\n        break\n    finally:\n        # Décrémentez y à chaque itération\n        y -= 1\n\nprint(f\"Fin de la boucle avec x = {x} et y = {y}\")\nDans cet exemple, la boucle while continue de s’exécuter tant que la condition x + y &gt; 8 est vraie. Si x est impair, le code essaie de diviser par zéro, ce qui lève une ZeroDivisionError. Dans ce cas, le message d’erreur est imprimé, et le mot-clé break interrompt la boucle. Le bloc finally est exécuté après chaque itération, peu importe les erreurs.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.6-structures-de-données-de-base---listes-et-tuples",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.6-structures-de-données-de-base---listes-et-tuples",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Python offre plusieurs structures de données intégrées, comme les listes et les tuples, qui sont essentielles pour le stockage et la manipulation de données.\n\n\n\nLes listes en Python sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de différents types.\n\nma_liste = [1, 2, 3, \"Python\", True]\n\nOpérations de Base sur les Listes :\n\nAjout d’éléments (append, extend).\nSuppression d’éléments (remove, pop).\nAccès et slicing (ma_liste[0], ma_liste[1:3]).\n\n\n\n\n\n\nLes tuples sont similaires aux listes, mais ils sont immuables (leurs valeurs ne peuvent pas être modifiées après leur création).\n\nmon_tuple = (1, 2, 3, \"Python\")\n\nUtilisés pour des données qui ne doivent pas être modifiées, comme les clés dans les dictionnaires.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.7-structures-de-données-de-base---dictionnaires-et-ensembles",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.7-structures-de-données-de-base---dictionnaires-et-ensembles",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les dictionnaires et les ensembles sont des structures de données puissantes pour stocker et gérer des ensembles de données.\n\n\n\nLes dictionnaires stockent des paires clé-valeur. Ils sont mutables et non ordonnés.\n\nmon_dictionnaire = {\"nom\": \"Alice\", \"age\": 30, \"langage\": \"Python\"}\n\nManipulation de Dictionnaires :\n\nAjout et modification d’éléments (mon_dictionnaire[\"nom\"] = \"Bob\").\nSuppression d’éléments (del mon_dictionnaire[\"age\"], mon_dictionnaire.pop(\"langage\")).\nAccès sécurisé (get).\n\n\n\n\n\n\nLes ensembles sont des collections non ordonnées de valeurs uniques. Utiles pour les opérations mathématiques comme les unions, intersections, et différences.\n\nmon_ensemble = {1, 2, 3, 4, 5}\n\nOpérations sur les Ensembles :\n\nAjout (add) et suppression (remove) d’éléments.\nOpérations comme union, intersection, et difference.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.8-exemple-pratique-mélangeant-les-structures-de-données",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.8-exemple-pratique-mélangeant-les-structures-de-données",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Voyons comment combiner listes, tuples, dictionnaires et ensembles dans un exemple pratique.\n\n\nSupposons que nous avons une liste de tuples, chaque tuple contenant le nom d’un étudiant et son score. Nous voulons créer un dictionnaire où chaque clé est un score unique, et la valeur est la liste des noms d’étudiants ayant ce score.\n::: {#5ab7be50 .cell execution_count=9} ``` {.python .cell-code} etudiants = [(“Alice”, 85), (“Bob”, 90), (“Eve”, 85), (“Dave”, 90), (“Carol”, 75)] scores = {}\nfor nom, score in etudiants: if score not in scores: scores[score] = [nom] else: scores[score].append(nom)\nprint(scores) # {85: [‘Alice’, ‘Eve’], 90: [‘Bob’, ‘Dave’], 75: [‘Carol’]} ```\n::: {.cell-output .cell-output-stdout} {85: ['Alice', 'Eve'], 90: ['Bob', 'Dave'], 75: ['Carol']} ::: :::\nDans cet exemple, nous parcourons la liste etudiants. Pour chaque tuple, nous vérifions si le score est déjà une clé dans le dictionnaire scores. Si ce n’est pas le cas, nous ajoutons une nouvelle clé avec le score et initialisons sa valeur avec une liste contenant le nom de l’étudiant. Si le score existe déjà, nous ajoutons simplement le nom de l’étudiant à la liste correspondante.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.9-compréhensions-de-liste-de-dictionnaire-et-densemble",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.9-compréhensions-de-liste-de-dictionnaire-et-densemble",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les compréhensions en Python sont un moyen concis et puissant de créer de nouvelles listes, dictionnaires ou ensembles à partir de séquences ou d’autres structures itérables.\n\n\n\nLes compréhensions de liste fournissent une façon concise de créer des listes. Elles consistent en une expression suivie par une clause for, puis zéro ou plusieurs clauses for ou if.\n\n# Création d'une liste des carrés des nombres de 0 à 9\ncarres = [x**2 for x in range(10)]\n\n\n\n\n\n\nSemblables aux compréhensions de liste, mais créent des dictionnaires. Elles sont entourées de {} avec une paire clé-valeur suivie d’une clause for.\n\n# Création d'un dictionnaire avec des nombres et leurs carrés\ncarres_dict = {x: x**2 for x in range(5)}\n\n\n\n\n\n\nUtilisées pour créer des ensembles de manière similaire aux compréhensions de liste, mais avec des éléments uniques.\n\n# Création d'un ensemble de carrés des nombres impairs\ncarres_impairs = {x**2 for x in range(10) if x % 2 != 0}",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.10-exemple-concret-utilisant-les-compréhensions",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.10-exemple-concret-utilisant-les-compréhensions",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les compréhensions peuvent être particulièrement utiles pour transformer et filtrer des données. Voici un exemple qui utilise des compréhensions de liste et de dictionnaire pour traiter des données.\n\n\nImaginons que nous avons une liste de mots et que nous voulons créer un dictionnaire qui associe chaque mot à sa longueur, mais seulement pour les mots de plus de trois lettres.\n::: {#cb1fea3a .cell execution_count=13} ``` {.python .cell-code} mots = [“python”, “est”, “un”, “langage”, “puissant”] longueur_mots = {mot: len(mot) for mot in mots if len(mot) &gt; 3}\nprint(longueur_mots) # {‘python’: 6, ‘langage’: 7, ‘puissant’: 8} ```\n::: {.cell-output .cell-output-stdout} {'python': 6, 'langage': 7, 'puissant': 8} ::: :::\nDans cet exemple, la compréhension de dictionnaire parcourt la liste mots, incluant uniquement les mots dont la longueur dépasse trois lettres. Pour chaque mot éligible, le dictionnaire longueur_mots est construit avec le mot comme clé et sa longueur comme valeur.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.11-opérateurs-ternaires-et-expressions-lambda",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.11-opérateurs-ternaires-et-expressions-lambda",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les opérateurs ternaires et les expressions lambda en Python offrent des moyens concis d’effectuer des opérations conditionnelles et de créer de petites fonctions anonymes.\n\n\n\nLes opérateurs ternaires permettent d’écrire des instructions conditionnelles en une seule ligne. La syntaxe est : [valeur_si_vrai] if [condition] else [valeur_si_faux].\n\n# Exemple d'opérateur ternaire\nage = 20\nstatut = \"majeur\" if age &gt;= 18 else \"mineur\"\n\n\n\n\n\n\nLes expressions lambda permettent de créer de petites fonctions anonymes. Elles sont utiles pour des opérations simples nécessitant une fonction.\n\n# Exemple d'expression lambda\nadditionner = lambda x, y: x + y\nprint(additionner(5, 3))  # Affiche 8\n\n8",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.12-techniques-avancées-de-manipulation-de-séquences",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.12-techniques-avancées-de-manipulation-de-séquences",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Python fournit des outils puissants pour manipuler des listes, des tuples et d’autres séquences de manière expressive.\n\n\n\nLe slicing permet de sélectionner des sous-parties d’une séquence. En plus des bases, Python permet des slicings plus complexes.\n\nma_liste = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsous_liste = ma_liste[::2]  # Sélectionne chaque élément pair\n\n\n\n\n\n\nLes listes et dictionnaires peuvent être imbriqués pour créer des structures de données complexes.\n\n# Exemple de dictionnaire contenant des listes\ninformations = {\n    \"nom\": \"Alice\",\n    \"hobbies\": [\"programmation\", \"jeux vidéo\", \"lecture\"]\n}",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.13-exemple-pratique-combinant-plusieurs-concepts",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.13-exemple-pratique-combinant-plusieurs-concepts",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Pour conclure ce chapitre, combinons plusieurs des concepts abordés dans un exemple illustrant leur utilité pratique.\n\n\nSupposons que nous avons une liste de dictionnaires représentant des livres, et nous voulons extraire les titres des livres publiés après 2000.\n::: {#16bfb00d .cell execution_count=18} ``` {.python .cell-code} livres = [ {“titre”: “Python 101”, “année”: 1999}, {“titre”: “Le Guide du Voyageur Galactique”, “année”: 1979}, {“titre”: “Apprendre la Programmation”, “année”: 2015} ]\ntitres_recent = [livre[“titre”] for livre in livres if livre[“année”] &gt; 2000] print(titres_recent) # Affiche [‘Apprendre la Programmation’] ```\n::: {.cell-output .cell-output-stdout} ['Apprendre la Programmation'] ::: :::\nDans cet exemple, une compréhension de liste est utilisée pour parcourir livres, en extrayant le titre de chaque livre dont l’année est supérieure à 2000. Cela démontre comment les compréhensions de liste peuvent être utilisées pour filtrer et transformer des données de manière concise et lisible. ```",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html",
    "href": "content/Cours_2/2-FonctionsEtModules.html",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les fonctions en Python sont des blocs de code réutilisables conçus pour effectuer une tâche spécifique. La création de fonctions bien définies est un élément clé de la programmation efficace et lisible.\n\n\n\nPour définir une fonction en Python, utilisez le mot-clé def, suivi du nom de la fonction, des parenthèses et des paramètres.\n\n\n  def ma_fonction(param1, param2):\n      # Corps de la fonction\n      return param1 + param2\n\n\n\n\n\nAppelez une fonction en utilisant son nom suivi des arguments entre parenthèses.\n\n\n    resultat = ma_fonction(5, 3)  # Appel de la fonction avec 5 et 3 comme arguments\n\n\n\n\n\n\n\n\nLes fonctions peuvent avoir des arguments par défaut, qui prennent une valeur spécifiée si aucun argument n’est fourni.\nLes arguments nommés permettent de passer des arguments dans n’importe quel ordre en spécifiant leur nom.\n\n\n    def saluer(nom, message=\"Bonjour\"):\n        return f\"{message}, {nom}\"\n\n    saluer(\"Alice\")             # Utilise le message par défaut\n    saluer(\"Bob\", \"Salut\")      # Utilise un message personnalisé\n    saluer(nom=\"Carol\", message=\"Bienvenue\")  # Arguments nommés\n\n'Bienvenue, Carol'\n\n\n\n\n\n\nLes variables définies dans une fonction ont une portée locale à cette fonction. Les variables définies en dehors ont une portée globale.\n\n\n    x = \"global\"\n\n    def exemple_scope():\n        y = \"local\"\n        print(x)  # Accède à la variable globale x\n        print(y)  # Accède à la variable locale y\n\n    exemple_scope()\n\nglobal\nlocal\n\n\n\n\n\n\nLes modules et packages en Python permettent de structurer et d’organiser le code de manière logique et réutilisable.\n\n\n\nUn module est un fichier Python contenant des fonctions, des classes et des variables, ainsi que du code exécutable.\n\n\n  import math\n  print(math.sqrt(16))  # Utilise la fonction s²qrt du module math\n\n4.0\n\n\n\n\n\n\nUn package est une collection de modules. Il contient un fichier spécial nommé __init__.py.\n\nPour créer un package, créez un répertoire portant le nom du package, puis ajoutez-y des modules et un fichier __init__.py.\nImportez des modules spécifiques du package :\n\n\n    from monpackage import monmodule\n\n\n\n\nPython propose des fonctions intégrées et des expressions lambda pour effectuer des opérations fonctionnelles courantes comme le mappage, le filtrage et la réduction des données.\n\n\n\nLes expressions lambda sont de petites fonctions anonymes.\n\n\n  doubler = lambda x: x * 2\n  print(doubler(5))  # Affiche 10\n\n10\n\n\n\n\n\n\nmap() applique une fonction à chaque élément d’une séquence.\nfilter() crée une liste de tous les éléments pour lesquels une fonction renvoie True.\nreduce() applique une fonction cumulativement aux éléments d’une séquence, de gauche à droite, pour réduire la séquence à une seule valeur.\n\n  # Exemple d'utilisation de map et filter\n  nombres = [1, 2, 3, 4, 5]\n\n  carres = list(map(lambda x: x2, nombres))\n  pairs = list(filter(lambda x: x % 2 == 0, carres))\n\n  # Utilisation de reduce\n  from functools import reduce\n  somme = reduce(lambda x, y: x + y, nombres)\n\n\n\n\n\nEn Python, *args et kwargs permettent de gérer de manière flexible un nombre variable d’arguments dans les fonctions.\n\n\n\n*args est utilisé pour passer une liste variable d’arguments non-nommés à une fonction. Les arguments sont accessibles comme une tuple.\n\n\ndef fonction_avec_args(*args):\n    for arg in args:\n        print(arg)\n\nfonction_avec_args('Python', 'est', 'génial')\n\nPython\nest\ngénial\n\n\n\n\n\n\nkwargs permet de passer une liste variable d’arguments nommés. Les arguments sont accessibles comme un dictionnaire.\n\n\ndef fonction_avec_kwargs(**kwargs):\n    for cle, valeur in kwargs.items():\n        print(f\"{cle}: {valeur}\")\n\nfonction_avec_kwargs(premier='Python', deuxieme='est', troisieme='génial')\n\npremier: Python\ndeuxieme: est\ntroisieme: génial\n\n\n\n\n\n\nLes expressions lambda en Python offrent un moyen compact de créer des fonctions anonymes pour des opérations simples.\n\n\n\nLes expressions lambda sont souvent utilisées pour des fonctions courtes et simples, comme des arguments pour des fonctions comme map, filter, et sorted.\n\n\n# Tri d'une liste de tuples basé sur le deuxième élément\nliste = [(1, 'd'), (2, 'b'), (3, 'c'), (4, 'a')]\nliste.sort(key=lambda x: x[1])\nprint(liste)  # Affiche [(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]\n\n[(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]\n\n\n\n\n\n\nL’organisation des projets en modules et packages est essentielle pour maintenir une structure claire et une maintenance facile du code.\n\n\n\nUn module en Python est simplement un fichier .py. Pour utiliser un module, utilisez import nom_du_module.\nUn package est un répertoire contenant un fichier spécial __init__.py et un ou plusieurs modules.\n\n\n\n\n\nUtilisez import pour accéder aux fonctions, classes et variables d’un module ou package. Les alias peuvent être utilisés pour simplifier les noms.\n\nimport mon_module as mm\nfrom mon_package import mon_module\n\n\n\n\nLes packages permettent de regrouper des modules logiquement liés, facilitant ainsi la réutilisation et la distribution du code.\nIls aident à éviter les conflits de noms et rendent le code plus organisable et maintenable.\n\n\n\n\n\nLa compréhension de la façon dont Python importe des modules et gère les chemins d’accès aux packages est essentielle pour éviter des erreurs courantes, notamment les dépendances circulaires.\n\n\n\nLorsque vous importez un module, Python recherche d’abord dans le répertoire courant, puis dans les répertoires listés dans la variable d’environnement PYTHONPATH, et enfin dans les emplacements par défaut.\n\n\nimport sys\nprint(sys.path)  # Affiche les chemins où Python recherche les modules\n\n['/home/remi/PhDWork/Introduction-Python/content/Cours_2', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python312.zip', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python3.12', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python3.12/lib-dynload', '', '/home/remi/.local/lib/python3.12/site-packages', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python3.12/site-packages']\n\n\n\nPYTHONPATH est similaire à PATH vu précédemment. Il s’agit d’une liste de répertoires dans lesquels Python cherche des modules à importer.\n\n\n\n\n\nLorsque vous utilisez from X import Y, Python exécute tout le code à la racine du module X. Cela signifie que tout code au niveau du module, y compris les importations, sera exécuté lors de l’importation.\n\n# Dans le module X.py\nprint(\"Module X importé\")\ndef fonction_Y():\n    print(\"Fonction Y exécutée\")\n\n# Dans un autre module\nfrom X import fonction_Y  # Affiche \"Module X importé\" lors de l'exécution\n\n\n\n\nUne dépendance circulaire se produit lorsque deux modules s’importent mutuellement. Cela peut entraîner des erreurs d’exécution car l’ordre d’importation peut affecter la disponibilité des fonctions et des classes.\n\nPour éviter cela, structurez votre code pour minimiser les dépendances inter-modules.\nConsidérez l’utilisation de l’importation à l’intérieur des fonctions ou des classes si l’importation est nécessaire uniquement dans une portée locale.\n\n\n\n\n\n\nÉvitez les importations génériques (from module import *) car elles peuvent polluer l’espace de noms.\nUtilisez des alias pour clarifier l’origine des modules ou pour éviter des conflits de noms.\n\n\nimport numpy as np  # Utilisation d'un alias pour numpy\n\n\n\n\n\nComprendre les subtilités des importations en Python, y compris leur coût et les conventions d’abréviation, peut améliorer la lisibilité et l’efficacité du code.\n\n\n\nEn Python, importer plusieurs fois le même module ne pénalise pas les performances de manière significative. Lorsqu’un module est importé pour la première fois, il est compilé en bytecode et stocké en mémoire. Les importations suivantes du même module font simplement référence à la version en mémoire.\n\n\nimport math  # Le module est chargé en mémoire\nimport math  # Référence le module déjà chargé, sans coût supplémentaire\n\n\nCela signifie que vous pouvez importer le même module dans différents fichiers ou plusieurs fois dans le même fichier sans vous soucier d’un impact négatif sur les performances.\n\n\n\n\n\nIl existe des conventions d’abréviations pour certains modules fréquemment utilisés en Python. Utiliser ces abréviations peut rendre votre code plus lisible et conforme aux standards de la communauté.\n\n\n\nModule\nAbréviation Standard\n\n\n\n\npandas\npd\n\n\nnumpy\nnp\n\n\nmatplotlib.pyplot\nplt\n\n\nseaborn\nsns\n\n\ntensorflow\ntf\n\n\nscikit-learn\nskl\n\n\nscipy\nsp\n\n\nos\nos (généralement utilisé tel quel)\n\n\nsys\nsys (généralement utilisé tel quel)\n\n\n\nCes abréviations sont largement reconnues et leur utilisation est recommandée pour maintenir la cohérence avec les pratiques de la communauté Python.\n\n\n\n\n\nEn plus d’utiliser des abréviations standard, il est également conseillé de regrouper les importations en haut du fichier.\nSéparez les importations standard, tierces et locales par des lignes vides pour une meilleure lisibilité.\n\n  # Importations standard\nimport os\nimport sys\n\n# Importations tierces\nimport numpy as np\nimport pandas as pd\n\n# Importations locales\nfrom mon_module import ma_fonction\n```",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.1-définition-et-appel-de-fonctions",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.1-définition-et-appel-de-fonctions",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les fonctions en Python sont des blocs de code réutilisables conçus pour effectuer une tâche spécifique. La création de fonctions bien définies est un élément clé de la programmation efficace et lisible.\n\n\n\nPour définir une fonction en Python, utilisez le mot-clé def, suivi du nom de la fonction, des parenthèses et des paramètres.\n\n\n  def ma_fonction(param1, param2):\n      # Corps de la fonction\n      return param1 + param2\n\n\n\n\n\nAppelez une fonction en utilisant son nom suivi des arguments entre parenthèses.\n\n\n    resultat = ma_fonction(5, 3)  # Appel de la fonction avec 5 et 3 comme arguments\n\n\n\n\n\n\n\n\nLes fonctions peuvent avoir des arguments par défaut, qui prennent une valeur spécifiée si aucun argument n’est fourni.\nLes arguments nommés permettent de passer des arguments dans n’importe quel ordre en spécifiant leur nom.\n\n\n    def saluer(nom, message=\"Bonjour\"):\n        return f\"{message}, {nom}\"\n\n    saluer(\"Alice\")             # Utilise le message par défaut\n    saluer(\"Bob\", \"Salut\")      # Utilise un message personnalisé\n    saluer(nom=\"Carol\", message=\"Bienvenue\")  # Arguments nommés\n\n'Bienvenue, Carol'\n\n\n\n\n\n\nLes variables définies dans une fonction ont une portée locale à cette fonction. Les variables définies en dehors ont une portée globale.\n\n\n    x = \"global\"\n\n    def exemple_scope():\n        y = \"local\"\n        print(x)  # Accède à la variable globale x\n        print(y)  # Accède à la variable locale y\n\n    exemple_scope()\n\nglobal\nlocal",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.2-modules-et-packages",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.2-modules-et-packages",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les modules et packages en Python permettent de structurer et d’organiser le code de manière logique et réutilisable.\n\n\n\nUn module est un fichier Python contenant des fonctions, des classes et des variables, ainsi que du code exécutable.\n\n\n  import math\n  print(math.sqrt(16))  # Utilise la fonction s²qrt du module math\n\n4.0\n\n\n\n\n\n\nUn package est une collection de modules. Il contient un fichier spécial nommé __init__.py.\n\nPour créer un package, créez un répertoire portant le nom du package, puis ajoutez-y des modules et un fichier __init__.py.\nImportez des modules spécifiques du package :\n\n\n    from monpackage import monmodule",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.3-lambda-map-filter-et-reduce",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.3-lambda-map-filter-et-reduce",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Python propose des fonctions intégrées et des expressions lambda pour effectuer des opérations fonctionnelles courantes comme le mappage, le filtrage et la réduction des données.\n\n\n\nLes expressions lambda sont de petites fonctions anonymes.\n\n\n  doubler = lambda x: x * 2\n  print(doubler(5))  # Affiche 10\n\n10\n\n\n\n\n\n\nmap() applique une fonction à chaque élément d’une séquence.\nfilter() crée une liste de tous les éléments pour lesquels une fonction renvoie True.\nreduce() applique une fonction cumulativement aux éléments d’une séquence, de gauche à droite, pour réduire la séquence à une seule valeur.\n\n  # Exemple d'utilisation de map et filter\n  nombres = [1, 2, 3, 4, 5]\n\n  carres = list(map(lambda x: x2, nombres))\n  pairs = list(filter(lambda x: x % 2 == 0, carres))\n\n  # Utilisation de reduce\n  from functools import reduce\n  somme = reduce(lambda x, y: x + y, nombres)",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.7-manipulation-des-arguments-de-fonction-avec-args-et-kwargs",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.7-manipulation-des-arguments-de-fonction-avec-args-et-kwargs",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "En Python, *args et kwargs permettent de gérer de manière flexible un nombre variable d’arguments dans les fonctions.\n\n\n\n*args est utilisé pour passer une liste variable d’arguments non-nommés à une fonction. Les arguments sont accessibles comme une tuple.\n\n\ndef fonction_avec_args(*args):\n    for arg in args:\n        print(arg)\n\nfonction_avec_args('Python', 'est', 'génial')\n\nPython\nest\ngénial\n\n\n\n\n\n\nkwargs permet de passer une liste variable d’arguments nommés. Les arguments sont accessibles comme un dictionnaire.\n\n\ndef fonction_avec_kwargs(**kwargs):\n    for cle, valeur in kwargs.items():\n        print(f\"{cle}: {valeur}\")\n\nfonction_avec_kwargs(premier='Python', deuxieme='est', troisieme='génial')\n\npremier: Python\ndeuxieme: est\ntroisieme: génial",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.8-expressions-lambda-pour-des-fonctions-anonymes",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.8-expressions-lambda-pour-des-fonctions-anonymes",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les expressions lambda en Python offrent un moyen compact de créer des fonctions anonymes pour des opérations simples.\n\n\n\nLes expressions lambda sont souvent utilisées pour des fonctions courtes et simples, comme des arguments pour des fonctions comme map, filter, et sorted.\n\n\n# Tri d'une liste de tuples basé sur le deuxième élément\nliste = [(1, 'd'), (2, 'b'), (3, 'c'), (4, 'a')]\nliste.sort(key=lambda x: x[1])\nprint(liste)  # Affiche [(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]\n\n[(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.9-modules-et-packages-pour-structurer-les-projets",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.9-modules-et-packages-pour-structurer-les-projets",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "L’organisation des projets en modules et packages est essentielle pour maintenir une structure claire et une maintenance facile du code.\n\n\n\nUn module en Python est simplement un fichier .py. Pour utiliser un module, utilisez import nom_du_module.\nUn package est un répertoire contenant un fichier spécial __init__.py et un ou plusieurs modules.\n\n\n\n\n\nUtilisez import pour accéder aux fonctions, classes et variables d’un module ou package. Les alias peuvent être utilisés pour simplifier les noms.\n\nimport mon_module as mm\nfrom mon_package import mon_module\n\n\n\n\nLes packages permettent de regrouper des modules logiquement liés, facilitant ainsi la réutilisation et la distribution du code.\nIls aident à éviter les conflits de noms et rendent le code plus organisable et maintenable.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.10-mécanisme-dimportation-en-python-et-gestion-des-dépendances",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.10-mécanisme-dimportation-en-python-et-gestion-des-dépendances",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "La compréhension de la façon dont Python importe des modules et gère les chemins d’accès aux packages est essentielle pour éviter des erreurs courantes, notamment les dépendances circulaires.\n\n\n\nLorsque vous importez un module, Python recherche d’abord dans le répertoire courant, puis dans les répertoires listés dans la variable d’environnement PYTHONPATH, et enfin dans les emplacements par défaut.\n\n\nimport sys\nprint(sys.path)  # Affiche les chemins où Python recherche les modules\n\n['/home/remi/PhDWork/Introduction-Python/content/Cours_2', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python312.zip', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python3.12', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python3.12/lib-dynload', '', '/home/remi/.local/lib/python3.12/site-packages', '/home/remi/.pyenv/versions/3.12-rocm6v2/lib/python3.12/site-packages']\n\n\n\nPYTHONPATH est similaire à PATH vu précédemment. Il s’agit d’une liste de répertoires dans lesquels Python cherche des modules à importer.\n\n\n\n\n\nLorsque vous utilisez from X import Y, Python exécute tout le code à la racine du module X. Cela signifie que tout code au niveau du module, y compris les importations, sera exécuté lors de l’importation.\n\n# Dans le module X.py\nprint(\"Module X importé\")\ndef fonction_Y():\n    print(\"Fonction Y exécutée\")\n\n# Dans un autre module\nfrom X import fonction_Y  # Affiche \"Module X importé\" lors de l'exécution\n\n\n\n\nUne dépendance circulaire se produit lorsque deux modules s’importent mutuellement. Cela peut entraîner des erreurs d’exécution car l’ordre d’importation peut affecter la disponibilité des fonctions et des classes.\n\nPour éviter cela, structurez votre code pour minimiser les dépendances inter-modules.\nConsidérez l’utilisation de l’importation à l’intérieur des fonctions ou des classes si l’importation est nécessaire uniquement dans une portée locale.\n\n\n\n\n\n\nÉvitez les importations génériques (from module import *) car elles peuvent polluer l’espace de noms.\nUtilisez des alias pour clarifier l’origine des modules ou pour éviter des conflits de noms.\n\n\nimport numpy as np  # Utilisation d'un alias pour numpy",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.11-coût-des-importations-répétées-et-abréviations-standard-en-python",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.11-coût-des-importations-répétées-et-abréviations-standard-en-python",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Comprendre les subtilités des importations en Python, y compris leur coût et les conventions d’abréviation, peut améliorer la lisibilité et l’efficacité du code.\n\n\n\nEn Python, importer plusieurs fois le même module ne pénalise pas les performances de manière significative. Lorsqu’un module est importé pour la première fois, il est compilé en bytecode et stocké en mémoire. Les importations suivantes du même module font simplement référence à la version en mémoire.\n\n\nimport math  # Le module est chargé en mémoire\nimport math  # Référence le module déjà chargé, sans coût supplémentaire\n\n\nCela signifie que vous pouvez importer le même module dans différents fichiers ou plusieurs fois dans le même fichier sans vous soucier d’un impact négatif sur les performances.\n\n\n\n\n\nIl existe des conventions d’abréviations pour certains modules fréquemment utilisés en Python. Utiliser ces abréviations peut rendre votre code plus lisible et conforme aux standards de la communauté.\n\n\n\nModule\nAbréviation Standard\n\n\n\n\npandas\npd\n\n\nnumpy\nnp\n\n\nmatplotlib.pyplot\nplt\n\n\nseaborn\nsns\n\n\ntensorflow\ntf\n\n\nscikit-learn\nskl\n\n\nscipy\nsp\n\n\nos\nos (généralement utilisé tel quel)\n\n\nsys\nsys (généralement utilisé tel quel)\n\n\n\nCes abréviations sont largement reconnues et leur utilisation est recommandée pour maintenir la cohérence avec les pratiques de la communauté Python.\n\n\n\n\n\nEn plus d’utiliser des abréviations standard, il est également conseillé de regrouper les importations en haut du fichier.\nSéparez les importations standard, tierces et locales par des lignes vides pour une meilleure lisibilité.\n\n  # Importations standard\nimport os\nimport sys\n\n# Importations tierces\nimport numpy as np\nimport pandas as pd\n\n# Importations locales\nfrom mon_module import ma_fonction\n```",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_1/7-Notebooks.html",
    "href": "content/Cours_1/7-Notebooks.html",
    "title": "Les Notebooks",
    "section": "",
    "text": "7. Les Notebooks Jupyter\n\nDifférence entre les Fichiers .py et .ipynb et la Notion de Notebook\nLa distinction entre les fichiers .py et .ipynb est fondamentale dans l’écosystème Python, en particulier pour les tâches de développement et d’analyse de données.\n\nFichiers .py:\n\nNature: Les fichiers .py sont des scripts Python traditionnels. Ils contiennent du code Python pur pouvant être exécuté par l’interpréteur Python.\nUtilisation: Ces fichiers sont généralement utilisés pour le développement d’applications, de scripts, ou de modules Python.\nIDEs et Éditeurs: Ils peuvent être ouverts et exécutés dans n’importe quel éditeur de texte ou IDE comme PyCharm, Visual Studio Code, ou Spyder.\n\nFichiers .ipynb et Notebooks:\n\nNature: Les fichiers avec l’extension .ipynb sont des notebooks Jupyter. Ils permettent de combiner du code exécutable, du texte enrichi (Markdown), des équations (LaTeX), des visualisations et des médias interactifs.\nUtilisation: Ces notebooks sont largement utilisés dans la data science et l’enseignement pour leur capacité à présenter le code, les résultats, et les explications de manière interactive et attrayante.\nEnvironnement: Ils nécessitent un environnement Jupyter pour être exécutés, comme Jupyter Notebook ou JupyterLab.\n\nLa Notion de Notebook:\n\nUn “notebook” est un document numérique qui permet de créer et de partager des documents contenant du code, du texte explicatif, des formules mathématiques et des visualisations.\nLes notebooks sont interactifs : vous pouvez exécuter le code dans des cellules individuelles et voir les résultats immédiatement sous ces cellules, ce qui facilite grandement l’exploration de données et les analyses ad hoc.\n\n\nEn résumé, la différence principale entre .py et .ipynb réside dans leur approche du développement et de la présentation du code. Les fichiers .py sont mieux adaptés pour le développement de logiciels structurés, tandis que les fichiers .ipynb sont idéaux pour l’exploration de données, l’analyse interactive et la documentation de processus.\n\n\nPrésentation de Jupyter\nJupyter est un projet open source qui permet de créer et de partager des documents contenant du code en direct, des équations, des visualisations et du texte narratif. Il est particulièrement populaire dans la data science, l’enseignement des sciences informatiques, et la recherche scientifique. Voici les aspects clés de Jupyter :\n\nJupyter Notebook:\n\nNature et Fonctionnalités : Jupyter Notebook est une application web qui permet de créer et de partager des documents contenant du code interactif (notamment Python), des équations, des visualisations, et du texte explicatif.\nUtilisation : Idéal pour la data science et l’analyse exploratoire, il facilite la visualisation des données et la communication des résultats.\nInteractivité : Les utilisateurs peuvent exécuter le code dans des cellules individuelles, voir les résultats immédiatement, et apporter des modifications en temps réel.\n\nJupyterLab:\n\nÉvolution de Jupyter Notebook : JupyterLab est une interface utilisateur de nouvelle génération pour le projet Jupyter. Il offre toutes les fonctionnalités de Jupyter Notebook, avec une interface plus flexible et extensible.\nInterface Améliorée : Il propose une interface utilisateur modulaire, où les notebooks, les éditeurs de texte, les terminaux, les visualisations de données et d’autres composants peuvent être disposés dans un espace de travail unique.\nExtensions et Personnalisations : JupyterLab permet d’ajouter des extensions, ce qui augmente sa fonctionnalité et sa flexibilité.\n\nSupport Multilingue:\n\nBien que Python soit le langage le plus couramment utilisé, Jupyter supporte de nombreux autres langages de programmation grâce au concept de “kernels”. Un kernel est un moteur de calcul qui exécute le code contenu dans le notebook.\n\nPartage et Collaboration:\n\nLes notebooks Jupyter peuvent être partagés via email, Dropbox, GitHub et Jupyter Notebook Viewer.\nIls facilitent la collaboration et sont souvent utilisés dans l’enseignement et la recherche scientifique pour partager des expériences, des analyses et des rapports.\n\n\nJupyter est devenu un outil incontournable dans les domaines de la data science et de l’éducation en raison de sa capacité à combiner code, données, et narration dans un format interactif et facilement partageable. Son approche modulaire et extensible avec JupyterLab le rend encore plus puissant pour des projets de développement et de recherche complexes.\n\n\nAutres Options pour le Développement Interactif: Google Colab et Alternatives\nOutre Jupyter, il existe d’autres plateformes populaires pour le développement interactif, particulièrement dans le domaine de la data science et du machine learning. Google Colab est l’une des plus remarquables.\n\nGoogle Colab:\n\nNature et Fonctionnalités: Google Colab est un service gratuit hébergé par Google qui permet aux utilisateurs de créer et de partager des documents similaires à Jupyter Notebooks. Il est basé sur Jupyter et offre un environnement Python complet.\nIntégration avec Google Drive: Colab est intégré avec Google Drive, facilitant le partage, l’accès et la collaboration sur des notebooks.\nRessources de Calcul Gratuites: Il offre l’accès à des ressources de calcul gratuites, y compris des GPU et des TPU, ce qui le rend populaire pour les projets de machine learning et de deep learning.\nEnvironnement Préconfiguré: Colab vient préchargé avec de nombreuses bibliothèques populaires, ce qui facilite la mise en place et la réalisation de projets de data science.\n\nAutres Alternatives:\n\nDatabricks Community Edition: Plateforme basée sur le cloud qui offre un environnement similaire à Jupyter pour l’exécution de notebooks Spark. Elle est utile pour les analyses de données à grande échelle.\nKaggle Kernels: Offre un environnement similaire à Jupyter Notebook avec l’accès gratuit à des GPU et TPU. Il est intégré à la plateforme Kaggle, permettant aux utilisateurs de travailler sur des datasets complexes et de participer à des compétitions de data science.\nAzure Notebooks: Service proposé par Microsoft, similaire à Jupyter Notebooks, mais intégré dans l’écosystème Azure. Il permet de créer, de partager et de gérer des notebooks dans le cloud.\n\nChoix de la Plateforme:\n\nLe choix entre ces différentes plateformes dépend de plusieurs facteurs tels que les ressources de calcul nécessaires, la facilité de partage et de collaboration, l’intégration avec d’autres services et outils, et les préférences personnelles ou organisationnelles.\n\n\nCes plateformes offrent une flexibilité et des fonctionnalités puissantes pour le développement interactif, l’exploration de données, et le machine learning, rendant l’analyse de données et la recherche scientifique plus accessibles et collaboratives.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Les Notebooks"
    ]
  },
  {
    "objectID": "content/Cours_1/5-PathandVirtualEnv.html",
    "href": "content/Cours_1/5-PathandVirtualEnv.html",
    "title": "Path.. et environnements virtuels!",
    "section": "",
    "text": "PATH et les Environnements Virtuels avec Pyenv\nPyenv est un outil populaire pour la gestion des versions de Python. Il permet aux développeurs d’installer et de basculer facilement entre plusieurs versions de Python sur un même système. Cette flexibilité est particulièrement utile dans des environnements de développement où différents projets nécessitent différentes versions de Python.\n\n\nPartie 1 : Pyenv et la Gestion de Versions Python\n\nIntroduction à Pyenv\nPyenv est un outil populaire pour la gestion des versions de Python. Il permet aux développeurs d’installer et de basculer facilement entre plusieurs versions de Python sur un même système. Cette flexibilité est particulièrement utile dans des environnements de développement où différents projets nécessitent différentes versions de Python.\n\n\nFonctionnement de Pyenv\n\nInstallation et Configuration :\n\nL’installation de pyenv implique l’ajout d’un script d’initialisation dans le fichier de configuration du shell (comme .bashrc, .zshrc).\nCe script ajuste la variable PATH pour inclure un chemin vers les shims de pyenv.\n\nLes Shims de Pyenv :\n\nLes shims sont des scripts intermédiaires qui interceptent les appels à Python et redirigent vers la version appropriée.\nLorsqu’un utilisateur exécute python, le shim de pyenv est appelé, qui détermine ensuite quelle version de Python doit être utilisée.\n\nGestion des Versions Python :\n\nPyenv permet de définir une version globale de Python pour l’ensemble du système ou des versions locales pour des répertoires spécifiques.\nLes versions de Python sont gérées en modifiant la variable PATH via les shims, permettant un basculement facile entre différentes versions.\n\nAvantages de Pyenv :\n\nFlexibilité et facilité de basculement entre différentes versions de Python.\nGestion aisée des dépendances spécifiques aux versions pour des projets variés.\nSolution idéale pour tester et développer des applications compatibles avec différentes versions de Python.\n\n\n\n\nInteraction de Pyenv avec PATH\nPyenv modifie PATH pour prioriser ses shims, qui redirigent ensuite les appels à Python vers la version spécifique configurée. Cette manipulation de PATH est au cœur de la fonctionnalité de pyenv, permettant une gestion transparente de multiples versions de Python.\n\n\n\nPYTHONPATH et Son Rôle dans la Configuration Python\n\nIntroduction à PYTHONPATH\nPYTHONPATH est une variable d’environnement utilisée par Python pour déterminer quels répertoires le système doit inclure dans le front-end de son chemin de recherche de modules. C’est une extension de la variable sys.path, qui est une liste de chaînes de caractères définissant les chemins d’accès pour les modules Python.\n\n\nFonctionnement de PYTHONPATH\n\nPrincipes de Base :\n\nQuand Python démarre, il initialise sys.path avec les emplacements par défaut pour les modules standard et les répertoires de site-packages.\nPYTHONPATH permet d’ajouter des répertoires supplémentaires où Python recherchera des modules à importer.\n\nUtilisation de PYTHONPATH :\n\nLes développeurs peuvent ajouter des chemins de répertoires personnalisés à PYTHONPATH pour rendre leurs modules ou packages personnalisés accessibles à travers tout le système.\nCela est utile quand les modules ne sont pas installés dans les répertoires standards.\n\nModification de PYTHONPATH :\n\nSous Windows, PYTHONPATH peut être modifié via les variables d’environnement dans les propriétés système.\nSous Linux et MacOS, on peut modifier PYTHONPATH en ajoutant export PYTHONPATH=/chemin/de/votre/module:$PYTHONPATH dans les fichiers de configuration du shell comme .bashrc ou .bash_profile.\n\nImplications de PYTHONPATH :\n\nUne bonne gestion de PYTHONPATH est essentielle pour s’assurer que les scripts Python accèdent aux bons modules et packages.\nUn PYTHONPATH mal configuré peut entraîner des conflits de modules ou des erreurs d’importation.\n\n\n\n\nDistinction entre PYTHONPATH et PATH\nBien que PATH et PYTHONPATH soient des variables d’environnement, elles servent des buts différents : - PATH est utilisé par le système d’exploitation pour localiser les fichiers exécutables. - PYTHONPATH est spécifique à Python et indique à l’interpréteur où chercher les modules pour les importations.\n\n\nGestionnaires de Bibliothèques et Environnements Virtuels: Pipenv et Poetry\nAu-delà de la gestion des versions de Python, la gestion des bibliothèques et des dépendances est un autre aspect crucial du développement Python. Deux outils populaires dans ce domaine sont Pipenv et Poetry. Voici comment ils fonctionnent et interagissent avec la notion de PATH : ### Partie 3 : Pipenv - Gestion des Bibliothèques et Environnements Virtuels\n\n\nIntroduction à Pipenv\nPipenv est un outil de gestion pour les projets Python qui combine la gestion des packages avec la gestion des environnements virtuels. Il est conçu pour offrir un workflow simplifié pour le développement de projets Python.\n\n\nFonctionnement de Pipenv\n\nGestion des Dépendances :\n\nPipenv utilise le fichier Pipfile pour déclarer les dépendances de projet, remplaçant les traditionnels requirements.txt.\nPipfile.lock est généré pour verrouiller les versions exactes des dépendances, assurant ainsi la reproductibilité des environnements.\n\nCréation d’Environnements Virtuels :\n\nLorsqu’un projet est initié avec Pipenv (par pipenv install), il crée automatiquement un environnement virtuel dédié à ce projet.\nCela isole les dépendances du projet des autres projets et du système global.\n\nActivation des Environnements Virtuels :\n\nPour activer l’environnement virtuel de Pipenv, utilisez la commande pipenv shell.\nCette action ajuste temporairement la variable PATH pour que les commandes python et pip fassent référence à l’environnement virtuel spécifique du projet.\n\nAvantages de Pipenv :\n\nSimplification de la gestion des dépendances et des environnements virtuels.\nAmélioration de la reproductibilité et de la cohérence entre les environnements de développement et de production.\nFacilité d’utilisation et intégration avec des outils de développement modernes.\n\n\n\n\nInteraction de Pipenv avec PATH\nLorsqu’un environnement virtuel est activé avec Pipenv, PATH est modifié pour que toutes les commandes Python soient redirigées vers l’interpréteur et les bibliothèques de l’environnement virtuel spécifique du projet. Cela garantit que les bonnes versions des packages sont utilisées et que les dépendances de projet sont isolées des autres projets ou de l’environnement global.\n\n\n\nPartie 4 : Poetry - Gestion Avancée des Dépendances et Packaging en Python\n\nIntroduction à Poetry\nPoetry est un outil de gestion des dépendances et de packaging pour les projets Python. Il fournit un système de gestion tout-en-un pour les bibliothèques et les applications, en mettant l’accent sur la facilité d’utilisation, la reproductibilité et la gestion cohérente des dépendances.\n\n\nFonctionnalités Clés de Poetry\n\nGestion des Dépendances :\n\nPoetry utilise le fichier pyproject.toml pour déclarer les dépendances et les métadonnées de projet, adhérant ainsi au standard PEP 518.\nIl gère les dépendances de manière plus intuitive et reproductible, en résolvant automatiquement les conflits de dépendances et en verrouillant les versions avec un fichier poetry.lock.\n\nPackaging et Publication :\n\nPoetry facilite le packaging et la publication de bibliothèques sur des dépôts comme PyPI, en intégrant les outils nécessaires dans un seul workflow.\nIl permet de construire, empaqueter et publier des projets avec des commandes simples et cohérentes.\n\nCréation et Gestion des Environnements Virtuels :\n\nÀ l’instar de Pipenv, Poetry crée automatiquement des environnements virtuels pour isoler les dépendances de chaque projet.\nLorsqu’un projet est activé, Poetry ajuste le PATH pour utiliser l’interpréteur et les outils de cet environnement.\n\n\n\n\nInteraction de Poetry avec PATH\nLorsqu’un environnement virtuel est activé avec Poetry, la variable PATH est modifiée pour diriger les commandes Python vers l’interpréteur spécifique de l’environnement virtuel du projet. Cela permet d’assurer que les dépendances et versions correctes sont utilisées pour chaque projet.\n\n\nAvantages de Poetry\n\nSimplicité et Cohérence : Poetry fournit un workflow clair et cohérent pour la gestion des dépendances et du packaging, simplifiant le processus de développement.\nReproductibilité : Les fichiers pyproject.toml et poetry.lock garantissent que les mêmes versions des dépendances sont installées dans tous les environnements.\nIntégration Facile : Poetry s’intègre facilement dans les systèmes de CI/CD et les flux de travail de développement existants.\n\n\n\n\nPartie 5 : Environnements Virtuels en Python et Exemple avec Docker\n\nA. Qu’est-ce qu’un Environnement Virtuel en Python ?\n\nDéfinition :\n\nUn environnement virtuel en Python est un espace isolé au sein du système qui permet d’exécuter des applications Python dans un contexte séparé, avec ses propres dépendances et interpréteur.\n\nObjectif :\n\nL’objectif principal est de séparer les dépendances requises pour différents projets, évitant ainsi les conflits entre différentes versions des bibliothèques.\n\nComment ils Fonctionnent :\n\nLes environnements virtuels modifient la variable PATH (et d’autres variables d’environnement) pour s’assurer que les commandes Python et pip pointent vers les versions spécifiques à cet environnement.\n\nOutils pour la Création d’Environnements Virtuels :\n\nvenv (intégré dans Python 3.3 et versions ultérieures) et virtualenv sont des outils populaires pour créer des environnements virtuels.\n\n\n\n\nB. Exemple avec Docker\nPour comprendre les environnements virtuels dans un cadre plus large, considérons Docker, une plateforme de conteneurisation qui permet de créer des environnements isolés, appelés conteneurs.\n\nDocker et Isolation :\n\nDocker crée des conteneurs qui sont isolés du système hôte et entre eux. Chaque conteneur peut avoir sa propre configuration, ses propres dépendances et son propre système d’exploitation léger.\n\nComparaison avec les Environnements Virtuels Python :\n\nTandis que les environnements virtuels Python isolent uniquement les dépendances Python, Docker isole l’ensemble du système, y compris le système d’exploitation, les bibliothèques système, etc.\nDocker offre un degré plus élevé d’isolation et de reproductibilité, ce qui est crucial dans les déploiements de production et les systèmes de CI/CD.\n\nUtilisation de Docker avec Python :\n\nVous pouvez créer un conteneur Docker pour un projet Python, où vous installez toutes les dépendances requises, y compris l’interpréteur Python.\nCela garantit que le projet s’exécute dans un environnement contrôlé et cohérent, indépendamment des configurations système de l’hôte.\n\n\n\n\nConclusion sur les Environnements Virtuels\nLes environnements virtuels, qu’ils soient spécifiques à Python ou sous forme de conteneurs Docker, sont essentiels pour maintenir la cohérence des projets, éviter les conflits de dépendances et assurer la reproductibilité des environnements de développement et de production. Ils représentent une pratique standard dans le développement moderne, garantissant que les applications s’exécutent de manière fiable et prévisible dans différents environnements.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Path.. et environnements virtuels!"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/Pycharm.html",
    "href": "content/Cours_1/IDEs/Pycharm.html",
    "title": "PyCharm - L’IDE orienté Python",
    "section": "",
    "text": "Présentation Générale de PyCharm\nPyCharm, développé par JetBrains, est un Environnement de Développement Intégré (IDE) conçu spécifiquement pour Python. Il est reconnu pour son ensemble complet de fonctionnalités qui soutiennent et facilitent le développement en Python. Voyons de plus près ce qui rend PyCharm si apprécié dans la communauté Python.\n\n\n\n1. Fonctionnalités de PyCharm\n\nSupport Intelligent du Code :\n\nPyCharm propose une complétion de code sophistiquée, une vérification d’erreurs en temps réel, et des outils de refactorisation. Ces fonctionnalités aident à augmenter la productivité et à réduire les erreurs potentielles.\n\nIntégration de Frameworks et Bibliothèques :\n\nL’IDE prend en charge de nombreux frameworks Python populaires, comme Django et Flask, ainsi que des bibliothèques scientifiques telles que NumPy et Pandas. Cette intégration facilite le travail sur des projets complexes et spécialisés.\n\nOutils de Débogage et de Test :\n\nPyCharm intègre un débogueur puissant et des outils pour les tests unitaires. Ces outils sont cruciaux pour la maintenance et l’assurance de la qualité du code.\n\nGestion des Systèmes de Version :\n\nCompatible avec divers systèmes de gestion de version tels que Git, SVN, et Mercurial, PyCharm simplifie le suivi des modifications et la collaboration au sein d’équipes de développement.\n\n\n\n\n2. Environnements Virtuels et Gestion des Dépendances\n\nPyCharm simplifie la création et la gestion des environnements virtuels Python, permettant une séparation efficace des dépendances entre les projets.\nL’IDE offre une interface utilisateur intuitive pour la gestion des packages Python, facilitant l’installation et la mise à jour des bibliothèques.\n\n\n\n\n3. Interface Utilisateur et Personnalisation\n\nL’interface de PyCharm est conçue pour être à la fois confortable et productive, avec des options de personnalisation pour l’adapter aux préférences de chaque utilisateur.\nLa prise en charge des plugins permet une extension des fonctionnalités, rendant l’IDE adaptable à divers besoins de développement.\n\n\n\n4. Support pour le Développement Web et la Data Science\n\nPyCharm excelle également dans les domaines du développement web et de la data science. Pour le web, il offre des outils pour HTML, CSS, JavaScript, et des frameworks front-end.\nEn data science, des fonctionnalités comme le support de Jupyter Notebook, la console IPython, et les outils de visualisation de données sont intégrées.\n\n\n\n5. Versions de PyCharm\n\nPyCharm est disponible en deux éditions :\n\nProfessional : une version payante qui offre des fonctionnalités avancées, notamment pour le développement web et la data science.\nCommunity : une version gratuite qui couvre les fonctionnalités de base du développement Python.\n\n\n\n\nConclusion\nPyCharm se distingue comme un choix privilégié pour les développeurs Python grâce à sa gamme étendue de fonctionnalités. Qu’il s’agisse de coder, de tester, de déboguer ou de gérer des projets complexes, PyCharm offre des outils puissants et une expérience de développement intégrée et fluide.\nPour plus d’informations sur PyCharm, consultez la documentation officielle et le getting started guide\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "PyCharm - L'IDE orienté Python"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/Spyder.html",
    "href": "content/Cours_1/IDEs/Spyder.html",
    "title": "Spyder - Un IDE Orienté Science des Données",
    "section": "",
    "text": "Présentation de Spyder\nSpyder est un Environnement de Développement Intégré (IDE) créé spécifiquement pour répondre aux besoins des scientifiques, des ingénieurs et des analystes de données qui utilisent Python. Il se distingue par son orientation vers la science des données, offrant des outils et fonctionnalités adaptés à ce domaine.\n\n\n\n1. Fonctionnalités Clés de Spyder\n\nInterface Utilisateur Intuitive :\n\nSpyder propose une interface épurée, divisée en plusieurs panneaux pour l’édition de code, la console Python, la gestion des variables, et la consultation de la documentation.\nCette organisation facilite la navigation et la gestion simultanée de multiples aspects d’un projet.\n\nIntégration de l’IPython :\n\nLa console IPython intégrée à Spyder permet un développement interactif, idéal pour tester des fragments de code, visualiser des données, et effectuer des analyses exploratoires.\nElle supporte également le tracé en ligne et des fonctionnalités de débogage avancées.\n\nOutils de Débogage et d’Exploration des Données :\n\nSpyder inclut un débogueur puissant et des outils d’exploration de données, tels qu’un explorateur de variables et un visualisateur de matrices.\nCes outils sont particulièrement utiles pour comprendre et analyser des ensembles de données complexes.\n\n\n\n\n2. Support pour la Data Science\n\nSpyder est optimisé pour la data science, offrant une intégration native avec des bibliothèques telles que NumPy, Pandas, Matplotlib et SciPy.\nIl fournit des fonctionnalités spécifiques pour la visualisation de données et l’analyse interactive, facilitant la manipulation et l’interprétation des données.\n\n\n\n3. Gestion des Environnements Virtuels\n\nSpyder permet de gérer facilement les environnements virtuels Python, ce qui est crucial pour maintenir les dépendances spécifiques à chaque projet isolées et gérables.\n\n\n\n\n4. Personnalisation et Extensions\n\nBien que Spyder offre moins d’options d’extensions que des IDE comme VS Code, il permet une personnalisation significative de l’interface utilisateur et de l’expérience de développement.\nSa configuration par défaut est déjà bien adaptée aux besoins de la science des données, réduisant le besoin de personnalisation extensive.\n\n\n\n5. Communauté et Ressources\n\nSpyder bénéficie d’une communauté active de développeurs et d’utilisateurs qui fournissent un soutien solide et une variété de ressources d’apprentissage, ce qui le rend accessible aux nouveaux utilisateurs.\n\n\n\nConclusion\nSpyder est un choix idéal pour les professionnels et les étudiants dans les domaines de la science des données, de l’ingénierie ou de la recherche scientifique. Son orientation vers l’analyse et l’exploration de données, combinée à une interface intuitive, le rend particulièrement adapté pour les tâches d’analyse de données complexes et le développement scientifique.\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "Spyder - Un IDE Orienté Science des Données"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html",
    "href": "content/Cours_1/1-Histoire.html",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Python, un langage de programmation de haut niveau, a été inventé par Guido van Rossum, dont la première version a été publiée en 1991. Ce langage, nommé d’après la série télévisée britannique “Monty Python’s Flying Circus”, a été conçu pour allier clarté syntaxique et puissance fonctionnelle.\nPython a évolué au fil des années, en gardant son principe directeur : une syntaxe qui favorise la lisibilité et la simplicité. Cette approche a conduit à un langage qui est à la fois facile à apprendre pour les débutants et puissant pour les développeurs expérimentés. Python est interprété, ce qui signifie que les scripts sont exécutés ligne par ligne, permettant une débogage et une interaction faciles.\nSa philosophie, encapsulée dans le “Zen de Python” (PEP 20)\n, guide la rédaction de programmes efficaces et lisibles. Il s’agit un ensemble de 19 aphorismes pour écrire de bons programmes en Python. Parmi les plus célèbres, on trouve “Beautiful is better than ugly”, “Explicit is better than implicit” et “Simple is better than complex”. Cette philosophie a été un facteur clé dans le succès de Python, en particulier pour les débutants qui peuvent facilement apprendre le langage et écrire des programmes simples et lisibles et est à garder en tête lors de l’écriture de code Python.\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nPour autant, bien que simple à prendre en main, Python est un langage puissant qui pour être réellement maîtrisé et compris dans sa globalité nécessite de la pratique et de l’expérience. De par son fonctionnement interne, le language permet ainsi à des développeurs expérimentés de trouver des solutions élégantes et efficaces à des problèmes complexes, qui serviront ensuite de base à des bibliothèques et frameworks utilisés par des développeurs bien moins expérimentés qui ne se douteront pas une seconde de ce qui se cache en dessous.\nEn résumé, le succès de Python repose sur plusieurs facteurs : sa simplicité, sa polyvalence (il est utilisé dans le développement web, l’analyse de données, l’intelligence artificielle, la science des données, et bien d’autres domaines), et une communauté active qui contribue à un écosystème riche en bibliothèques et frameworks.\n\n\n\nMais le language existe depuis 1991, et a donc évolué au fil des années. En effet, les besoins comme les machines ont changé, et comme la langue humaine, le language de programmation a évolué pour s’adapter à ces changements.\nCe qui est connu de presque tous, c’est que Python a deux grandes versions : Python 2 et Python 3. Python 2 a été largement utilisé et apprécié, mais en 2020, il a été officiellement abandonné au profit de Python 3, qui a été publié en 2008. Et oui, il a fallu 12 ans pour que Python 3 devienne la version officielle de Python, car les différences entre les versions 2 et 3 étaient importantes, et il a fallu du temps pour que les développeurs s’adaptent.\nCela va de la syntaxe à la gestion de la mémoire, en passant par la gestion des chaînes de caractères et des bibliothèques, et l’un des exemples les plus connus est le passage de print à une fonction, qui a été introduit dans Python 3: - Python 2 : print \"Hello World\" - Python 3 : print(\"Hello World\")\nD’exterieur, cela peut sembler être un changement mineur, mais au niveau de ce que cela signifie en terme de fonctionnement interne, c’est un changement majeur. En effet, dans Python 2, print est un mot clé, alors que dans Python 3, c’est une fonction. Cela signifie que dans Python 2, print est un mot clé qui est interprété par l’interpréteur Python, alors que dans Python 3, print est une fonction qui est appelée par l’interpréteur Python.\nCela cache en fait une forme d’uniformisation du code, car Python a la particularité d’être un language objet, et donc tout est un objet, y compris les fonctions. Cela signifie que les fonctions peuvent être passées en paramètre, et donc que les fonctions peuvent être appelées par d’autres fonctions. Cela permet de créer des fonctions qui peuvent être utilisées dans des contextes différents, et donc de réduire la duplication de code.\nEt bien qu’il ai fallu 12 ans pour que Python 3 devienne la version officielle de Python, il a continué d’évoluer, et continue encore aujourd’hui. En effet, Python en est à sa version 3.12, et bien que les changements ne soient pas aussi fondamentaux, les nouvelles capacités dont se dotent le language reste puissantes. On peut ainsi citer l’évolution continue de L’Asynchronisme en Python : - Emergence de l’Asynchronisme: Python a intégré des concepts d’asynchronisme pour répondre aux besoins modernes en programmation, notamment pour la gestion efficace des opérations I/O et pour le développement d’applications web. - asyncio en Python 3.5: Le module asyncio a été introduit dans Python 3.5, marquant un changement significatif dans la gestion de la concurrence et des opérations asynchrones. Il permet d’écrire du code asynchrone en utilisant la syntaxe async/await, facilitant la création de programmes non bloquants. - Améliorations continues: Depuis Python 3.5, il y a eu des améliorations continues dans les fonctionnalités asynchrones, rendant Python plus adapté pour des applications nécessitant de hautes performances en matière de concurrence et d’asynchronisme.\n\n\n\nPourquoi Python est largement adopté : 1. Facilité d’apprentissage et de lecture: La syntaxe de Python est conçue pour être intuitive et lisible, ce qui rend l’apprentissage du langage plus accessible aux débutants. 2. Polyvalence: Python est utilisé dans divers domaines, tels que le développement web, l’analyse de données, l’intelligence artificielle, et la science des données. 3. Bibliothèques et Frameworks: Python bénéficie d’un écosystème riche, avec des bibliothèques comme NumPy, Pandas, TensorFlow, et Flask, qui étendent ses capacités. 4. Communauté active: Une vaste communauté de développeurs contribue à l’amélioration continue de Python et offre un soutien important via des forums et des ressources en ligne. 5. Interopérabilité: Python peut être intégré avec d’autres langages de programmation, ce qui lui permet de s’adapter à divers environnements et exigences de projet.\nCritiques courantes de Python : 1. Vitesse d’exécution: Étant un langage interprété, Python peut être plus lent que les langages compilés comme C ou Java, particulièrement dans les applications nécessitant de lourds calculs. 2. Gestion de la mémoire: Python utilise une gestion de mémoire automatique qui peut entraîner une consommation de mémoire plus élevée. 3. Dépendance aux bibliothèques: La richesse des bibliothèques Python est à double tranchant. Certains développeurs critiquent la dépendance excessive à des bibliothèques externes pour des fonctionnalités de base. 4. Limitations en matière de programmation mobile et de jeux: Python n’est pas le choix principal pour le développement d’applications mobiles et de jeux en raison de sa vitesse et de sa consommation de ressources. 5. Versionnage: La transition de Python 2 à Python 3 a créé des problèmes de compatibilité, bien que cela se soit amélioré avec le temps.\n\n\n\nCes limites viennent de l’histoire du language, et de ses choix de conception. D’une part, Python est un language interprété, et donc il est plus lent que les languages compilés. Cela vient du fait que l’interpréteur Python doit lire le code, le comprendre, et l’exécuter, alors qu’un compilateur va transformer le code en langage machine, et donc le code est directement exécutable.\nCela vient du typage dynamique de Python, qui permet de ne pas avoir à déclarer le type des variables, et donc de ne pas avoir à réserver de la mémoire pour ces variables. Cela permet de ne pas avoir à se soucier de la mémoire, mais cela a un coût, car l’interpréteur Python doit déterminer le type des variables à l’exécution, et donc cela prend du temps.\nEt cela vient du fait que la language a été développé à une époque où les ordinateurs n’avaient qu’un seul CPU, et donc ne pouvaient exécuter qu’une seule instruction à la fois. Cela a conduit à un language qui n’est pas adapté à la programmation parallèle, et donc qui ne peut pas tirer parti des architectures modernes qui ont plusieurs CPU, et donc peuvent exécuter plusieurs instructions en même temps, du moins pas de la même façon que le peut un language comme C. Ce problème est très connu et se nomme le GIL (Global Interpreter Lock), il est un problème qui est connu depuis longtemps, mais qui n’a pas encore été résolu. Un peu de lecture, pour les plus curieux : Python GIL, Python GIL, Python GIL\n\n\n\nLes PEPs (Python Enhancement Proposals) sont des propositions d’amélioration du langage Python. Ils sont utilisés pour discuter des nouvelles fonctionnalités et des changements de comportement du langage. Ils sont également utilisés pour décrire les normes de codage, les processus de développement et les décisions de conception. Les PEPs sont des documents vivants et peuvent être modifiés à mesure que de nouvelles informations sont disponibles.\nLes PEPs sont numérotés et organisés dans une hiérarchie. Les PEPs sont numérotés de 0 à 9999, et sont organisés en trois catégories : - Informational PEPs (PEP 0-99): Les PEPs informatifs fournissent des informations sur le langage Python ou sur les processus de développement. Ils ne décrivent pas de nouvelles fonctionnalités ou de changements de comportement. - Process PEPs (PEP 100-199): Les PEPs de processus décrivent les processus de développement, les normes de codage et les décisions de conception. - Standards Track PEPs (PEP 200-9999): Les PEPs de la norme de suivi décrivent les nouvelles fonctionnalités et les changements de comportement du langage Python.\nLes PEPs sont écrits en utilisant le format reStructuredText, et sont publiés sur le site web officiel de Python. Les PEPs sont discutés et révisés par la communauté Python, et sont acceptés ou rejetés par le BDFL (Benevolent Dictator For Life), Guido van Rossum.\nDans les derniers PEPs, l’un pourrait changer radicalement Python, le PEP 703 – Making the Global Interpreter Lock Optional in CPython] qui propose de supprimer le GIL, et donc de permettre à Python d’être utilisé pour de la programmation parallèle. Cela permettrait à Python de tirer parti des architectures modernes.\nCela en tête nous pouvons donc commencer à apprendre Python, et à comprendre comment il fonctionne.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.1---origines",
    "href": "content/Cours_1/1-Histoire.html#section-1.1---origines",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Python, un langage de programmation de haut niveau, a été inventé par Guido van Rossum, dont la première version a été publiée en 1991. Ce langage, nommé d’après la série télévisée britannique “Monty Python’s Flying Circus”, a été conçu pour allier clarté syntaxique et puissance fonctionnelle.\nPython a évolué au fil des années, en gardant son principe directeur : une syntaxe qui favorise la lisibilité et la simplicité. Cette approche a conduit à un langage qui est à la fois facile à apprendre pour les débutants et puissant pour les développeurs expérimentés. Python est interprété, ce qui signifie que les scripts sont exécutés ligne par ligne, permettant une débogage et une interaction faciles.\nSa philosophie, encapsulée dans le “Zen de Python” (PEP 20)\n, guide la rédaction de programmes efficaces et lisibles. Il s’agit un ensemble de 19 aphorismes pour écrire de bons programmes en Python. Parmi les plus célèbres, on trouve “Beautiful is better than ugly”, “Explicit is better than implicit” et “Simple is better than complex”. Cette philosophie a été un facteur clé dans le succès de Python, en particulier pour les débutants qui peuvent facilement apprendre le langage et écrire des programmes simples et lisibles et est à garder en tête lors de l’écriture de code Python.\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nPour autant, bien que simple à prendre en main, Python est un langage puissant qui pour être réellement maîtrisé et compris dans sa globalité nécessite de la pratique et de l’expérience. De par son fonctionnement interne, le language permet ainsi à des développeurs expérimentés de trouver des solutions élégantes et efficaces à des problèmes complexes, qui serviront ensuite de base à des bibliothèques et frameworks utilisés par des développeurs bien moins expérimentés qui ne se douteront pas une seconde de ce qui se cache en dessous.\nEn résumé, le succès de Python repose sur plusieurs facteurs : sa simplicité, sa polyvalence (il est utilisé dans le développement web, l’analyse de données, l’intelligence artificielle, la science des données, et bien d’autres domaines), et une communauté active qui contribue à un écosystème riche en bibliothèques et frameworks.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.2---et-évolution",
    "href": "content/Cours_1/1-Histoire.html#section-1.2---et-évolution",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Mais le language existe depuis 1991, et a donc évolué au fil des années. En effet, les besoins comme les machines ont changé, et comme la langue humaine, le language de programmation a évolué pour s’adapter à ces changements.\nCe qui est connu de presque tous, c’est que Python a deux grandes versions : Python 2 et Python 3. Python 2 a été largement utilisé et apprécié, mais en 2020, il a été officiellement abandonné au profit de Python 3, qui a été publié en 2008. Et oui, il a fallu 12 ans pour que Python 3 devienne la version officielle de Python, car les différences entre les versions 2 et 3 étaient importantes, et il a fallu du temps pour que les développeurs s’adaptent.\nCela va de la syntaxe à la gestion de la mémoire, en passant par la gestion des chaînes de caractères et des bibliothèques, et l’un des exemples les plus connus est le passage de print à une fonction, qui a été introduit dans Python 3: - Python 2 : print \"Hello World\" - Python 3 : print(\"Hello World\")\nD’exterieur, cela peut sembler être un changement mineur, mais au niveau de ce que cela signifie en terme de fonctionnement interne, c’est un changement majeur. En effet, dans Python 2, print est un mot clé, alors que dans Python 3, c’est une fonction. Cela signifie que dans Python 2, print est un mot clé qui est interprété par l’interpréteur Python, alors que dans Python 3, print est une fonction qui est appelée par l’interpréteur Python.\nCela cache en fait une forme d’uniformisation du code, car Python a la particularité d’être un language objet, et donc tout est un objet, y compris les fonctions. Cela signifie que les fonctions peuvent être passées en paramètre, et donc que les fonctions peuvent être appelées par d’autres fonctions. Cela permet de créer des fonctions qui peuvent être utilisées dans des contextes différents, et donc de réduire la duplication de code.\nEt bien qu’il ai fallu 12 ans pour que Python 3 devienne la version officielle de Python, il a continué d’évoluer, et continue encore aujourd’hui. En effet, Python en est à sa version 3.12, et bien que les changements ne soient pas aussi fondamentaux, les nouvelles capacités dont se dotent le language reste puissantes. On peut ainsi citer l’évolution continue de L’Asynchronisme en Python : - Emergence de l’Asynchronisme: Python a intégré des concepts d’asynchronisme pour répondre aux besoins modernes en programmation, notamment pour la gestion efficace des opérations I/O et pour le développement d’applications web. - asyncio en Python 3.5: Le module asyncio a été introduit dans Python 3.5, marquant un changement significatif dans la gestion de la concurrence et des opérations asynchrones. Il permet d’écrire du code asynchrone en utilisant la syntaxe async/await, facilitant la création de programmes non bloquants. - Améliorations continues: Depuis Python 3.5, il y a eu des améliorations continues dans les fonctionnalités asynchrones, rendant Python plus adapté pour des applications nécessitant de hautes performances en matière de concurrence et d’asynchronisme.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.3-----popularité-et-critiques",
    "href": "content/Cours_1/1-Histoire.html#section-1.3-----popularité-et-critiques",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Pourquoi Python est largement adopté : 1. Facilité d’apprentissage et de lecture: La syntaxe de Python est conçue pour être intuitive et lisible, ce qui rend l’apprentissage du langage plus accessible aux débutants. 2. Polyvalence: Python est utilisé dans divers domaines, tels que le développement web, l’analyse de données, l’intelligence artificielle, et la science des données. 3. Bibliothèques et Frameworks: Python bénéficie d’un écosystème riche, avec des bibliothèques comme NumPy, Pandas, TensorFlow, et Flask, qui étendent ses capacités. 4. Communauté active: Une vaste communauté de développeurs contribue à l’amélioration continue de Python et offre un soutien important via des forums et des ressources en ligne. 5. Interopérabilité: Python peut être intégré avec d’autres langages de programmation, ce qui lui permet de s’adapter à divers environnements et exigences de projet.\nCritiques courantes de Python : 1. Vitesse d’exécution: Étant un langage interprété, Python peut être plus lent que les langages compilés comme C ou Java, particulièrement dans les applications nécessitant de lourds calculs. 2. Gestion de la mémoire: Python utilise une gestion de mémoire automatique qui peut entraîner une consommation de mémoire plus élevée. 3. Dépendance aux bibliothèques: La richesse des bibliothèques Python est à double tranchant. Certains développeurs critiquent la dépendance excessive à des bibliothèques externes pour des fonctionnalités de base. 4. Limitations en matière de programmation mobile et de jeux: Python n’est pas le choix principal pour le développement d’applications mobiles et de jeux en raison de sa vitesse et de sa consommation de ressources. 5. Versionnage: La transition de Python 2 à Python 3 a créé des problèmes de compatibilité, bien que cela se soit amélioré avec le temps.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.4---comprendre-ces-limites",
    "href": "content/Cours_1/1-Histoire.html#section-1.4---comprendre-ces-limites",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Ces limites viennent de l’histoire du language, et de ses choix de conception. D’une part, Python est un language interprété, et donc il est plus lent que les languages compilés. Cela vient du fait que l’interpréteur Python doit lire le code, le comprendre, et l’exécuter, alors qu’un compilateur va transformer le code en langage machine, et donc le code est directement exécutable.\nCela vient du typage dynamique de Python, qui permet de ne pas avoir à déclarer le type des variables, et donc de ne pas avoir à réserver de la mémoire pour ces variables. Cela permet de ne pas avoir à se soucier de la mémoire, mais cela a un coût, car l’interpréteur Python doit déterminer le type des variables à l’exécution, et donc cela prend du temps.\nEt cela vient du fait que la language a été développé à une époque où les ordinateurs n’avaient qu’un seul CPU, et donc ne pouvaient exécuter qu’une seule instruction à la fois. Cela a conduit à un language qui n’est pas adapté à la programmation parallèle, et donc qui ne peut pas tirer parti des architectures modernes qui ont plusieurs CPU, et donc peuvent exécuter plusieurs instructions en même temps, du moins pas de la même façon que le peut un language comme C. Ce problème est très connu et se nomme le GIL (Global Interpreter Lock), il est un problème qui est connu depuis longtemps, mais qui n’a pas encore été résolu. Un peu de lecture, pour les plus curieux : Python GIL, Python GIL, Python GIL",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.5---les-peps",
    "href": "content/Cours_1/1-Histoire.html#section-1.5---les-peps",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Les PEPs (Python Enhancement Proposals) sont des propositions d’amélioration du langage Python. Ils sont utilisés pour discuter des nouvelles fonctionnalités et des changements de comportement du langage. Ils sont également utilisés pour décrire les normes de codage, les processus de développement et les décisions de conception. Les PEPs sont des documents vivants et peuvent être modifiés à mesure que de nouvelles informations sont disponibles.\nLes PEPs sont numérotés et organisés dans une hiérarchie. Les PEPs sont numérotés de 0 à 9999, et sont organisés en trois catégories : - Informational PEPs (PEP 0-99): Les PEPs informatifs fournissent des informations sur le langage Python ou sur les processus de développement. Ils ne décrivent pas de nouvelles fonctionnalités ou de changements de comportement. - Process PEPs (PEP 100-199): Les PEPs de processus décrivent les processus de développement, les normes de codage et les décisions de conception. - Standards Track PEPs (PEP 200-9999): Les PEPs de la norme de suivi décrivent les nouvelles fonctionnalités et les changements de comportement du langage Python.\nLes PEPs sont écrits en utilisant le format reStructuredText, et sont publiés sur le site web officiel de Python. Les PEPs sont discutés et révisés par la communauté Python, et sont acceptés ou rejetés par le BDFL (Benevolent Dictator For Life), Guido van Rossum.\nDans les derniers PEPs, l’un pourrait changer radicalement Python, le PEP 703 – Making the Global Interpreter Lock Optional in CPython] qui propose de supprimer le GIL, et donc de permettre à Python d’être utilisé pour de la programmation parallèle. Cela permettrait à Python de tirer parti des architectures modernes.\nCela en tête nous pouvons donc commencer à apprendre Python, et à comprendre comment il fonctionne.",
    "crumbs": [
      "Histoire du Langage"
    ]
  }
]