[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction à Python !",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "index.html#rémi-genet",
    "href": "index.html#rémi-genet",
    "title": "Introduction à Python !",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "content/Cours_1/6-IDEs.html",
    "href": "content/Cours_1/6-IDEs.html",
    "title": "Les IDEs",
    "section": "",
    "text": "A. Définition et Objectif des IDE\n\nQu’est-ce qu’un IDE ?\n\nUn Environnement de Développement Intégré (IDE) est une application logicielle qui fournit des outils complets et intégrés pour le développement de logiciels.\nIl combine un éditeur de code, un compilateur ou interpréteur, un débogueur, et souvent des outils supplémentaires dans une interface unifiée.\n\nObjectif d’un IDE\n\nL’objectif principal d’un IDE est de maximiser la productivité du développeur en simplifiant le processus de développement avec des outils intégrés et une interface utilisateur conviviale.\nIl vise à réduire la complexité de configuration des différents outils nécessaires au développement.\n\n\n\n\nB. Fonctionnalités Clés des IDE pour Python\n\nÉditeur de Code\n\nPropose la coloration syntaxique, l’auto-complétion, et la refactorisation du code pour faciliter la lecture et l’écriture du code Python.\n\nDébogueur\n\nIntègre des fonctionnalités pour exécuter le code pas à pas, inspecter les variables, et identifier les erreurs, rendant le débogage plus intuitif.\n\nGestion des Projets\n\nOffre des outils pour organiser et gérer les fichiers de code, ressources, et dépendances, améliorant la structure et la maintenabilité des projets.\n\nIntégration de Contrôle de Version\n\nIntègre des systèmes de contrôle de version comme Git, facilitant la gestion des versions et la collaboration entre développeurs.\n\nConsole et Terminal Intégrés\n\nPermet l’exécution de scripts Python et l’interaction avec l’interpréteur directement dans l’IDE, offrant une expérience de développement fluide.\n\nSupport des Frameworks et Bibliothèques\n\nFournit une intégration avec des frameworks de développement web, de science des données, et d’autres bibliothèques Python, facilitant le développement dans des domaines spécifiques.\n\n\n\n\nC. Rôle des IDE dans le Développement Python\n\nProductivité et Efficacité\n\nLes IDE accélèrent le processus de développement en automatisant les tâches répétitives et en fournissant des raccourcis pratiques.\n\nQualité et Cohérence du Code\n\nLes fonctionnalités comme la vérification de syntaxe, la refactorisation et le formatage du code contribuent à maintenir une haute qualité et une cohérence du code.\n\nApprentissage et Accessibilité\n\nPour les débutants, les IDE peuvent simplifier l’apprentissage du langage Python en offrant une interface plus accessible et des outils d’aide à la programmation.\n\nCollaboration et Travail d’Équipe\n\nLes outils intégrés de gestion de versions et de collaboration facilitent le travail en équipe, en particulier sur de grands projets avec de nombreux contributeurs.\n\n\n\n\nD. Choisir un IDE pour Python\nLe choix d’un IDE dépend de plusieurs facteurs : - Niveau d’Expérience : Certains IDE sont mieux adaptés aux débutants avec des interfaces plus simples, tandis que d’autres offrent des fonctionnalités avancées pour les développeurs expérimentés. - Type de Projet : Selon le projet (développement web, data science, scripts), certains IDE offrent des outils et intégrations spécifiques plus adaptés. - Préférences Personnelles : L’interface utilisateur, la configuration et les extensions disponibles peuvent influencer le choix d’un IDE.\nLes IDEs jouent un rôle essentiel dans le développement moderne en fournissant un environnement riche et intégré pour le codage, le test, le débogage et le déploiement de logiciels. Pour les développeurs Python, le choix d’un IDE adapté peut grandement affecter l’efficacité et la qualité du processus de développement.\nPycharm Spyder VsCode\n\n\n\n\n Back to top",
    "crumbs": [
      "Les IDEs"
    ]
  },
  {
    "objectID": "content/Cours_1/index.html",
    "href": "content/Cours_1/index.html",
    "title": "Comprendre Et Installer Python",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExécution d’un Programme Python\n\n\nExplorer les mécanismes sous-jacents à l’exécution d’un programme Python pour une compréhension approfondie des processus de compilation et d’interprétation.\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistoire du Langage\n\n\nExplorer l’histoire de Python, c’est comprendre ses choix de conception, son évolution et sa place actuelle dans le monde de la programmation. Ce chapitre se concentre sur…\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLe PATH\n\n\nExplorer la notion de PATH, un élément essentiel dans la configuration des environnements de développement.\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes IDEs\n\n\nChoisir son IDE, une question de goûts mais un impact important sur la productivité.\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes Notebooks\n\n\nLeS Notebooks représentent l’un des support de choix pour la recherche et la datascience, et sont un outil formidable pour une utilisation interractive de Python\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPath.. et environnements virtuels!\n\n\nLes outils pour gerer plusieurs versions de python facilement, et le concept d’environnements virtuels -\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP - Construire son python depuis la source\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVersions et Compilation de Python\n\n\nExplorer les diverses implémentations de Python et le processus de compilation pour comprendre la diversité et la flexibilité du langage.\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Comprendre Et Installer Python"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/Spyder.html",
    "href": "content/Cours_1/IDEs/Spyder.html",
    "title": "Spyder - Un IDE Orienté Science des Données",
    "section": "",
    "text": "Présentation de Spyder\nSpyder est un Environnement de Développement Intégré (IDE) créé spécifiquement pour répondre aux besoins des scientifiques, des ingénieurs et des analystes de données qui utilisent Python. Il se distingue par son orientation vers la science des données, offrant des outils et fonctionnalités adaptés à ce domaine.\n\n\n\n1. Fonctionnalités Clés de Spyder\n\nInterface Utilisateur Intuitive :\n\nSpyder propose une interface épurée, divisée en plusieurs panneaux pour l’édition de code, la console Python, la gestion des variables, et la consultation de la documentation.\nCette organisation facilite la navigation et la gestion simultanée de multiples aspects d’un projet.\n\nIntégration de l’IPython :\n\nLa console IPython intégrée à Spyder permet un développement interactif, idéal pour tester des fragments de code, visualiser des données, et effectuer des analyses exploratoires.\nElle supporte également le tracé en ligne et des fonctionnalités de débogage avancées.\n\nOutils de Débogage et d’Exploration des Données :\n\nSpyder inclut un débogueur puissant et des outils d’exploration de données, tels qu’un explorateur de variables et un visualisateur de matrices.\nCes outils sont particulièrement utiles pour comprendre et analyser des ensembles de données complexes.\n\n\n\n\n2. Support pour la Data Science\n\nSpyder est optimisé pour la data science, offrant une intégration native avec des bibliothèques telles que NumPy, Pandas, Matplotlib et SciPy.\nIl fournit des fonctionnalités spécifiques pour la visualisation de données et l’analyse interactive, facilitant la manipulation et l’interprétation des données.\n\n\n\n3. Gestion des Environnements Virtuels\n\nSpyder permet de gérer facilement les environnements virtuels Python, ce qui est crucial pour maintenir les dépendances spécifiques à chaque projet isolées et gérables.\n\n\n\n\n4. Personnalisation et Extensions\n\nBien que Spyder offre moins d’options d’extensions que des IDE comme VS Code, il permet une personnalisation significative de l’interface utilisateur et de l’expérience de développement.\nSa configuration par défaut est déjà bien adaptée aux besoins de la science des données, réduisant le besoin de personnalisation extensive.\n\n\n\n5. Communauté et Ressources\n\nSpyder bénéficie d’une communauté active de développeurs et d’utilisateurs qui fournissent un soutien solide et une variété de ressources d’apprentissage, ce qui le rend accessible aux nouveaux utilisateurs.\n\n\n\nConclusion\nSpyder est un choix idéal pour les professionnels et les étudiants dans les domaines de la science des données, de l’ingénierie ou de la recherche scientifique. Son orientation vers l’analyse et l’exploration de données, combinée à une interface intuitive, le rend particulièrement adapté pour les tâches d’analyse de données complexes et le développement scientifique.\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "Spyder - Un IDE Orienté Science des Données"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/Pycharm.html",
    "href": "content/Cours_1/IDEs/Pycharm.html",
    "title": "PyCharm - L’IDE orienté Python",
    "section": "",
    "text": "Présentation Générale de PyCharm\nPyCharm, développé par JetBrains, est un Environnement de Développement Intégré (IDE) conçu spécifiquement pour Python. Il est reconnu pour son ensemble complet de fonctionnalités qui soutiennent et facilitent le développement en Python. Voyons de plus près ce qui rend PyCharm si apprécié dans la communauté Python.\n\n\n\n1. Fonctionnalités de PyCharm\n\nSupport Intelligent du Code :\n\nPyCharm propose une complétion de code sophistiquée, une vérification d’erreurs en temps réel, et des outils de refactorisation. Ces fonctionnalités aident à augmenter la productivité et à réduire les erreurs potentielles.\n\nIntégration de Frameworks et Bibliothèques :\n\nL’IDE prend en charge de nombreux frameworks Python populaires, comme Django et Flask, ainsi que des bibliothèques scientifiques telles que NumPy et Pandas. Cette intégration facilite le travail sur des projets complexes et spécialisés.\n\nOutils de Débogage et de Test :\n\nPyCharm intègre un débogueur puissant et des outils pour les tests unitaires. Ces outils sont cruciaux pour la maintenance et l’assurance de la qualité du code.\n\nGestion des Systèmes de Version :\n\nCompatible avec divers systèmes de gestion de version tels que Git, SVN, et Mercurial, PyCharm simplifie le suivi des modifications et la collaboration au sein d’équipes de développement.\n\n\n\n\n2. Environnements Virtuels et Gestion des Dépendances\n\nPyCharm simplifie la création et la gestion des environnements virtuels Python, permettant une séparation efficace des dépendances entre les projets.\nL’IDE offre une interface utilisateur intuitive pour la gestion des packages Python, facilitant l’installation et la mise à jour des bibliothèques.\n\n\n\n\n3. Interface Utilisateur et Personnalisation\n\nL’interface de PyCharm est conçue pour être à la fois confortable et productive, avec des options de personnalisation pour l’adapter aux préférences de chaque utilisateur.\nLa prise en charge des plugins permet une extension des fonctionnalités, rendant l’IDE adaptable à divers besoins de développement.\n\n\n\n4. Support pour le Développement Web et la Data Science\n\nPyCharm excelle également dans les domaines du développement web et de la data science. Pour le web, il offre des outils pour HTML, CSS, JavaScript, et des frameworks front-end.\nEn data science, des fonctionnalités comme le support de Jupyter Notebook, la console IPython, et les outils de visualisation de données sont intégrées.\n\n\n\n5. Versions de PyCharm\n\nPyCharm est disponible en deux éditions :\n\nProfessional : une version payante qui offre des fonctionnalités avancées, notamment pour le développement web et la data science.\nCommunity : une version gratuite qui couvre les fonctionnalités de base du développement Python.\n\n\n\n\nConclusion\nPyCharm se distingue comme un choix privilégié pour les développeurs Python grâce à sa gamme étendue de fonctionnalités. Qu’il s’agisse de coder, de tester, de déboguer ou de gérer des projets complexes, PyCharm offre des outils puissants et une expérience de développement intégrée et fluide.\nPour plus d’informations sur PyCharm, consultez la documentation officielle et le getting started guide\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "PyCharm - L'IDE orienté Python"
    ]
  },
  {
    "objectID": "content/Cours_1/5-PathandVirtualEnv.html",
    "href": "content/Cours_1/5-PathandVirtualEnv.html",
    "title": "Path.. et environnements virtuels!",
    "section": "",
    "text": "PATH et les Environnements Virtuels avec Pyenv\nPyenv est un outil populaire pour la gestion des versions de Python. Il permet aux développeurs d’installer et de basculer facilement entre plusieurs versions de Python sur un même système. Cette flexibilité est particulièrement utile dans des environnements de développement où différents projets nécessitent différentes versions de Python.\n\n\nPartie 1 : Pyenv et la Gestion de Versions Python\n\nIntroduction à Pyenv\nPyenv est un outil populaire pour la gestion des versions de Python. Il permet aux développeurs d’installer et de basculer facilement entre plusieurs versions de Python sur un même système. Cette flexibilité est particulièrement utile dans des environnements de développement où différents projets nécessitent différentes versions de Python.\n\n\nFonctionnement de Pyenv\n\nInstallation et Configuration :\n\nL’installation de pyenv implique l’ajout d’un script d’initialisation dans le fichier de configuration du shell (comme .bashrc, .zshrc).\nCe script ajuste la variable PATH pour inclure un chemin vers les shims de pyenv.\n\nLes Shims de Pyenv :\n\nLes shims sont des scripts intermédiaires qui interceptent les appels à Python et redirigent vers la version appropriée.\nLorsqu’un utilisateur exécute python, le shim de pyenv est appelé, qui détermine ensuite quelle version de Python doit être utilisée.\n\nGestion des Versions Python :\n\nPyenv permet de définir une version globale de Python pour l’ensemble du système ou des versions locales pour des répertoires spécifiques.\nLes versions de Python sont gérées en modifiant la variable PATH via les shims, permettant un basculement facile entre différentes versions.\n\nAvantages de Pyenv :\n\nFlexibilité et facilité de basculement entre différentes versions de Python.\nGestion aisée des dépendances spécifiques aux versions pour des projets variés.\nSolution idéale pour tester et développer des applications compatibles avec différentes versions de Python.\n\n\n\n\nInteraction de Pyenv avec PATH\nPyenv modifie PATH pour prioriser ses shims, qui redirigent ensuite les appels à Python vers la version spécifique configurée. Cette manipulation de PATH est au cœur de la fonctionnalité de pyenv, permettant une gestion transparente de multiples versions de Python.\n\n\n\nPYTHONPATH et Son Rôle dans la Configuration Python\n\nIntroduction à PYTHONPATH\nPYTHONPATH est une variable d’environnement utilisée par Python pour déterminer quels répertoires le système doit inclure dans le front-end de son chemin de recherche de modules. C’est une extension de la variable sys.path, qui est une liste de chaînes de caractères définissant les chemins d’accès pour les modules Python.\n\n\nFonctionnement de PYTHONPATH\n\nPrincipes de Base :\n\nQuand Python démarre, il initialise sys.path avec les emplacements par défaut pour les modules standard et les répertoires de site-packages.\nPYTHONPATH permet d’ajouter des répertoires supplémentaires où Python recherchera des modules à importer.\n\nUtilisation de PYTHONPATH :\n\nLes développeurs peuvent ajouter des chemins de répertoires personnalisés à PYTHONPATH pour rendre leurs modules ou packages personnalisés accessibles à travers tout le système.\nCela est utile quand les modules ne sont pas installés dans les répertoires standards.\n\nModification de PYTHONPATH :\n\nSous Windows, PYTHONPATH peut être modifié via les variables d’environnement dans les propriétés système.\nSous Linux et MacOS, on peut modifier PYTHONPATH en ajoutant export PYTHONPATH=/chemin/de/votre/module:$PYTHONPATH dans les fichiers de configuration du shell comme .bashrc ou .bash_profile.\n\nImplications de PYTHONPATH :\n\nUne bonne gestion de PYTHONPATH est essentielle pour s’assurer que les scripts Python accèdent aux bons modules et packages.\nUn PYTHONPATH mal configuré peut entraîner des conflits de modules ou des erreurs d’importation.\n\n\n\n\nDistinction entre PYTHONPATH et PATH\nBien que PATH et PYTHONPATH soient des variables d’environnement, elles servent des buts différents : - PATH est utilisé par le système d’exploitation pour localiser les fichiers exécutables. - PYTHONPATH est spécifique à Python et indique à l’interpréteur où chercher les modules pour les importations.\n\n\nGestionnaires de Bibliothèques et Environnements Virtuels: Pipenv et Poetry\nAu-delà de la gestion des versions de Python, la gestion des bibliothèques et des dépendances est un autre aspect crucial du développement Python. Deux outils populaires dans ce domaine sont Pipenv et Poetry. Voici comment ils fonctionnent et interagissent avec la notion de PATH : ### Partie 3 : Pipenv - Gestion des Bibliothèques et Environnements Virtuels\n\n\nIntroduction à Pipenv\nPipenv est un outil de gestion pour les projets Python qui combine la gestion des packages avec la gestion des environnements virtuels. Il est conçu pour offrir un workflow simplifié pour le développement de projets Python.\n\n\nFonctionnement de Pipenv\n\nGestion des Dépendances :\n\nPipenv utilise le fichier Pipfile pour déclarer les dépendances de projet, remplaçant les traditionnels requirements.txt.\nPipfile.lock est généré pour verrouiller les versions exactes des dépendances, assurant ainsi la reproductibilité des environnements.\n\nCréation d’Environnements Virtuels :\n\nLorsqu’un projet est initié avec Pipenv (par pipenv install), il crée automatiquement un environnement virtuel dédié à ce projet.\nCela isole les dépendances du projet des autres projets et du système global.\n\nActivation des Environnements Virtuels :\n\nPour activer l’environnement virtuel de Pipenv, utilisez la commande pipenv shell.\nCette action ajuste temporairement la variable PATH pour que les commandes python et pip fassent référence à l’environnement virtuel spécifique du projet.\n\nAvantages de Pipenv :\n\nSimplification de la gestion des dépendances et des environnements virtuels.\nAmélioration de la reproductibilité et de la cohérence entre les environnements de développement et de production.\nFacilité d’utilisation et intégration avec des outils de développement modernes.\n\n\n\n\nInteraction de Pipenv avec PATH\nLorsqu’un environnement virtuel est activé avec Pipenv, PATH est modifié pour que toutes les commandes Python soient redirigées vers l’interpréteur et les bibliothèques de l’environnement virtuel spécifique du projet. Cela garantit que les bonnes versions des packages sont utilisées et que les dépendances de projet sont isolées des autres projets ou de l’environnement global.\n\n\n\nPartie 4 : Poetry - Gestion Avancée des Dépendances et Packaging en Python\n\nIntroduction à Poetry\nPoetry est un outil de gestion des dépendances et de packaging pour les projets Python. Il fournit un système de gestion tout-en-un pour les bibliothèques et les applications, en mettant l’accent sur la facilité d’utilisation, la reproductibilité et la gestion cohérente des dépendances.\n\n\nFonctionnalités Clés de Poetry\n\nGestion des Dépendances :\n\nPoetry utilise le fichier pyproject.toml pour déclarer les dépendances et les métadonnées de projet, adhérant ainsi au standard PEP 518.\nIl gère les dépendances de manière plus intuitive et reproductible, en résolvant automatiquement les conflits de dépendances et en verrouillant les versions avec un fichier poetry.lock.\n\nPackaging et Publication :\n\nPoetry facilite le packaging et la publication de bibliothèques sur des dépôts comme PyPI, en intégrant les outils nécessaires dans un seul workflow.\nIl permet de construire, empaqueter et publier des projets avec des commandes simples et cohérentes.\n\nCréation et Gestion des Environnements Virtuels :\n\nÀ l’instar de Pipenv, Poetry crée automatiquement des environnements virtuels pour isoler les dépendances de chaque projet.\nLorsqu’un projet est activé, Poetry ajuste le PATH pour utiliser l’interpréteur et les outils de cet environnement.\n\n\n\n\nInteraction de Poetry avec PATH\nLorsqu’un environnement virtuel est activé avec Poetry, la variable PATH est modifiée pour diriger les commandes Python vers l’interpréteur spécifique de l’environnement virtuel du projet. Cela permet d’assurer que les dépendances et versions correctes sont utilisées pour chaque projet.\n\n\nAvantages de Poetry\n\nSimplicité et Cohérence : Poetry fournit un workflow clair et cohérent pour la gestion des dépendances et du packaging, simplifiant le processus de développement.\nReproductibilité : Les fichiers pyproject.toml et poetry.lock garantissent que les mêmes versions des dépendances sont installées dans tous les environnements.\nIntégration Facile : Poetry s’intègre facilement dans les systèmes de CI/CD et les flux de travail de développement existants.\n\n\n\n\nPartie 5 : Environnements Virtuels en Python et Exemple avec Docker\n\nA. Qu’est-ce qu’un Environnement Virtuel en Python ?\n\nDéfinition :\n\nUn environnement virtuel en Python est un espace isolé au sein du système qui permet d’exécuter des applications Python dans un contexte séparé, avec ses propres dépendances et interpréteur.\n\nObjectif :\n\nL’objectif principal est de séparer les dépendances requises pour différents projets, évitant ainsi les conflits entre différentes versions des bibliothèques.\n\nComment ils Fonctionnent :\n\nLes environnements virtuels modifient la variable PATH (et d’autres variables d’environnement) pour s’assurer que les commandes Python et pip pointent vers les versions spécifiques à cet environnement.\n\nOutils pour la Création d’Environnements Virtuels :\n\nvenv (intégré dans Python 3.3 et versions ultérieures) et virtualenv sont des outils populaires pour créer des environnements virtuels.\n\n\n\n\nB. Exemple avec Docker\nPour comprendre les environnements virtuels dans un cadre plus large, considérons Docker, une plateforme de conteneurisation qui permet de créer des environnements isolés, appelés conteneurs.\n\nDocker et Isolation :\n\nDocker crée des conteneurs qui sont isolés du système hôte et entre eux. Chaque conteneur peut avoir sa propre configuration, ses propres dépendances et son propre système d’exploitation léger.\n\nComparaison avec les Environnements Virtuels Python :\n\nTandis que les environnements virtuels Python isolent uniquement les dépendances Python, Docker isole l’ensemble du système, y compris le système d’exploitation, les bibliothèques système, etc.\nDocker offre un degré plus élevé d’isolation et de reproductibilité, ce qui est crucial dans les déploiements de production et les systèmes de CI/CD.\n\nUtilisation de Docker avec Python :\n\nVous pouvez créer un conteneur Docker pour un projet Python, où vous installez toutes les dépendances requises, y compris l’interpréteur Python.\nCela garantit que le projet s’exécute dans un environnement contrôlé et cohérent, indépendamment des configurations système de l’hôte.\n\n\n\n\nConclusion sur les Environnements Virtuels\nLes environnements virtuels, qu’ils soient spécifiques à Python ou sous forme de conteneurs Docker, sont essentiels pour maintenir la cohérence des projets, éviter les conflits de dépendances et assurer la reproductibilité des environnements de développement et de production. Ils représentent une pratique standard dans le développement moderne, garantissant que les applications s’exécutent de manière fiable et prévisible dans différents environnements.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Path.. et environnements virtuels!"
    ]
  },
  {
    "objectID": "content/Cours_1/7-Notebooks.html",
    "href": "content/Cours_1/7-Notebooks.html",
    "title": "Les Notebooks",
    "section": "",
    "text": "7. Les Notebooks Jupyter\n\nDifférence entre les Fichiers .py et .ipynb et la Notion de Notebook\nLa distinction entre les fichiers .py et .ipynb est fondamentale dans l’écosystème Python, en particulier pour les tâches de développement et d’analyse de données.\n\nFichiers .py:\n\nNature: Les fichiers .py sont des scripts Python traditionnels. Ils contiennent du code Python pur pouvant être exécuté par l’interpréteur Python.\nUtilisation: Ces fichiers sont généralement utilisés pour le développement d’applications, de scripts, ou de modules Python.\nIDEs et Éditeurs: Ils peuvent être ouverts et exécutés dans n’importe quel éditeur de texte ou IDE comme PyCharm, Visual Studio Code, ou Spyder.\n\nFichiers .ipynb et Notebooks:\n\nNature: Les fichiers avec l’extension .ipynb sont des notebooks Jupyter. Ils permettent de combiner du code exécutable, du texte enrichi (Markdown), des équations (LaTeX), des visualisations et des médias interactifs.\nUtilisation: Ces notebooks sont largement utilisés dans la data science et l’enseignement pour leur capacité à présenter le code, les résultats, et les explications de manière interactive et attrayante.\nEnvironnement: Ils nécessitent un environnement Jupyter pour être exécutés, comme Jupyter Notebook ou JupyterLab.\n\nLa Notion de Notebook:\n\nUn “notebook” est un document numérique qui permet de créer et de partager des documents contenant du code, du texte explicatif, des formules mathématiques et des visualisations.\nLes notebooks sont interactifs : vous pouvez exécuter le code dans des cellules individuelles et voir les résultats immédiatement sous ces cellules, ce qui facilite grandement l’exploration de données et les analyses ad hoc.\n\n\nEn résumé, la différence principale entre .py et .ipynb réside dans leur approche du développement et de la présentation du code. Les fichiers .py sont mieux adaptés pour le développement de logiciels structurés, tandis que les fichiers .ipynb sont idéaux pour l’exploration de données, l’analyse interactive et la documentation de processus.\n\n\nPrésentation de Jupyter\nJupyter est un projet open source qui permet de créer et de partager des documents contenant du code en direct, des équations, des visualisations et du texte narratif. Il est particulièrement populaire dans la data science, l’enseignement des sciences informatiques, et la recherche scientifique. Voici les aspects clés de Jupyter :\n\nJupyter Notebook:\n\nNature et Fonctionnalités : Jupyter Notebook est une application web qui permet de créer et de partager des documents contenant du code interactif (notamment Python), des équations, des visualisations, et du texte explicatif.\nUtilisation : Idéal pour la data science et l’analyse exploratoire, il facilite la visualisation des données et la communication des résultats.\nInteractivité : Les utilisateurs peuvent exécuter le code dans des cellules individuelles, voir les résultats immédiatement, et apporter des modifications en temps réel.\n\nJupyterLab:\n\nÉvolution de Jupyter Notebook : JupyterLab est une interface utilisateur de nouvelle génération pour le projet Jupyter. Il offre toutes les fonctionnalités de Jupyter Notebook, avec une interface plus flexible et extensible.\nInterface Améliorée : Il propose une interface utilisateur modulaire, où les notebooks, les éditeurs de texte, les terminaux, les visualisations de données et d’autres composants peuvent être disposés dans un espace de travail unique.\nExtensions et Personnalisations : JupyterLab permet d’ajouter des extensions, ce qui augmente sa fonctionnalité et sa flexibilité.\n\nSupport Multilingue:\n\nBien que Python soit le langage le plus couramment utilisé, Jupyter supporte de nombreux autres langages de programmation grâce au concept de “kernels”. Un kernel est un moteur de calcul qui exécute le code contenu dans le notebook.\n\nPartage et Collaboration:\n\nLes notebooks Jupyter peuvent être partagés via email, Dropbox, GitHub et Jupyter Notebook Viewer.\nIls facilitent la collaboration et sont souvent utilisés dans l’enseignement et la recherche scientifique pour partager des expériences, des analyses et des rapports.\n\n\nJupyter est devenu un outil incontournable dans les domaines de la data science et de l’éducation en raison de sa capacité à combiner code, données, et narration dans un format interactif et facilement partageable. Son approche modulaire et extensible avec JupyterLab le rend encore plus puissant pour des projets de développement et de recherche complexes.\n\n\nAutres Options pour le Développement Interactif: Google Colab et Alternatives\nOutre Jupyter, il existe d’autres plateformes populaires pour le développement interactif, particulièrement dans le domaine de la data science et du machine learning. Google Colab est l’une des plus remarquables.\n\nGoogle Colab:\n\nNature et Fonctionnalités: Google Colab est un service gratuit hébergé par Google qui permet aux utilisateurs de créer et de partager des documents similaires à Jupyter Notebooks. Il est basé sur Jupyter et offre un environnement Python complet.\nIntégration avec Google Drive: Colab est intégré avec Google Drive, facilitant le partage, l’accès et la collaboration sur des notebooks.\nRessources de Calcul Gratuites: Il offre l’accès à des ressources de calcul gratuites, y compris des GPU et des TPU, ce qui le rend populaire pour les projets de machine learning et de deep learning.\nEnvironnement Préconfiguré: Colab vient préchargé avec de nombreuses bibliothèques populaires, ce qui facilite la mise en place et la réalisation de projets de data science.\n\nAutres Alternatives:\n\nDatabricks Community Edition: Plateforme basée sur le cloud qui offre un environnement similaire à Jupyter pour l’exécution de notebooks Spark. Elle est utile pour les analyses de données à grande échelle.\nKaggle Kernels: Offre un environnement similaire à Jupyter Notebook avec l’accès gratuit à des GPU et TPU. Il est intégré à la plateforme Kaggle, permettant aux utilisateurs de travailler sur des datasets complexes et de participer à des compétitions de data science.\nAzure Notebooks: Service proposé par Microsoft, similaire à Jupyter Notebooks, mais intégré dans l’écosystème Azure. Il permet de créer, de partager et de gérer des notebooks dans le cloud.\n\nChoix de la Plateforme:\n\nLe choix entre ces différentes plateformes dépend de plusieurs facteurs tels que les ressources de calcul nécessaires, la facilité de partage et de collaboration, l’intégration avec d’autres services et outils, et les préférences personnelles ou organisationnelles.\n\n\nCes plateformes offrent une flexibilité et des fonctionnalités puissantes pour le développement interactif, l’exploration de données, et le machine learning, rendant l’analyse de données et la recherche scientifique plus accessibles et collaboratives.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Les Notebooks"
    ]
  },
  {
    "objectID": "content/Cours_5/1-AST.html",
    "href": "content/Cours_5/1-AST.html",
    "title": "L’arbre Syntaxique Abstrait ou AST",
    "section": "",
    "text": "L’arbre Syntaxique Abstrait - Comment revoir ses bases en Python\n\n\nCours sur la Bibliothèque Standard Python et l’Abstract Syntax Tree (AST)\n\nPartie 1: La Valeur de la Bibliothèque Standard Python\n\nIntroduction à la Bibliothèque Standard\nLa bibliothèque standard Python est une collection riche et variée de modules et de fonctions intégrées qui sont automatiquement disponibles dans tout environnement Python. Elle couvre une large gamme de fonctionnalités, des opérations mathématiques aux interactions réseau.\n\n\nPourquoi Utiliser la Bibliothèque Standard\n\nFiabilité : Les modules de la bibliothèque standard sont bien testés et maintenus.\nPortabilité : Le code qui utilise la bibliothèque standard est généralement portable sur toutes les plateformes où Python est disponible.\nPerformance : Certains modules sont implémentés en C, offrant des performances optimales.\nProductivité : Permet de se concentrer sur les aspects uniques du projet, plutôt que de réinventer la roue.\n\n\n\nExemples de Modules Utiles\n\nos et sys pour les interactions système.\nre pour les expressions régulières.\ndatetime pour la manipulation de dates et d’heures.\njson, csv pour la manipulation de fichiers et de données.\n\nEn plus des modules de base, la bibliothèque standard Python offre des outils avancés pour des tâches spécifiques.\nasyncio :\n    Gère la programmation asynchrone, permettant d'écrire du code concurrent en utilisant la syntaxe async/await.\n    Utilisation pour des applications I/O-bound et pour améliorer les performances dans les applications réseau.\n\nthreading et multiprocessing :\n    threading est utilisé pour la programmation multithread, utile pour l'exécution concurrente de plusieurs tâches.\n    multiprocessing permet l'exécution parallèle de code en utilisant plusieurs processus, évitant ainsi le Global Interpreter Lock (GIL) de Python.\n\nfunctools :\n    Fournit des outils pour manipuler les fonctions. La fonction cache (dans Python 3.9+, lru_cache dans les versions antérieures) est particulièrement utile pour mémoriser les résultats des appels de fonctions coûteux.\nExemple d’Utilisation de functools.cache\n\nfrom functools import cache\nimport time\n\ndef fibonacci(n):\n    return n if n &lt; 2 else fibonacci(n-1) + fibonacci(n-2)\n\nt1=time.time()\nprint('result is:', fibonacci(40))\nprint('computation took:', time.time()-t1)\n\n\n@cache\ndef fibonacci(n):\n    return n if n &lt; 2 else fibonacci(n-1) + fibonacci(n-2)\n\nt1=time.time()\nprint('result is:', fibonacci(40))\nprint('computation took:', time.time()-t1)\n\nresult is: 102334155\ncomputation took: 10.7185218334198\nresult is: 102334155\ncomputation took: 4.9591064453125e-05\n\n\n\n\n\n\nLe résultat de fibonacci étant mis en cache le nombre d’appel réel à la fonction est réduit de façon drastique, et le temps d’execution est réduit de facon supra-linéaire.\n\n\nPartie 2: Abstract Syntax Tree (AST) en Python\n\nQu’est-ce que l’AST ?\nL’Abstract Syntax Tree (AST) est une représentation en arbre de la structure syntaxique du code source dans un langage de programmation. En Python, le module ast permet d’interagir et de manipuler ces arbres syntaxiques.\n\n\nUtilisations de l’AST\n\nAnalyse de Code : Permet d’examiner et de comprendre la structure du code.\nModification de Code : On peut transformer le code source avant son exécution.\nCréation d’Outils d’Analyse Statique : Construire des outils personnalisés pour analyser le style ou la qualité du code.\n\n\n\nExemple Simple avec AST\nimport ast\n\ncode = \"\"\"\ndef add(a, b):\n    return a + b\n\"\"\"\n\n# Parse le code source en AST\nparsed_code = ast.parse(code)\n\n# Parcourir et afficher les nœuds de l'AST\nfor node in ast.walk(parsed_code):\n    print(type(node))\n\n\nPourquoi Utiliser l’AST ?\n\nCompréhension Approfondie du Langage : Travailler avec l’AST nécessite une compréhension des éléments syntaxiques de Python, ce qui enrichit la connaissance du langage.\nDéveloppement de Compétences en Analyse de Code : L’AST est au cœur des outils d’analyse statique, et sa manipulation peut développer des compétences avancées en analyse de code.\n\n\n\nProjet avec AST\n\nProjet Suggéré : Créer un outil d’analyse statique simple ou un reformateur de code en utilisant l’AST.\nAvantages : Ce type de projet offre une compréhension pratique de la structure du code Python et peut être un excellent ajout à un portfolio de développeur.\n\n\n\nExemple de Manipulation de l’AST\nimport ast\nimport astor\n\nclass PrintReplacer(ast.NodeTransformer):\n    def visit_Print(self, node):\n        return ast.Expr(value=ast.Call(func=ast.Name(id='print', ctx=ast.Load()), \n                                       args=node.values, keywords=[]))\n\nsource_code = \"\"\"\nprint \"Hello, World!\"\n\"\"\"\n\ntree = ast.parse(source_code)\ntree = PrintReplacer().visit(tree)\nprint(astor.to_source(tree))  # Convertit l'AST modifié en code source\n\n\n\n\nPartie 3: AST pour la Transformation et l’Optimisation du Code\n\nModification du Code avec AST\n\nRefactoring : L’AST permet de refactoriser le code de manière programmatique, ce qui est utile pour les grandes bases de code.\nOptimisation : Peut être utilisé pour identifier et appliquer des optimisations de code.\n\n\n\nExemple d’Optimisation avec AST\nimport astor\n\nclass MyTransformer(ast.NodeTransformer):\n    def visit_BinOp(self, node):\n        if isinstance(node.op, ast.Add):\n            return ast.BinOp(left=node.left, op=ast.Sub(), right=node.right)\n        return node\n\ntree = ast.parse(\"x + y\")\ntransformed = MyTransformer().visit(tree)\nprint(astor.to_source(transformed))  # Affiche \"x - y\"\n\n\n\nConclusion\nLa bibliothèque standard Python est un trésor de fonctionnalités, offrant des outils pour presque toutes les tâches imaginables en programmation. Comprendre et utiliser efficacement ces outils est essentiel pour tout développeur Python. De plus, explorer l’AST et ses applications peut non seulement renforcer la compréhension du langage Python, mais aussi ouvrir la voie à des projets intéressants et éducatifs, tout en développant des compétences en analyse de code.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "L'arbre Syntaxique Abstrait ou AST"
    ]
  },
  {
    "objectID": "content/Cours_5/TP5.html",
    "href": "content/Cours_5/TP5.html",
    "title": "TP-5",
    "section": "",
    "text": "POO - Python Orienté Objet”\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_5/2-POO_le_retour.html",
    "href": "content/Cours_5/2-POO_le_retour.html",
    "title": "POO - Python Orienté Objet",
    "section": "",
    "text": "POO - Python Orienté Objet”\n\n\n\n\n\n Back to top",
    "crumbs": [
      "POO - Python Orienté Objet"
    ]
  },
  {
    "objectID": "content/Cours_2/index.html",
    "href": "content/Cours_2/index.html",
    "title": "Syntaxes et Concepts de Base",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercices d’applications\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctions et Modules\n\n\nCe chapitre se concentre sur les fonctions et les modules en Python, deux composants clés pour écrire un code propre et réutilisable. Il aborde la création de fonctions, la…\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction à la POO en Python\n\n\nDans ce chapitre, nous explorons les principes fondamentaux de la Programmation Orientée Objet (POO) en Python. Les étudiants découvriront comment Python applique les…\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyntaxe et objets de Base Python\n\n\nCe chapitre offre une plongée approfondie dans la syntaxe et les objets de base de Python. Il vise à fournir une compréhension solide des fondements du langage, couvrant…\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Syntaxes et Concepts de Base"
    ]
  },
  {
    "objectID": "content/Cours_2/Exercices.html",
    "href": "content/Cours_2/Exercices.html",
    "title": "Exercices d’applications",
    "section": "",
    "text": "Liste des fichiers à télécharger\n\n Telecharger le premier jeu d'exercice \n Telecharger le premier second d'exercice \n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "Exercices d'applications"
    ]
  },
  {
    "objectID": "content/Projets/projets_L3_2023.html",
    "href": "content/Projets/projets_L3_2023.html",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Introduction à Python - Millésime 2024\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html",
    "href": "content/Cours_3/3-MachineLearning.html",
    "title": "Machine Learning",
    "section": "",
    "text": "Python est devenu la langue de prédilection pour le machine learning (ML) en raison de sa simplicité, de sa richesse en bibliothèques, et de sa communauté active. Des bibliothèques comme Scikit-learn, TensorFlow, et PyTorch facilitent la mise en œuvre de diverses techniques de ML.\n\n\n\n\nScikit-learn est une bibliothèque Python polyvalente pour le machine learning. Elle offre des outils simples et efficaces pour l’analyse de données et la modélisation statistique.\nFonctionnalités clés :\n\nClassification, Régression, et Clustering: Algorithmes pour les tâches de ML les plus courantes.\nPrétraitement des Données: Outils pour normaliser, échelonner, et transformer les données.\nSélection de Modèles et Validation Croisée: Méthodes pour choisir les meilleurs modèles et paramètres.\n\n\n\n\n\n\nClassification avec Scikit-learn:\n\n\nfrom sklearn.datasets import load_iris\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Chargement des données\niris = load_iris()\nX, y = iris.data, iris.target\n\n# Entraînement d'un modèle de forêt aléatoire\nclf = RandomForestClassifier()\nclf.fit(X, y)\n\nRandomForestClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier()\n\n\n\n\n\n\nTensorFlow et PyTorch sont des bibliothèques plus spécialisées, offrant des fonctionnalités avancées pour les réseaux de neurones profonds et l’apprentissage automatique à grande échelle.\nElles sont particulièrement adaptées pour :\n\nRéseaux de Neurones Profonds: Construction et entraînement de modèles complexes.\nTraitement de Données à Grande Échelle: Gestion efficace des ensembles de données volumineux.\nPersonnalisation et Recherche: Flexibilité pour expérimenter de nouvelles idées en ML.\n\n\n\n\n\n\nObjectif: Se familiariser avec le processus de base du machine learning en utilisant Scikit-learn.\nÉnoncé: Utilisez Scikit-learn pour construire un classificateur simple sur un jeu de données standard, évaluez ses performances, et essayez d’améliorer ses résultats en ajustant les paramètres.\nSolution:\n\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\n# Division en ensembles d'entraînement et de test\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n\n# Entraînement du modèle\nclf.fit(X_train, y_train)\n\n# Évaluation du modèle\ny_pred = clf.predict(X_test)\nprint(\"Accuracy:\", accuracy_score(y_test, y_pred))\n\nAccuracy: 0.9555555555555556\n\n\n\n\n\nLe machine learning en Python offre un éventail impressionnant d’outils et de techniques pour l’analyse de données, la prédiction, et la compréhension des modèles complexes. Que vous débutiez avec Scikit-learn ou que vous plongiez dans des modèles plus avancés avec TensorFlow ou PyTorch, Python a les ressources pour répondre à vos besoins en ML.\n\n\n\n\n\n\n\nStatsmodels est une bibliothèque Python spécialisée dans les modèles statistiques et l’économétrie. Elle est particulièrement utile pour les analyses statistiques traditionnelles.\nFonctionnalités clés de Statsmodels :\n\nRégressions Linéaires et Logistiques: Outils pour modéliser les relations entre variables.\nTests Statistiques: Tests pour valider les hypothèses sur les données.\nExploration de Séries Temporelles: Outils pour analyser les données dépendant du temps.\n\n\n\n\n\n\nPyTorch est une bibliothèque d’apprentissage profond très appréciée dans la communauté de recherche en raison de sa flexibilité et de sa facilité d’utilisation.\nAspects saillants de PyTorch :\n\nAutograd: Système de différenciation automatique pour le calcul des gradients.\nRéseaux de Neurones Personnalisés: Facilité de création et d’expérimentation avec de nouveaux modèles.\nPerformances en Temps Réel: Optimisé pour les calculs sur GPU, idéal pour l’entraînement de modèles complexes.\n\n\n\n\n\n\nTensorFlow est une bibliothèque développée par Google, largement utilisée pour des applications d’apprentissage automatique complexes, en particulier celles nécessitant une grande échelle de calcul.\nCaractéristiques principales de TensorFlow :\n\nArchitecture Flexible: Convient à la fois pour la recherche et la production.\nTensorBoard: Outil pour la visualisation et le monitoring des modèles.\nTFLite pour les Applications Mobiles et Embarquées: Permet de déployer des modèles ML sur des appareils mobiles.\n\n\n\n\n\n\nObjectif: Se familiariser avec l’apprentissage profond en utilisant PyTorch ou TensorFlow.\nÉnoncé: Construisez et entraînez un réseau de neurones simple pour classifier des images à partir d’un jeu de données standard comme MNIST.\nSolution (avec PyTorch) :\n\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torchvision import datasets, transforms\nfrom torch.utils.data import DataLoader\n\n# Chargement des données\ntransform = transforms.ToTensor()\ntrain_dataset = datasets.MNIST(root='./data', train=True, transform=transform, download=True)\ntrain_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)\n\n# Définition du modèle\nclass SimpleNN(nn.Module):\n    def __init__(self):\n        super(SimpleNN, self).__init__()\n        self.linear = nn.Linear(784, 10)\n\n    def forward(self, x):\n        x = x.view(x.size(0), -1)  # Aplatir l'image\n        return self.linear(x)\n\nmodel = SimpleNN()\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Entraînement du modèle\nfor epoch in range(5):\n    for data, target in train_loader:\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n    print(f'Epoch {epoch}, Loss: {loss.item()}')\n\nEpoch 0, Loss: 0.463758260011673\nEpoch 1, Loss: 0.40204814076423645\nEpoch 2, Loss: 0.5841864347457886\nEpoch 3, Loss: 0.45830824971199036\nEpoch 4, Loss: 0.3604811728000641\n\n\n\n\n\nL’écosystème du machine learning en Python est riche et varié, offrant des outils adaptés à une large gamme de besoins, de l’analyse statistique traditionnelle avec Statsmodels à l’apprentissage profond avec PyTorch et TensorFlow. Chaque outil a ses propres forces, et le choix dépend des objectifs spécifiques du projet, de l’expertise de l’utilisateur, et du contexte d’application.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#introduction-au-machine-learning-avec-python",
    "href": "content/Cours_3/3-MachineLearning.html#introduction-au-machine-learning-avec-python",
    "title": "Machine Learning",
    "section": "",
    "text": "Python est devenu la langue de prédilection pour le machine learning (ML) en raison de sa simplicité, de sa richesse en bibliothèques, et de sa communauté active. Des bibliothèques comme Scikit-learn, TensorFlow, et PyTorch facilitent la mise en œuvre de diverses techniques de ML.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#scikit-learn-un-point-de-départ-pour-le-machine-learning",
    "href": "content/Cours_3/3-MachineLearning.html#scikit-learn-un-point-de-départ-pour-le-machine-learning",
    "title": "Machine Learning",
    "section": "",
    "text": "Scikit-learn est une bibliothèque Python polyvalente pour le machine learning. Elle offre des outils simples et efficaces pour l’analyse de données et la modélisation statistique.\nFonctionnalités clés :\n\nClassification, Régression, et Clustering: Algorithmes pour les tâches de ML les plus courantes.\nPrétraitement des Données: Outils pour normaliser, échelonner, et transformer les données.\nSélection de Modèles et Validation Croisée: Méthodes pour choisir les meilleurs modèles et paramètres.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#exemple-dutilisation-de-scikit-learn",
    "href": "content/Cours_3/3-MachineLearning.html#exemple-dutilisation-de-scikit-learn",
    "title": "Machine Learning",
    "section": "",
    "text": "Classification avec Scikit-learn:\n\n\nfrom sklearn.datasets import load_iris\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Chargement des données\niris = load_iris()\nX, y = iris.data, iris.target\n\n# Entraînement d'un modèle de forêt aléatoire\nclf = RandomForestClassifier()\nclf.fit(X, y)\n\nRandomForestClassifier()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.RandomForestClassifierRandomForestClassifier()",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#tensorflow-et-pytorch-pour-des-applications-plus-avancées",
    "href": "content/Cours_3/3-MachineLearning.html#tensorflow-et-pytorch-pour-des-applications-plus-avancées",
    "title": "Machine Learning",
    "section": "",
    "text": "TensorFlow et PyTorch sont des bibliothèques plus spécialisées, offrant des fonctionnalités avancées pour les réseaux de neurones profonds et l’apprentissage automatique à grande échelle.\nElles sont particulièrement adaptées pour :\n\nRéseaux de Neurones Profonds: Construction et entraînement de modèles complexes.\nTraitement de Données à Grande Échelle: Gestion efficace des ensembles de données volumineux.\nPersonnalisation et Recherche: Flexibilité pour expérimenter de nouvelles idées en ML.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#exercice-pratique",
    "href": "content/Cours_3/3-MachineLearning.html#exercice-pratique",
    "title": "Machine Learning",
    "section": "",
    "text": "Objectif: Se familiariser avec le processus de base du machine learning en utilisant Scikit-learn.\nÉnoncé: Utilisez Scikit-learn pour construire un classificateur simple sur un jeu de données standard, évaluez ses performances, et essayez d’améliorer ses résultats en ajustant les paramètres.\nSolution:\n\n\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\n# Division en ensembles d'entraînement et de test\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n\n# Entraînement du modèle\nclf.fit(X_train, y_train)\n\n# Évaluation du modèle\ny_pred = clf.predict(X_test)\nprint(\"Accuracy:\", accuracy_score(y_test, y_pred))\n\nAccuracy: 0.9555555555555556",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#conclusion",
    "href": "content/Cours_3/3-MachineLearning.html#conclusion",
    "title": "Machine Learning",
    "section": "",
    "text": "Le machine learning en Python offre un éventail impressionnant d’outils et de techniques pour l’analyse de données, la prédiction, et la compréhension des modèles complexes. Que vous débutiez avec Scikit-learn ou que vous plongiez dans des modèles plus avancés avec TensorFlow ou PyTorch, Python a les ressources pour répondre à vos besoins en ML.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#statsmodels-analyse-statistique-en-python",
    "href": "content/Cours_3/3-MachineLearning.html#statsmodels-analyse-statistique-en-python",
    "title": "Machine Learning",
    "section": "",
    "text": "Statsmodels est une bibliothèque Python spécialisée dans les modèles statistiques et l’économétrie. Elle est particulièrement utile pour les analyses statistiques traditionnelles.\nFonctionnalités clés de Statsmodels :\n\nRégressions Linéaires et Logistiques: Outils pour modéliser les relations entre variables.\nTests Statistiques: Tests pour valider les hypothèses sur les données.\nExploration de Séries Temporelles: Outils pour analyser les données dépendant du temps.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#pytorch-apprentissage-profond-et-recherche",
    "href": "content/Cours_3/3-MachineLearning.html#pytorch-apprentissage-profond-et-recherche",
    "title": "Machine Learning",
    "section": "",
    "text": "PyTorch est une bibliothèque d’apprentissage profond très appréciée dans la communauté de recherche en raison de sa flexibilité et de sa facilité d’utilisation.\nAspects saillants de PyTorch :\n\nAutograd: Système de différenciation automatique pour le calcul des gradients.\nRéseaux de Neurones Personnalisés: Facilité de création et d’expérimentation avec de nouveaux modèles.\nPerformances en Temps Réel: Optimisé pour les calculs sur GPU, idéal pour l’entraînement de modèles complexes.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#tensorflow-machine-learning-à-grande-échelle",
    "href": "content/Cours_3/3-MachineLearning.html#tensorflow-machine-learning-à-grande-échelle",
    "title": "Machine Learning",
    "section": "",
    "text": "TensorFlow est une bibliothèque développée par Google, largement utilisée pour des applications d’apprentissage automatique complexes, en particulier celles nécessitant une grande échelle de calcul.\nCaractéristiques principales de TensorFlow :\n\nArchitecture Flexible: Convient à la fois pour la recherche et la production.\nTensorBoard: Outil pour la visualisation et le monitoring des modèles.\nTFLite pour les Applications Mobiles et Embarquées: Permet de déployer des modèles ML sur des appareils mobiles.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#exercice-pratique-avec-pytorch-ou-tensorflow",
    "href": "content/Cours_3/3-MachineLearning.html#exercice-pratique-avec-pytorch-ou-tensorflow",
    "title": "Machine Learning",
    "section": "",
    "text": "Objectif: Se familiariser avec l’apprentissage profond en utilisant PyTorch ou TensorFlow.\nÉnoncé: Construisez et entraînez un réseau de neurones simple pour classifier des images à partir d’un jeu de données standard comme MNIST.\nSolution (avec PyTorch) :\n\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torchvision import datasets, transforms\nfrom torch.utils.data import DataLoader\n\n# Chargement des données\ntransform = transforms.ToTensor()\ntrain_dataset = datasets.MNIST(root='./data', train=True, transform=transform, download=True)\ntrain_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)\n\n# Définition du modèle\nclass SimpleNN(nn.Module):\n    def __init__(self):\n        super(SimpleNN, self).__init__()\n        self.linear = nn.Linear(784, 10)\n\n    def forward(self, x):\n        x = x.view(x.size(0), -1)  # Aplatir l'image\n        return self.linear(x)\n\nmodel = SimpleNN()\ncriterion = nn.CrossEntropyLoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Entraînement du modèle\nfor epoch in range(5):\n    for data, target in train_loader:\n        optimizer.zero_grad()\n        output = model(data)\n        loss = criterion(output, target)\n        loss.backward()\n        optimizer.step()\n    print(f'Epoch {epoch}, Loss: {loss.item()}')\n\nEpoch 0, Loss: 0.463758260011673\nEpoch 1, Loss: 0.40204814076423645\nEpoch 2, Loss: 0.5841864347457886\nEpoch 3, Loss: 0.45830824971199036\nEpoch 4, Loss: 0.3604811728000641",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/3-MachineLearning.html#conclusion-1",
    "href": "content/Cours_3/3-MachineLearning.html#conclusion-1",
    "title": "Machine Learning",
    "section": "",
    "text": "L’écosystème du machine learning en Python est riche et varié, offrant des outils adaptés à une large gamme de besoins, de l’analyse statistique traditionnelle avec Statsmodels à l’apprentissage profond avec PyTorch et TensorFlow. Chaque outil a ses propres forces, et le choix dépend des objectifs spécifiques du projet, de l’expertise de l’utilisateur, et du contexte d’application.",
    "crumbs": [
      "Machine Learning"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html",
    "href": "content/Cours_3/1-Dataframes.html",
    "title": "Les DataFrames",
    "section": "",
    "text": "Un dataframe est une structure de données bidimensionnelle, similaire à une feuille de calcul ou une table de base de données. Ils sont extrêmement utiles pour la manipulation et l’analyse de données structurées. En Python, la bibliothèque la plus courante pour travailler avec des dataframes est Pandas.\n\n\n\n\nManipulation de données: Pandas offre des fonctionnalités puissantes pour nettoyer, transformer et analyser les données.\nFacilité d’utilisation: Avec une API intuitive, Pandas permet une prise en main rapide pour les nouveaux utilisateurs.\nIntégration avec d’autres bibliothèques: Pandas se combine bien avec des bibliothèques pour la visualisation (comme Matplotlib) et le calcul scientifique (comme NumPy).\n\n\n\n\n\nInstallation:\n\npip install pandas\n\nImportation et Création d’un Dataframe:\n\n\nimport pandas as pd\ndata = {'Nom': ['Anna', 'Bob', 'Charles'], 'Age': [28, 34, 29]}\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nNom\nAge\n\n\n\n\n0\nAnna\n28\n\n\n1\nBob\n34\n\n\n2\nCharles\n29\n\n\n\n\n\n\n\n\nOpérations de Base:\n\nAfficher les données: print(df) ou Display(df) (dans un notebook - affiche un tableau de façon plus lisible. Il faut importer from IPython.display import display)\nAccéder aux colonnes: df['Nom']\nFiltrage: df[df['Age'] &gt; 30]\n\n\n\n\n\n\nObjectif: Créer un dataframe, ajouter des données, puis les filtrer.\nÉnoncé: Vous avez une liste de noms et d’âges. Créez un dataframe, ajoutez une colonne ‘Profession’, puis filtrez pour afficher seulement les personnes de plus de 30 ans.\nSolution:\n\n# Création du dataframe\ndf['Profession'] = ['Ingénieur', 'Artiste', 'Médecin']\n\n# Filtrage\nprint(df[df['Age'] &gt; 30])\n\n\n\nLes dataframes, via la bibliothèque Pandas, sont des outils essentiels en Python pour la manipulation de données. Leur simplicité et leur puissance en font un choix privilégié pour les data scientists et les analystes de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#introduction-aux-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#introduction-aux-dataframes",
    "title": "Les DataFrames",
    "section": "",
    "text": "Un dataframe est une structure de données bidimensionnelle, similaire à une feuille de calcul ou une table de base de données. Ils sont extrêmement utiles pour la manipulation et l’analyse de données structurées. En Python, la bibliothèque la plus courante pour travailler avec des dataframes est Pandas.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#pourquoi-utiliser-pandas-pour-les-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#pourquoi-utiliser-pandas-pour-les-dataframes",
    "title": "Les DataFrames",
    "section": "",
    "text": "Manipulation de données: Pandas offre des fonctionnalités puissantes pour nettoyer, transformer et analyser les données.\nFacilité d’utilisation: Avec une API intuitive, Pandas permet une prise en main rapide pour les nouveaux utilisateurs.\nIntégration avec d’autres bibliothèques: Pandas se combine bien avec des bibliothèques pour la visualisation (comme Matplotlib) et le calcul scientifique (comme NumPy).",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#utilisation-de-base-de-pandas",
    "href": "content/Cours_3/1-Dataframes.html#utilisation-de-base-de-pandas",
    "title": "Les DataFrames",
    "section": "",
    "text": "Installation:\n\npip install pandas\n\nImportation et Création d’un Dataframe:\n\n\nimport pandas as pd\ndata = {'Nom': ['Anna', 'Bob', 'Charles'], 'Age': [28, 34, 29]}\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nNom\nAge\n\n\n\n\n0\nAnna\n28\n\n\n1\nBob\n34\n\n\n2\nCharles\n29\n\n\n\n\n\n\n\n\nOpérations de Base:\n\nAfficher les données: print(df) ou Display(df) (dans un notebook - affiche un tableau de façon plus lisible. Il faut importer from IPython.display import display)\nAccéder aux colonnes: df['Nom']\nFiltrage: df[df['Age'] &gt; 30]",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-pratique",
    "href": "content/Cours_3/1-Dataframes.html#exercice-pratique",
    "title": "Les DataFrames",
    "section": "",
    "text": "Objectif: Créer un dataframe, ajouter des données, puis les filtrer.\nÉnoncé: Vous avez une liste de noms et d’âges. Créez un dataframe, ajoutez une colonne ‘Profession’, puis filtrez pour afficher seulement les personnes de plus de 30 ans.\nSolution:\n\n# Création du dataframe\ndf['Profession'] = ['Ingénieur', 'Artiste', 'Médecin']\n\n# Filtrage\nprint(df[df['Age'] &gt; 30])",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion",
    "href": "content/Cours_3/1-Dataframes.html#conclusion",
    "title": "Les DataFrames",
    "section": "",
    "text": "Les dataframes, via la bibliothèque Pandas, sont des outils essentiels en Python pour la manipulation de données. Leur simplicité et leur puissance en font un choix privilégié pour les data scientists et les analystes de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#manipulation-de-grandes-données",
    "href": "content/Cours_3/1-Dataframes.html#manipulation-de-grandes-données",
    "title": "Les DataFrames",
    "section": "Manipulation de Grandes Données",
    "text": "Manipulation de Grandes Données\nQuand on travaille avec de grands ensembles de données, il est crucial de savoir comment gérer efficacement la mémoire et le temps de traitement.\n\nLecture par morceaux: Pandas permet de lire de grandes données par morceaux, ce qui réduit la consommation de mémoire.\n\nchunk_size = 1000\nfor chunk in pd.read_csv('large_file.csv', chunksize=chunk_size):\n    # Traitement de chaque morceau\n\nOptimisation des types de données: Parfois, changer le type de données d’une colonne peut réduire significativement l’utilisation de la mémoire.\n\ndf['Colonne'] = df['Colonne'].astype('category')",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#opérations-sur-les-colonnes-et-les-lignes",
    "href": "content/Cours_3/1-Dataframes.html#opérations-sur-les-colonnes-et-les-lignes",
    "title": "Les DataFrames",
    "section": "Opérations sur les Colonnes et les Lignes",
    "text": "Opérations sur les Colonnes et les Lignes\n\nAjout et suppression de colonnes:\n\nAjout: df['Nouvelle_Colonne'] = df['Colonne1'] + df['Colonne2']\nSuppression: df.drop('Colonne', axis=1, inplace=True)\n\nApplication de fonctions:\n\ndf['Colonne'].apply(lambda x: x * 2)",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-pratique-avancé",
    "href": "content/Cours_3/1-Dataframes.html#exercice-pratique-avancé",
    "title": "Les DataFrames",
    "section": "Exercice Pratique Avancé",
    "text": "Exercice Pratique Avancé\n\nObjectif: Manipuler un grand fichier CSV et effectuer des opérations sur les colonnes.\nÉnoncé: Lisez un grand fichier CSV par morceaux. Pour chaque morceau, ajoutez une colonne ‘AgeDoubled’ qui est le double de la colonne ‘Age’, puis enregistrez chaque morceau modifié dans un nouveau fichier.\nSolution:\nchunk_size = 1000\nfor i, chunk in enumerate(pd.read_csv('large_file.csv', chunksize=chunk_size)):\n    chunk['AgeDoubled'] = chunk['Age'] * 2\n    chunk.to_csv(f'chunk_{i}.csv')",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion-1",
    "href": "content/Cours_3/1-Dataframes.html#conclusion-1",
    "title": "Les DataFrames",
    "section": "Conclusion",
    "text": "Conclusion\nLa maîtrise des opérations avancées sur les dataframes est essentielle pour traiter efficacement des ensembles de données complexes. Les possibilités offertes par Pandas en font un outil incontournable pour la manipulation et l’analyse de données en Python.\n\nExemples Concrets d’Utilisation des Dataframes et Optimisation des Performances",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#utilisation-dans-des-scénarios-réels",
    "href": "content/Cours_3/1-Dataframes.html#utilisation-dans-des-scénarios-réels",
    "title": "Les DataFrames",
    "section": "Utilisation dans des Scénarios Réels",
    "text": "Utilisation dans des Scénarios Réels\n\nAnalyse de Données: Les dataframes sont fréquemment utilisés pour l’analyse de données dans divers domaines, comme la finance, la recherche scientifique, et le marketing.\n\nExemple: Analyse des tendances de vente en e-commerce. On peut charger les données des transactions, calculer les métriques clés comme le chiffre d’affaires, et identifier les produits les plus vendus.\n\nTraitement de Données pour le Machine Learning: Avant de construire des modèles de machine learning, il est souvent nécessaire de nettoyer et de transformer les données.\n\nExemple: Préparation de données pour la prédiction de prix immobiliers. On peut utiliser les dataframes pour gérer des données manquantes, encoder des variables catégorielles, et normaliser les valeurs.\n\nRapports et Visualisation: Les dataframes se couplent bien avec des outils de visualisation pour créer des rapports et des graphiques.\n\nExemple: Création d’un rapport sur la performance des employés. On peut combiner des données issues de différentes sources, calculer des KPIs, et générer des graphiques pour la présentation.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#optimisation-des-performances",
    "href": "content/Cours_3/1-Dataframes.html#optimisation-des-performances",
    "title": "Les DataFrames",
    "section": "Optimisation des Performances",
    "text": "Optimisation des Performances\n\nUtilisation de Dask pour le Traitement Parallèle: Pour des ensembles de données très volumineux, Dask offre une solution de traitement parallèle compatible avec l’API de Pandas.\n\nimport dask.dataframe as dd\ndask_df = dd.from_pandas(pandas_df, npartitions=10)\n\nOptimisation du Code:\n\nUtiliser iterrows() et itertuples() pour itérer sur les dataframes de manière plus performante.\nPréférer les opérations vectorisées aux boucles lorsque c’est possible.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-pratique-de-synthèse",
    "href": "content/Cours_3/1-Dataframes.html#exercice-pratique-de-synthèse",
    "title": "Les DataFrames",
    "section": "Exercice Pratique de Synthèse",
    "text": "Exercice Pratique de Synthèse\n\nObjectif: Combiner plusieurs fichiers de données, effectuer une analyse simple, et visualiser les résultats.\nÉnoncé: Vous avez plusieurs fichiers CSV représentant les ventes mensuelles d’une entreprise. Fusionnez-les, calculez le total des ventes par mois, puis créez un graphique linéaire des ventes.\nSolution:\n\nimport matplotlib.pyplot as plt\n\n# Fusion des fichiers CSV\ndf_total = pd.concat([pd.read_csv(f) for f in fichiers_csv])\n\n# Calcul du total des ventes par mois\nventes_par_mois = df_total.groupby('Mois')['Ventes'].sum()\n\n# Création du graphique\nventes_par_mois.plot(kind='line')\nplt.title('Ventes Mensuelles')\nplt.show()",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion-2",
    "href": "content/Cours_3/1-Dataframes.html#conclusion-2",
    "title": "Les DataFrames",
    "section": "Conclusion",
    "text": "Conclusion\nLes dataframes, grâce à leur flexibilité et leur puissance, sont un outil fondamental pour l’analyse de données, le traitement préparatoire pour le machine learning, et la création de rapports et visualisations. L’optimisation des performances et l’utilisation de bibliothèques complémentaires comme Dask peuvent augmenter considérablement l’efficacité du travail avec de grandes quantités de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#bonus-astuces-et-meilleures-pratiques-avec-les-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#bonus-astuces-et-meilleures-pratiques-avec-les-dataframes",
    "title": "Les DataFrames",
    "section": "Bonus : Astuces et Meilleures Pratiques avec les Dataframes",
    "text": "Bonus : Astuces et Meilleures Pratiques avec les Dataframes\nAprès avoir abordé les bases, les aspects avancés et des exemples concrets d’utilisation des dataframes, il est utile de conclure avec quelques astuces et meilleures pratiques qui peuvent rendre le travail avec les dataframes encore plus efficace et agréable.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#astuces-pour-la-manipulation-de-dataframes",
    "href": "content/Cours_3/1-Dataframes.html#astuces-pour-la-manipulation-de-dataframes",
    "title": "Les DataFrames",
    "section": "Astuces pour la Manipulation de Dataframes",
    "text": "Astuces pour la Manipulation de Dataframes\n\nChainage de Méthodes: Pandas permet de chaîner les méthodes, ce qui rend le code plus lisible et concis.\n\ndf = (pd.read_csv('data.csv')\n      .dropna()\n      .rename(columns={'old_name': 'new_name'})\n      .sort_values('column'))\nOn parle aussi pour décrire ce genre d’API, de fluent API. Le terme API fait ici référence à l’API utilisateur, c’est à dire l’ensemble des fonctions et méthodes que l’on peut utiliser pour interagir avec une bibliothèque. Une API est dite fluide lorsqu’elle permet d’enchaîner les appels de méthodes, comme dans l’exemple ci-dessus.\n\nUtilisation de query pour le Filtrage: La méthode query permet un filtrage plus lisible et souvent plus rapide.\n\ndf_filtered = df.query('age &gt; 30 & city == \"Paris\"')\n\nAssignation Conditionnelle avec np.where: Pour créer de nouvelles colonnes basées sur des conditions.\n\nimport numpy as np\ndf['status'] = np.where(df['age'] &gt; 18, 'adult', 'minor')",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#meilleures-pratiques",
    "href": "content/Cours_3/1-Dataframes.html#meilleures-pratiques",
    "title": "Les DataFrames",
    "section": "Meilleures Pratiques",
    "text": "Meilleures Pratiques\n\nÉviter les Boucles Autant que Possible: Préférer les opérations vectorisées pour une meilleure performance.\nUtilisation Judicieuse de la Mémoire: Être attentif aux types de données, en particulier avec de grands ensembles de données.\nTester avec des Sous-ensembles de Données: Avant d’appliquer des opérations à l’ensemble du dataframe, tester avec un petit échantillon.\nDocumentation et Commentaires: S’assurer que le code est bien documenté pour faciliter la compréhension et la maintenance.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#exercice-de-réflexion",
    "href": "content/Cours_3/1-Dataframes.html#exercice-de-réflexion",
    "title": "Les DataFrames",
    "section": "Exercice de Réflexion",
    "text": "Exercice de Réflexion\n\nObjectif: Réfléchir à l’optimisation du traitement des données.\nÉnoncé: Imaginez que vous avez un dataframe très large avec plusieurs colonnes inutilisées et des types de données non optimisés. Comment aborderiez-vous sa nettoyage et son optimisation pour une analyse efficace?\nSolution Suggérée:\n\nSupprimer les colonnes inutiles pour économiser de la mémoire.\nConvertir les colonnes avec des données catégorielles en type ‘category’.\nUtiliser des fonctions vectorisées pour les transformations de données.",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Dataframes.html#conclusion-3",
    "href": "content/Cours_3/1-Dataframes.html#conclusion-3",
    "title": "Les DataFrames",
    "section": "Conclusion",
    "text": "Conclusion\nLa maîtrise des dataframes dans Pandas ne se limite pas seulement à connaître diverses fonctions et méthodes, mais implique également une compréhension des meilleures pratiques et astuces pour optimiser la performance et la lisibilité du code. Cela inclut une utilisation efficace de la mémoire, l’évitement des boucles inutiles, et une bonne documentation du code.\nVous trouverez également des exemples simple d’utilisation de tout les fonctions standards dans ce Notebook\nque vous pouvez également télécharger directement ici:\n Telecharger le Notebook d'exemple \nPour vous entrainer, vous pouvez télécharger le fichier suivant et l’importer dans un notebook Jupyter :\n Telecharger le Notebook du TP \n Download the population_communes dataset",
    "crumbs": [
      "Les DataFrames"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "b Introduction au Calcul Scientifique Le calcul scientifique est une discipline essentielle dans de nombreux domaines de la recherche et de l’industrie. En Python, cela implique souvent l’utilisation de bibliothèques telles que NumPy, SciPy, et autres, qui fournissent des outils efficaces pour le calcul numérique.\n\n\n\nNumPy est une bibliothèque de base pour le calcul scientifique en Python. Elle offre des structures de données puissantes, optimisées pour les opérations mathématiques complexes et la manipulation de grands ensembles de données.\n\n\n\n\n\nTableaux Multidimensionnels: Les ndarray de NumPy sont plus performants que les listes Python pour les opérations mathématiques.\n\n\nimport numpy as np\narr = np.array([1, 2, 3, 4, 5])\n\n\nOpérations Mathématiques Rapides et Efficaces: NumPy permet des calculs vectorisés, ce qui est plus rapide que les boucles traditionnelles.\n\n\narr = arr + 1  # Ajoute 1 à chaque élément\n\n\nFonctions Mathématiques Avancées: NumPy inclut des fonctions pour l’algèbre linéaire, la transformée de Fourier, et plus.\n\n\nmatrix = np.random.rand(3, 3)  # Crée une matrice 3x3 de nombres aléatoires\nnp.linalg.inv(matrix)  # Inversion d'une matrice\n\narray([[-2.08539094, -0.35063541,  4.16752787],\n       [ 0.28605245,  1.16237177, -0.60513187],\n       [ 2.81408057,  0.07757706, -3.55232178]])\n\n\n\n\n\n\nSciPy s’appuie sur NumPy pour offrir un ensemble plus large de fonctionnalités pour le calcul scientifique, notamment dans l’optimisation, l’intégration numérique, et la statistique.\n\n\n\n\n\nOptimisation: Trouver le minimum ou le maximum d’une fonction.\n\n\nfrom scipy.optimize import minimize\n\ndef func(x):\n    return x**2 + 5\n\nresult = minimize(func, 0)  # Trouve le minimum de la fonction\n\n\n\n\n\nObjectif: Utiliser NumPy et SciPy pour résoudre un problème d’optimisation.\nÉnoncé: Définissez une fonction mathématique simple (par exemple, un polynôme) et utilisez SciPy pour trouver son minimum.\nSolution:\n\n\ndef poly(x):\n    return x**2 - 5*x + 4\n\nresult = minimize(poly, 0)  # Trouver le minimum du polynôme\n\n\n\n\nLe calcul scientifique en Python, grâce à des bibliothèques comme NumPy et SciPy, est une composante essentielle pour les chercheurs et les ingénieurs. Ces outils offrent des capacités puissantes pour traiter des problèmes mathématiques complexes, de l’algèbre linéaire à l’optimisation numérique.\n\n\n\n\n\nIndexation Sophistiquée: NumPy offre des méthodes d’indexation avancées qui permettent de manipuler et d’accéder aux données de manière très flexible.\n\nIndexation Booléenne: Sélectionner des éléments basés sur des conditions.\narr[arr &gt; 2]  # Sélectionne les éléments supérieurs à 2\nIndexation Fantaisie: Sélectionner des éléments en utilisant des listes d’indices.\narr[[1, 3, 4]]  # Sélectionne les éléments aux positions 1, 3, et 4\n\nBroadcasting: Une méthode puissante pour effectuer des opérations arithmétiques sur des tableaux de formes différentes.\narr + np.array([1, 2, 3])  # Ajoute [1, 2, 3] à chaque ligne de 'arr'\nManipulation de Formes: Reshaper les tableaux pour les adapter aux besoins de vos calculs.\narr.reshape(3, 2)  # Remodeler le tableau en 3 lignes et 2 colonnes\n\n\n\n\n\nOptimisation Multivariable: SciPy n’est pas limité à l’optimisation de fonctions à une seule variable. Il peut également optimiser des fonctions avec plusieurs variables.\ndef func(x):\n    return x[0]**2 + x[1]**2 + x[2]**2  # Fonction à 3 variables\n\nresult = minimize(func, [0, 0, 0])  # Point de départ : [0, 0, 0]\nContraintes et Bornes: Vous pouvez ajouter des contraintes et des bornes à votre problème d’optimisation pour le rendre plus réaliste.\ncons = ({'type': 'eq', 'fun': lambda x: x[0] + x[1] - 1})  # Contrainte d'égalité\nbnds = ((0, None), (0, None))  # Bornes pour x[0] et x[1]\n\nresult = minimize(func, [0, 0], constraints=cons, bounds=bnds)\n\n\n\n\n\nObjectif: Approfondir l’utilisation de NumPy et SciPy pour des calculs complexes.\nÉnoncé: Créez un tableau 2D avec NumPy et utilisez l’indexation fantaisie pour sélectionner des éléments spécifiques. Ensuite, définissez une fonction multivariable et utilisez SciPy pour la minimiser avec des contraintes.\nSolution:\n\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# NumPy: Indexation fantaisie\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d[[0, 2], [1, 2]])  # Sélectionne les éléments (0,1) et (2,2)\n\n# SciPy: Optimisation multivariable avec contraintes\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncons = ({'type': 'eq', 'fun': lambda x: x[0] + x[1] - 1})  # x[0] + x[1] doit être égal à 1\nresult = minimize(func, [0.5, 0.5], constraints=cons)\nprint(result)\n\n[2 9]\n message: Optimization terminated successfully\n success: True\n  status: 0\n     fun: 0.5\n       x: [ 5.000e-01  5.000e-01]\n     nit: 1\n     jac: [ 1.000e+00  1.000e+00]\n    nfev: 3\n    njev: 1\n\n\n\n\n\nLes fonctionnalités avancées de NumPy et SciPy ouvrent des possibilités presque illimitées pour le calcul scientifique en Python. L’indexation avancée, le broadcasting, l’optimisation multivariable, et les contraintes ne sont que quelques exemples des outils puissants à la disposition des scientifiques et ingénieurs. Maîtriser ces outils peut significativement accélérer et améliorer la qualité de la recherche et du développement.\n\n\n\n\n\n\n\nIngénierie: L’utilisation de NumPy et SciPy en ingénierie est cruciale pour des tâches telles que l’analyse structurelle, la simulation de systèmes dynamiques, et la conception assistée par ordinateur (CAO).\n\nExemple: Dans l’ingénierie mécanique, on utilise souvent ces outils pour résoudre des équations différentielles qui modélisent le comportement dynamique des systèmes.\n\nPhysique et Chimie: Les calculs complexes en physique et en chimie, comme la modélisation moléculaire ou la dynamique des fluides, peuvent être réalisés avec efficacité grâce à ces bibliothèques.\n\nExemple: Les chercheurs en physique quantique peuvent utiliser SciPy pour résoudre des problèmes d’optimisation dans la recherche de l’état fondamental des systèmes quantiques.\n\nFinance et Économétrie: NumPy et SciPy sont largement utilisés dans le domaine de la finance pour l’analyse de risques, la modélisation de marchés, et l’optimisation de portefeuilles.\n\nExemple: En finance quantitative, ces outils aident à optimiser les portefeuilles en minimisant le risque pour un rendement donné.\n\n\n\n\n\n\nUtilisation de Cython ou Numba: Pour des calculs intensifs, l’utilisation de Cython ou Numba pour compiler le code Python en code machine peut apporter une amélioration significative des performances.\nParallélisation des Calculs: L’utilisation de la parallélisation, par exemple avec Dask ou des opérations multithreading/multiprocessing, peut accélérer les calculs lourds.\nGestion Efficace de la Mémoire: Utiliser des techniques comme la vectorisation et éviter les copies inutiles de données pour réduire la consommation de mémoire.\n\n\n\n\nLe calcul scientifique et l’optimisation en Python, grâce à des bibliothèques comme NumPy et SciPy, jouent un rôle clé dans une multitude de domaines. Que ce soit pour résoudre des problèmes complexes en ingénierie, en physique, en chimie, ou en finance, ces outils offrent les capacités nécessaires pour réaliser des analyses précises et des simulations efficaces. La maîtrise de ces outils est donc essentielle pour tout scientifique ou ingénieur souhaitant exploiter pleinement le potentiel du calcul numérique.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#numpy-fondement-du-calcul-scientifique-en-python",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#numpy-fondement-du-calcul-scientifique-en-python",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "NumPy est une bibliothèque de base pour le calcul scientifique en Python. Elle offre des structures de données puissantes, optimisées pour les opérations mathématiques complexes et la manipulation de grands ensembles de données.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#fonctionnalités-clés-de-numpy",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#fonctionnalités-clés-de-numpy",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Tableaux Multidimensionnels: Les ndarray de NumPy sont plus performants que les listes Python pour les opérations mathématiques.\n\n\nimport numpy as np\narr = np.array([1, 2, 3, 4, 5])\n\n\nOpérations Mathématiques Rapides et Efficaces: NumPy permet des calculs vectorisés, ce qui est plus rapide que les boucles traditionnelles.\n\n\narr = arr + 1  # Ajoute 1 à chaque élément\n\n\nFonctions Mathématiques Avancées: NumPy inclut des fonctions pour l’algèbre linéaire, la transformée de Fourier, et plus.\n\n\nmatrix = np.random.rand(3, 3)  # Crée une matrice 3x3 de nombres aléatoires\nnp.linalg.inv(matrix)  # Inversion d'une matrice\n\narray([[-2.08539094, -0.35063541,  4.16752787],\n       [ 0.28605245,  1.16237177, -0.60513187],\n       [ 2.81408057,  0.07757706, -3.55232178]])",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#scipy-élargissement-des-capacités-de-calcul",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#scipy-élargissement-des-capacités-de-calcul",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "SciPy s’appuie sur NumPy pour offrir un ensemble plus large de fonctionnalités pour le calcul scientifique, notamment dans l’optimisation, l’intégration numérique, et la statistique.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exemple-dutilisation-de-scipy-pour-loptimisation",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exemple-dutilisation-de-scipy-pour-loptimisation",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Optimisation: Trouver le minimum ou le maximum d’une fonction.\n\n\nfrom scipy.optimize import minimize\n\ndef func(x):\n    return x**2 + 5\n\nresult = minimize(func, 0)  # Trouve le minimum de la fonction",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exercice-pratique",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#exercice-pratique",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Objectif: Utiliser NumPy et SciPy pour résoudre un problème d’optimisation.\nÉnoncé: Définissez une fonction mathématique simple (par exemple, un polynôme) et utilisez SciPy pour trouver son minimum.\nSolution:\n\n\ndef poly(x):\n    return x**2 - 5*x + 4\n\nresult = minimize(poly, 0)  # Trouver le minimum du polynôme",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#conclusion",
    "href": "content/Cours_3/2-Calcul_Scientifique_et_Optimization.html#conclusion",
    "title": "Calcul Scientifique et Optimization",
    "section": "",
    "text": "Le calcul scientifique en Python, grâce à des bibliothèques comme NumPy et SciPy, est une composante essentielle pour les chercheurs et les ingénieurs. Ces outils offrent des capacités puissantes pour traiter des problèmes mathématiques complexes, de l’algèbre linéaire à l’optimisation numérique.\n\n\n\n\n\nIndexation Sophistiquée: NumPy offre des méthodes d’indexation avancées qui permettent de manipuler et d’accéder aux données de manière très flexible.\n\nIndexation Booléenne: Sélectionner des éléments basés sur des conditions.\narr[arr &gt; 2]  # Sélectionne les éléments supérieurs à 2\nIndexation Fantaisie: Sélectionner des éléments en utilisant des listes d’indices.\narr[[1, 3, 4]]  # Sélectionne les éléments aux positions 1, 3, et 4\n\nBroadcasting: Une méthode puissante pour effectuer des opérations arithmétiques sur des tableaux de formes différentes.\narr + np.array([1, 2, 3])  # Ajoute [1, 2, 3] à chaque ligne de 'arr'\nManipulation de Formes: Reshaper les tableaux pour les adapter aux besoins de vos calculs.\narr.reshape(3, 2)  # Remodeler le tableau en 3 lignes et 2 colonnes\n\n\n\n\n\nOptimisation Multivariable: SciPy n’est pas limité à l’optimisation de fonctions à une seule variable. Il peut également optimiser des fonctions avec plusieurs variables.\ndef func(x):\n    return x[0]**2 + x[1]**2 + x[2]**2  # Fonction à 3 variables\n\nresult = minimize(func, [0, 0, 0])  # Point de départ : [0, 0, 0]\nContraintes et Bornes: Vous pouvez ajouter des contraintes et des bornes à votre problème d’optimisation pour le rendre plus réaliste.\ncons = ({'type': 'eq', 'fun': lambda x: x[0] + x[1] - 1})  # Contrainte d'égalité\nbnds = ((0, None), (0, None))  # Bornes pour x[0] et x[1]\n\nresult = minimize(func, [0, 0], constraints=cons, bounds=bnds)\n\n\n\n\n\nObjectif: Approfondir l’utilisation de NumPy et SciPy pour des calculs complexes.\nÉnoncé: Créez un tableau 2D avec NumPy et utilisez l’indexation fantaisie pour sélectionner des éléments spécifiques. Ensuite, définissez une fonction multivariable et utilisez SciPy pour la minimiser avec des contraintes.\nSolution:\n\n\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# NumPy: Indexation fantaisie\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr2d[[0, 2], [1, 2]])  # Sélectionne les éléments (0,1) et (2,2)\n\n# SciPy: Optimisation multivariable avec contraintes\ndef func(x):\n    return x[0]**2 + x[1]**2\n\ncons = ({'type': 'eq', 'fun': lambda x: x[0] + x[1] - 1})  # x[0] + x[1] doit être égal à 1\nresult = minimize(func, [0.5, 0.5], constraints=cons)\nprint(result)\n\n[2 9]\n message: Optimization terminated successfully\n success: True\n  status: 0\n     fun: 0.5\n       x: [ 5.000e-01  5.000e-01]\n     nit: 1\n     jac: [ 1.000e+00  1.000e+00]\n    nfev: 3\n    njev: 1\n\n\n\n\n\nLes fonctionnalités avancées de NumPy et SciPy ouvrent des possibilités presque illimitées pour le calcul scientifique en Python. L’indexation avancée, le broadcasting, l’optimisation multivariable, et les contraintes ne sont que quelques exemples des outils puissants à la disposition des scientifiques et ingénieurs. Maîtriser ces outils peut significativement accélérer et améliorer la qualité de la recherche et du développement.\n\n\n\n\n\n\n\nIngénierie: L’utilisation de NumPy et SciPy en ingénierie est cruciale pour des tâches telles que l’analyse structurelle, la simulation de systèmes dynamiques, et la conception assistée par ordinateur (CAO).\n\nExemple: Dans l’ingénierie mécanique, on utilise souvent ces outils pour résoudre des équations différentielles qui modélisent le comportement dynamique des systèmes.\n\nPhysique et Chimie: Les calculs complexes en physique et en chimie, comme la modélisation moléculaire ou la dynamique des fluides, peuvent être réalisés avec efficacité grâce à ces bibliothèques.\n\nExemple: Les chercheurs en physique quantique peuvent utiliser SciPy pour résoudre des problèmes d’optimisation dans la recherche de l’état fondamental des systèmes quantiques.\n\nFinance et Économétrie: NumPy et SciPy sont largement utilisés dans le domaine de la finance pour l’analyse de risques, la modélisation de marchés, et l’optimisation de portefeuilles.\n\nExemple: En finance quantitative, ces outils aident à optimiser les portefeuilles en minimisant le risque pour un rendement donné.\n\n\n\n\n\n\nUtilisation de Cython ou Numba: Pour des calculs intensifs, l’utilisation de Cython ou Numba pour compiler le code Python en code machine peut apporter une amélioration significative des performances.\nParallélisation des Calculs: L’utilisation de la parallélisation, par exemple avec Dask ou des opérations multithreading/multiprocessing, peut accélérer les calculs lourds.\nGestion Efficace de la Mémoire: Utiliser des techniques comme la vectorisation et éviter les copies inutiles de données pour réduire la consommation de mémoire.\n\n\n\n\nLe calcul scientifique et l’optimisation en Python, grâce à des bibliothèques comme NumPy et SciPy, jouent un rôle clé dans une multitude de domaines. Que ce soit pour résoudre des problèmes complexes en ingénierie, en physique, en chimie, ou en finance, ces outils offrent les capacités nécessaires pour réaliser des analyses précises et des simulations efficaces. La maîtrise de ces outils est donc essentielle pour tout scientifique ou ingénieur souhaitant exploiter pleinement le potentiel du calcul numérique.",
    "crumbs": [
      "Calcul Scientifique et Optimization"
    ]
  },
  {
    "objectID": "content/Cours_3/pandas_short_example.html",
    "href": "content/Cours_3/pandas_short_example.html",
    "title": "Pandas",
    "section": "",
    "text": "Pandas\n\nimport pandas as pd\n\n\ndata = [\n    {'beer_name': 'a', 'type': 'blonde', 'price': 2},\n    {'beer_name': 'b', 'type': 'blonde', 'price': 2},\n    {'beer_name': 'c', 'type': 'blonde', 'price': 3},\n    {'beer_name': 'd', 'type': 'brune', 'price': 4},\n    {'beer_name': 'e', 'type': 'ale', 'price': 2}\n]\n\n\ndf = pd.DataFrame(data)  # créer un dataframe à partir d'une liste de dict\n\n\ndf\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\ndf.columns\n\nIndex(['beer_name', 'type', 'price'], dtype='object')\n\n\n\ntype(df)\n\npandas.core.frame.DataFrame\n\n\n\n# Créer un dataframe à partir d'un dict de list:\ndf2 = pd.DataFrame({\n    'x': [1,2,3,5],\n    'y': [4,22,33,5]\n})\n\n\ndf2\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n1\n4\n\n\n1\n2\n22\n\n\n2\n3\n33\n\n\n3\n5\n5\n\n\n\n\n\n\n\n\ndf2.shape\n\n(4, 2)\n\n\n\ndf2.columns\n\nIndex(['x', 'y'], dtype='object')\n\n\n\ndf2.x\n\n0    1\n1    2\n2    3\n3    5\nName: x, dtype: int64\n\n\n\ntype(df2.x)\n\npandas.core.series.Series\n\n\n\nl = [1, 2, 3, None]\ns = pd.Series(l)\n\n\nl\n\n[1, 2, 3, None]\n\n\n\ns\n\n0    1.0\n1    2.0\n2    3.0\n3    NaN\ndtype: float64\n\n\n\ns.mean()\n\n2.0\n\n\n\ndf2['x']  \n\n0    1\n1    2\n2    3\n3    5\nName: x, dtype: int64\n\n\n\ndf2['x'] + 10\n\n0    11\n1    12\n2    13\n3    15\nName: x, dtype: int64\n\n\n\ndf2['x'] + df2['y']\n\n0     5\n1    24\n2    36\n3    10\ndtype: int64\n\n\n\ndf2['x'] &gt; 2  # renvoie une série de booléens\n\n0    False\n1    False\n2     True\n3     True\nName: x, dtype: bool\n\n\n\n(df2['x'] &gt; 2) & (df2['x'] &lt; 5)  # on peut combiner les séries de booléens avec & et |\n\n0    False\n1    False\n2     True\n3    False\nName: x, dtype: bool\n\n\n\ndf\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\ndf['price']\n\n0    2\n1    2\n2    3\n3    4\n4    2\nName: price, dtype: int64\n\n\n\nbool_serie = df['price'] &gt; 2\nbool_serie\n\n0    False\n1    False\n2     True\n3     True\n4    False\nName: price, dtype: bool\n\n\n\n# on peut se servir de la syntaxe [] avec une série de booléens pour filtrer des lignes:\ndf[bool_serie]\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\n# Ici on extrait les lignes qui on un price &lt;= 2 + celles qui ont un price &gt; 3\ndf[(df['price'] &gt; 3) | (df['price'] &lt;= 2)]\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\ns = df.price\ns\n\n0    2\n1    2\n2    3\n3    4\n4    2\nName: price, dtype: int64\n\n\n\ns.sort_values()\n\n0    2\n1    2\n4    2\n2    3\n3    4\nName: price, dtype: int64\n\n\n\ndf.sort_values('price')\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n4\ne\nale\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\ndf.sort_values(['type', 'price'])  # tri sur plusieurs colonnes\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n4\ne\nale\n2\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\ndfsorted = df.sort_values(['type', 'price'])\ndfsorted\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n4\ne\nale\n2\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n\n\n\n\n\n\ndfsorted.sort_index()  # trier par l'index\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\ndf['type']  # une colonne qui contient des str\n\n0    blonde\n1    blonde\n2    blonde\n3     brune\n4       ale\nName: type, dtype: object\n\n\n\n# L'attribut .str permet d'accéder aux méthodes des str habituelles:\ndf['type'].str.startswith('b')\n\n0     True\n1     True\n2     True\n3     True\n4    False\nName: type, dtype: bool\n\n\n\ndf\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n3\nd\nbrune\n4\n\n\n4\ne\nale\n2\n\n\n\n\n\n\n\n\ndf[['price', 'type']]  # prendre un sous-ensemble des colonnes\n\n\n\n\n\n\n\n\nprice\ntype\n\n\n\n\n0\n2\nblonde\n\n\n1\n2\nblonde\n\n\n2\n3\nblonde\n\n\n3\n4\nbrune\n\n\n4\n2\nale\n\n\n\n\n\n\n\n\ndf.loc[[0, 2]]  # extrait les lignes à l'index 0 et 2\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n\n\n\n\n\n\ndf.loc[0:2]  # extrait les lignes aux index 0, 1, et 2 *inclus*\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\n\n\n0\na\nblonde\n2\n\n\n1\nb\nblonde\n2\n\n\n2\nc\nblonde\n3\n\n\n\n\n\n\n\n\n# extrait les lignes aux index 1, 2, et 3 *inclus*, avec les colonnes price et type:\ndf.loc[1:3, ['price', 'type']]  \n\n\n\n\n\n\n\n\nprice\ntype\n\n\n\n\n1\n2\nblonde\n\n\n2\n3\nblonde\n\n\n3\n4\nbrune\n\n\n\n\n\n\n\n\ndf['plop'] = [10, 11, 12, 13, 14]  # ajout d'une colonne\n\n\ndf\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\ndf2 = df.set_index('plop')  # on place la colonne 'plop' en index\ndf2\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\nplop\n\n\n\n\n\n\n\n10\na\nblonde\n2\n\n\n11\nb\nblonde\n2\n\n\n12\nc\nblonde\n3\n\n\n13\nd\nbrune\n4\n\n\n14\ne\nale\n2\n\n\n\n\n\n\n\n\ndf2.loc[10:12, 'beer_name':'price']\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\n\n\nplop\n\n\n\n\n\n\n\n10\na\nblonde\n2\n\n\n11\nb\nblonde\n2\n\n\n12\nc\nblonde\n3\n\n\n\n\n\n\n\n\ndf_with_beername_index = df.set_index('beer_name')\n\n\ndf_with_beername_index\n\n\n\n\n\n\n\n\ntype\nprice\nplop\n\n\nbeer_name\n\n\n\n\n\n\n\na\nblonde\n2\n10\n\n\nb\nblonde\n2\n11\n\n\nc\nblonde\n3\n12\n\n\nd\nbrune\n4\n13\n\n\ne\nale\n2\n14\n\n\n\n\n\n\n\n\ndf_with_beername_index.loc[['a', 'c'], ['price', 'plop']]\n\n\n\n\n\n\n\n\nprice\nplop\n\n\nbeer_name\n\n\n\n\n\n\na\n2\n10\n\n\nc\n3\n12\n\n\n\n\n\n\n\n\ndf_with_type_index = df.set_index('type')\ndf_with_type_index\n\n\n\n\n\n\n\n\nbeer_name\nprice\nplop\n\n\ntype\n\n\n\n\n\n\n\nblonde\na\n2\n10\n\n\nblonde\nb\n2\n11\n\n\nblonde\nc\n3\n12\n\n\nbrune\nd\n4\n13\n\n\nale\ne\n2\n14\n\n\n\n\n\n\n\n\ndf_with_type_index.loc['blonde']\n\n\n\n\n\n\n\n\nbeer_name\nprice\nplop\n\n\ntype\n\n\n\n\n\n\n\nblonde\na\n2\n10\n\n\nblonde\nb\n2\n11\n\n\nblonde\nc\n3\n12\n\n\n\n\n\n\n\n\n# iloc est similaire à loc sauf qu'il prend en paramètre les positions des lignes/colonnes,\n# contrairement à loc qui prend leurs valeurs.\ndf_with_type_index.iloc[:2, 1:]  # extrait les lignes 0 à 2 (exclue) et les colonnes 1 et suivantes\n\n\n\n\n\n\n\n\nprice\nplop\n\n\ntype\n\n\n\n\n\n\nblonde\n2\n10\n\n\nblonde\n2\n11\n\n\n\n\n\n\n\n\ndf \n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n# Extrait la valeur de la 1ère cellule:\ndf.iloc[0, 0]\n\n'a'\n\n\n\ndfbis = df.copy()\n\n\ndfbis\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\n# Concaténer 2 dataframes:\npd.concat([\n    df,\n    dfbis\n])\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\ndf_with_type_index\n\n\n\n\n\n\n\n\nbeer_name\nprice\nplop\n\n\ntype\n\n\n\n\n\n\n\nblonde\na\n2\n10\n\n\nblonde\nb\n2\n11\n\n\nblonde\nc\n3\n12\n\n\nbrune\nd\n4\n13\n\n\nale\ne\n2\n14\n\n\n\n\n\n\n\n\ndf_with_type_index.reset_index()\n\n\n\n\n\n\n\n\ntype\nbeer_name\nprice\nplop\n\n\n\n\n0\nblonde\na\n2\n10\n\n\n1\nblonde\nb\n2\n11\n\n\n2\nblonde\nc\n3\n12\n\n\n3\nbrune\nd\n4\n13\n\n\n4\nale\ne\n2\n14\n\n\n\n\n\n\n\n\nfor elem in df.index:\n    print(elem)\n\n0\n1\n2\n3\n4\n\n\n\ndf.set_index(['type', 'price']).sort_index()\n\n\n\n\n\n\n\n\n\nbeer_name\nplop\n\n\ntype\nprice\n\n\n\n\n\n\nale\n2\ne\n14\n\n\nblonde\n2\na\n10\n\n\n2\nb\n11\n\n\n3\nc\n12\n\n\nbrune\n4\nd\n13\n\n\n\n\n\n\n\n\ndf.to_csv('output.csv', index=False)  # exporter le dataframe dans un fichier csv\n\n\npd.read_csv('output.csv')  # créer un dataframe à partir d'un csv\n\n\n\n\n\n\n\n\nbeer_name\ntype\nprice\nplop\n\n\n\n\n0\na\nblonde\n2\n10\n\n\n1\nb\nblonde\n2\n11\n\n\n2\nc\nblonde\n3\n12\n\n\n3\nd\nbrune\n4\n13\n\n\n4\ne\nale\n2\n14\n\n\n\n\n\n\n\n\npd.read_csv('output2.csv')\n\n\n\n\n\n\n\n\nbeer_name\nprice\ntype\ngood\n\n\n\n\n0\na\n2\nblonde\nnon renseigne\n\n\n1\nb\n2\nblonde\noui\n\n\n2\nc\n3\nblonde\noui\n\n\n3\nd\n4\nbrune\nnon renseigne\n\n\n4\ne\n2\nale\nnon renseigne\n\n\n5\nx\n1\nblonde\noui\n\n\n\n\n\n\n\n\n# read_csv dispose de plein d'options\npd.read_csv('output2.csv', na_values=['non renseigne'], true_values=['oui'])\n\n\n\n\n\n\n\n\nbeer_name\nprice\ntype\ngood\n\n\n\n\n0\na\n2\nblonde\nNaN\n\n\n1\nb\n2\nblonde\nTrue\n\n\n2\nc\n3\nblonde\nTrue\n\n\n3\nd\n4\nbrune\nNaN\n\n\n4\ne\n2\nale\nNaN\n\n\n5\nx\n1\nblonde\nTrue\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_3/Exercice-pandas_and_geography.html",
    "href": "content/Cours_3/Exercice-pandas_and_geography.html",
    "title": "Introduction à Python",
    "section": "",
    "text": "On va travailler sur le csv de donnée population commune:\n1- importer le fichier et donné le nombre de ville présente dans celui-ci\n2- Donnée le nombre de ville par région\n3-Donnée la moyenne et l’écart-type globale et par région de la population (totale) par ville\n4- Existe-t-il des villes sans population ?\n5- Verifiez qu’un code de département n’est pas présent dans 2 régions différentes\n6- Des villes portent-elles le même nom ?\n7-Créer une colonne ‘base du nom’ qui tronquent les noms des villes possedant des tirets avant ceux-ci (exemple: Abbeville-Saint-Lucien devient Abbeville)\n8- Combien de ville ayant des noms différents portent un ‘base du nom’ similaire ?\n9- A l’aide de matplotlib, tracer une courbe de densité cumulative de la différence entre population totale et municipale\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_4/2-TypageEnPython.html",
    "href": "content/Cours_4/2-TypageEnPython.html",
    "title": "Typage en Python",
    "section": "",
    "text": "Python est un langage à typage dynamique, ce qui signifie que le type d’une variable est déterminé à l’exécution et peut changer au cours du temps.\n\nx = 5        # x est un entier\nx = \"Hello\"  # x est maintenant une chaîne de caractères\n\n\n\n\n\nAvantages : Flexibilité et facilité d’écriture du code.\nInconvénients : Moins de prévisibilité et risque accru d’erreurs à l’exécution.",
    "crumbs": [
      "Typage en Python"
    ]
  },
  {
    "objectID": "content/Cours_4/2-TypageEnPython.html#types-et-typage-dynamique",
    "href": "content/Cours_4/2-TypageEnPython.html#types-et-typage-dynamique",
    "title": "Typage en Python",
    "section": "",
    "text": "Python est un langage à typage dynamique, ce qui signifie que le type d’une variable est déterminé à l’exécution et peut changer au cours du temps.\n\nx = 5        # x est un entier\nx = \"Hello\"  # x est maintenant une chaîne de caractères\n\n\n\n\n\nAvantages : Flexibilité et facilité d’écriture du code.\nInconvénients : Moins de prévisibilité et risque accru d’erreurs à l’exécution.",
    "crumbs": [
      "Typage en Python"
    ]
  },
  {
    "objectID": "content/Cours_4/2-TypageEnPython.html#typage-en-python-approfondissement",
    "href": "content/Cours_4/2-TypageEnPython.html#typage-en-python-approfondissement",
    "title": "Typage en Python",
    "section": "Typage en Python: Approfondissement",
    "text": "Typage en Python: Approfondissement\n\nTypage Dynamique en Python\n\nComprendre le Typage Dynamique\nPython est un langage à typage dynamique, ce qui signifie que le type d’une variable est déterminé au moment de l’exécution et non à la compilation. Cette caractéristique offre une grande flexibilité.\n\n\nExemple de Typage Dynamique\n\nx = 5        #Ici, x est un entier\nx = \"Hello\"  #Maintenant, x est une chaîne de caractères\n\n\n\nImplications du Typage Dynamique\n\nFlexibilité : Permet de réaffecter des variables à différents types.\nRisques Potentiels : Peut conduire à des erreurs subtiles, difficiles à détecter avant l’exécution.\n\n\n\n\n\nClasses Abstraites\n\nUtilisation des Classes Abstraites\nLes classes abstraites en Python, utilisées via le module abc, servent à définir une interface pour d’autres classes à suivre, imposant ainsi une certaine structure dans le code.\n\n\nExemple de Classe Abstraite\n\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    \n    @abstractmethod\n    def area(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius ** 2\n\n\n\nImportance des Classes Abstraites\n\nDéfinition d’Interfaces : Force les classes dérivées à implémenter certaines méthodes.\nStructuration du Code : Aide à maintenir une architecture de code claire et organisée.\n\n\n\n\n\nCompilation avec Cython\n\nAmélioration des Performances avec Cython\nCython permet d’écrire des extensions Python en C pour une exécution plus rapide, ce qui est particulièrement utile pour les calculs intensifs.\n\n\nExemple de Code Cython\nDéfinition d’une fonction en Cython\ncdef int multiply(int a, int b):\n    return a * b\nCette fonction peut maintenant être utilisée comme une fonction Python normale, mais elle est compilée en C et s’exécute plus rapidement.\n\n\nAvantages de l’Utilisation de Cython\n\nPerformance : Le code Cython est généralement beaucoup plus rapide.\nInteropérabilité : Permet d’intégrer facilement des bibliothèques C/C++ dans des applications Python.\n\n\n\n\nConclusion\nLe typage en Python, avec ses différentes facettes - typage dynamique, type hinting, classes abstraites et Cython - offre une gamme variée d’outils pour augmenter la clarté, la performance et la structure du code. La compréhension de ces aspects est essentielle pour les développeurs Python afin de produire des codes efficaces, maintenables et performants.",
    "crumbs": [
      "Typage en Python"
    ]
  },
  {
    "objectID": "content/Cours_4/1-MutabilitéEtScopes.html",
    "href": "content/Cours_4/1-MutabilitéEtScopes.html",
    "title": "Mutabilité et Scope",
    "section": "",
    "text": "Mutabilité et Scope - Une base de Python\n\n\nCours sur la Mutabilité et le Scope en Python\n\nPremière Partie: Comprendre la Mutabilité\n\nQu’est-ce que la Mutabilité ?\nLa mutabilité en Python fait référence à la capacité d’un objet à être modifié après sa création. Dans Python, certains types de données sont mutables, tandis que d’autres sont immutables.\n\n\nTypes Mutables vs. Immutables\n\nImmutables : Ces types ne peuvent pas être modifiés une fois créés. Les principaux types immutables en Python incluent les entiers (int), les nombres à virgule flottante (float), les chaînes de caractères (str), et les tuples (tuple).\nMutables : Ces types peuvent être modifiés. Les listes (list), les dictionnaires (dict), et les ensembles (set) sont des exemples de types mutables.\n\n\n\nImplications de la Mutabilité\n\nSécurité : Les objets immutables sont plus sûrs à partager et à utiliser car ils ne peuvent pas être modifiés de manière inattendue.\nPerformance : La mutabilité peut affecter la performance. Par exemple, l’ajout d’éléments à une liste (mutable) est généralement plus rapide que la concaténation de tuples (immutables).\n\nTypes Immutables\n\n# Un entier est immuable\nx = 10\nprint(id(x))  # Identifiant de l'objet 'x'\nx += 1\nprint(id(x))  # L'identifiant a changé car un nouvel objet a été créé\n\n# Un tuple est immuable\nt = (1, 2, 3)\ntry:\n    t[0] = 10  # Essaie de modifier le tuple\nexcept TypeError as e:\n    print(e)  # Affiche une erreur\n\n139839798478544\n139839798478576\n'tuple' object does not support item assignment\n\n\nTypes Mutables\n\n# Une liste est mutable\nmy_list = [1, 2, 3]\nprint(id(my_list))  # Identifiant de 'my_list'\nmy_list.append(4)  # Modification de la liste\nprint(id(my_list))  # L'identifiant reste le même\n\n139839579198464\n139839579198464\n\n\n\n\n\n\nDeuxième Partie: Scope en Python\n\nQu’est-ce que le Scope ?\nLe scope en Python fait référence à la portée dans laquelle les variables sont visibles et accessibles. Il détermine la visibilité d’une variable au sein du code.\n\n\nTypes de Scope\n\nLocal Scope : Les variables définies à l’intérieur d’une fonction. Elles ne sont accessibles que dans cette fonction.\nEnclosing Scope : Apparaît dans les fonctions imbriquées (fonctions dans une fonction). Une variable dans une fonction englobante est accessible dans la fonction imbriquée.\nGlobal Scope : Les variables définies au niveau du module ou du script. Accessibles partout dans le script ou le module.\nBuilt-in Scope : Contient des noms préassignés par Python, comme print, len.\n\n\n\nManipulation de Scope\n\nglobal Keyword : Permet de modifier une variable globale à l’intérieur d’une fonction.\nnonlocal Keyword : Utilisé dans les fonctions imbriquées pour modifier une variable dans le scope englobant.\n\nExemple 2: Scope en Python\n\ndef outer_function():\n    x = \"local to outer_function\"\n\n    def inner_function():\n        nonlocal x  # Référence à 'x' dans le scope englobant\n        x = \"modified by inner_function\"\n        print(\"Inner function:\", x)\n\n    inner_function()\n    print(\"Outer function:\", x)\n\nouter_function()\n\nInner function: modified by inner_function\nOuter function: modified by inner_function\n\n\n\n\n\n\nTroisième Partie: Mutabilité et Classes en Python\n\nClasses et Objets Mutables\n\nEn Python, les classes peuvent être utilisées pour créer des types mutables. L’état d’une instance de classe (c’est-à-dire ses attributs) peut être modifié après sa création.\nExemple : Une classe Car avec un attribut color peut voir sa couleur modifiée après la création de l’objet.\n\n\n\nPrécautions avec les Objets Mutables\n\nLes modifications apportées à un objet mutable peuvent avoir des effets inattendus, en particulier lors de la copie d’objets ou du passage d’objets comme arguments à des fonctions.\n\nExemple 3: Classes et Mutabilité\n\nclass Car:\n    def __init__(self, color):\n        self.color = color\n\nmy_car = Car(\"red\")\nprint(my_car.color)  # Affiche 'red'\n\nmy_car.color = \"blue\"  # Modification de l'attribut 'color'\nprint(my_car.color)  # Affiche 'blue'\n\nred\nblue\n\n\n\n\n\n\nQuatrième Partie: Implications Pratiques et Bonnes Pratiques\n\ndef add_to_list(element, target_list=[]):  # Liste mutable comme argument par défaut\n    target_list.append(element)\n    return target_list\n\nprint(add_to_list(1))  # Affiche [1]\nprint(add_to_list(2))  # Affiche [1, 2] - L'effet de bord se produit ici\n\n[1]\n[1, 2]\n\n\n\nImplications de la Mutabilité\n\nEffets de Bord : La modification d’objets mutables peut entraîner des effets de bord indésirables, en particulier lorsqu’ils sont partagés entre différentes parties d’un programme.\nCopie Profonde vs. Copie Superficielle : La compréhension de la différence entre copie profonde (deepcopy) et copie superficielle (copy) est essentielle lors de la manipulation d’objets mutables.\n\n\n\nBonnes Pratiques\n\nImmutabilité par Défaut : Préférer l’utilisation de types immutables sauf si la mutabilité est nécessaire. Cela réduit les risques d’erreurs et les effets de bord.\nPrudence avec les Objets Globaux : Être prudent lors de la modification de variables globales, surtout si elles sont mutables.\nDocumentation et Commentaires : Documenter clairement l’utilisation et les modifications des objets mutables, surtout dans les grandes bases de code et les projets de groupe.\n\n\nimport copy\n\noriginal_list = [[1, 2, 3], [4, 5, 6]]\n\n# Copie superficielle\nshallow_copied_list = copy.copy(original_list)\nshallow_copied_list[0][0] = \"X\"\nprint(original_list)  # Affecte la liste originale\n\n# Copie profonde\ndeep_copied_list = copy.deepcopy(original_list)\ndeep_copied_list[0][0] = \"Y\"\nprint(original_list)  # Ne change pas la liste originale\n\n[['X', 2, 3], [4, 5, 6]]\n[['X', 2, 3], [4, 5, 6]]\n\n\n\n\n\nConclusion\nLa compréhension de la mutabilité et du scope en Python est fondamentale pour écrire un code clair, efficace et sans erreurs. Bien que la mutabilité offre de la flexibilité, elle doit être utilisée judicieusement pour éviter des complications inutiles. La maîtrise du scope aide à structurer le code de manière logique et à éviter les conflits de noms et les erreurs inattendues.\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_4/3-TournonsAutourduGIL.html",
    "href": "content/Cours_4/3-TournonsAutourduGIL.html",
    "title": "Asynchronie et Multiprocessing",
    "section": "",
    "text": "Asynchronie et Multiprocessing - Quels solutions sous le joug du GIL ?\n\nVous trouverez ici les cours sur les solutions d’asynchronie et de multiprocessing en Python: Cours sur Async, thread, process\n\n\n\n\n Back to top",
    "crumbs": [
      "Asynchronie et Multiprocessing"
    ]
  },
  {
    "objectID": "content/Cours_4/index.html",
    "href": "content/Cours_4/index.html",
    "title": "Bonne pratiques, Dangers, et Astuces",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAsynchronie et Multiprocessing\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMutabilité et Scope\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP - Requettes API avec Python\n\n\nAsynchronie vs synchronie\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypage en Python\n\n\nTypage en Python - Utile ou pas ?\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "content/Cours_4/TP-RequetteruneAPI.html",
    "href": "content/Cours_4/TP-RequetteruneAPI.html",
    "title": "TP - Requettes API avec Python",
    "section": "",
    "text": "Visualisation de données avec Python\n\n\n\n\n Back to top",
    "crumbs": [
      "TP - Requettes API avec Python"
    ]
  },
  {
    "objectID": "content/Cours_3/TP-3.html",
    "href": "content/Cours_3/TP-3.html",
    "title": "TP-3 Libraries",
    "section": "",
    "text": "TP : Analyse et Prévision des Volumes d’Actifs Financiers\nCe TP se concentre sur la récupération des données de prix d’actifs, la prévision de volumes et la visualisation de la volatilité. Nous allons suivre les étapes suivantes :\n\n1. Récupération des Données avec yfinance\nNous utiliserons le package yfinance pour récupérer les données de prix journaliers de 10 actifs différents.\n\n\n2. Prévision de Volume avec Modèles Simples\nNous mettrons en œuvre des modèles de prévision simples comme la régression linéaire et ARIMA pour prédire le volume des transactions pour le jour suivant (1-step ahead forecast).\n\n\n3. Visualisation des Volumes par Rapport à la Volatilité\nNous visualiserons les volumes des actifs en relation avec leur volatilité, en utilisant la valeur absolue des rendements comme proxy de la volatilité.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP-3 Libraries"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Visualisation.html",
    "href": "content/Cours_3/6-Visualisation.html",
    "title": "Visualiser et présenter ces données avec Python",
    "section": "",
    "text": "Visualisation de données avec Python\n\n\nChapitre sur la Visualisation de Données en Python\n\nIntroduction à la Visualisation de Données\nLa visualisation est un aspect crucial de l’analyse de données, aidant à comprendre les tendances, les modèles et les anomalies dans les données. Python offre une variété de bibliothèques de visualisation, chacune avec ses propres forces et cas d’utilisation.\n\n\nMatplotlib: Le Fondement de la Visualisation en Python\n\nMatplotlib est la bibliothèque de visualisation la plus connue et la plus utilisée en Python. Elle offre une grande flexibilité pour créer une large gamme de graphiques statiques, animés et interactifs.\nExemple d’utilisation :\nimport matplotlib.pyplot as plt\n\nplt.plot([1, 2, 3, 4])\nplt.ylabel('some numbers')\nplt.show()\n\n\n\nSeaborn: Visualisation Statistique Facilitée\n\nSeaborn est basé sur Matplotlib et fournit une interface de haut niveau pour dessiner des graphiques statistiques attractifs et informatifs.\nExemple de visualisation des relations entre variables :\nimport seaborn as sns\niris = sns.load_dataset('iris')\nsns.pairplot(iris, hue='species')\n\n\n\nAltair: Déclaration Declarative pour la Visualisation\n\nAltair offre une API déclarative puissante pour construire des visualisations complexes de manière concise et intuitive.\nExemple simple d’un graphique à barres :\nimport altair as alt\nfrom vega_datasets import data\n\nsource = data.cars()\nchart = alt.Chart(source).mark_bar().encode(\n    x='mean(Miles_per_Gallon)',\n    y='Origin',\n    color='Origin'\n)\nchart.show()\n\n\n\nPlotly: Visualisation Interactive et Avancée\n\nPlotly est remarquable pour ses graphiques interactifs et ses capacités de visualisation avancées, permettant des visualisations complexes et multi-dimensionnelles.\nExemple d’intégration avec Pandas pour une visualisation interactive :\nimport plotly\nimport pandas as pd\n\nplotly.offline.init_notebook_mode() \nplotly.io.renderers.default = 'jupyterlab+notebook+pdf'\n\n# Supposons que 'gdf' est un DataFrame Pandas\ngdf.plot(kind='scatter', x='timestamp', y='p', color='side', \n         color_discrete_map={'B': 'blue', 'S': 'red'}, size='dot_size', \n         template='plotly', symbol='side', symbol_map=symbol_map, \n         hover_data=['name'], backend='plotly').show()\n\n\n\nExercice Pratique\n\nObjectif: Créer un graphique interactif avec Plotly et l’intégrer à un DataFrame Pandas.\nÉnoncé: Utilisez Plotly pour créer un graphique à bulles interactif qui montre les relations entre différentes variables dans un DataFrame Pandas.\nSolution: Utilisez le code d’exemple Plotly fourni ci-dessus comme point de départ et ajustez-le en fonction de vos données spécifiques et des relations que vous souhaitez visualiser.\n\n\n\nConclusion\nLa visualisation de données est un élément essentiel de l’analyse de données, et Python offre une gamme impressionnante de bibliothèques pour créer des visualisations statiques, animées et interactives. Que vous cherchiez à produire des graphiques simples ou à explorer des visualisations interactives avancées, il existe une bibliothèque Python qui répond à vos besoins.\n\n\n\nTechniques Avancées de Visualisation de Données en Python\n\nCréation de Tableaux de Bord Interactifs\nLa capacité de créer des tableaux de bord interactifs permet une exploration en profondeur et dynamique des données.\n\nDash: Un framework Python pour créer des applications web analytiques.\n\nPermet de construire des tableaux de bord interactifs en utilisant uniquement Python.\nExemple :\nimport dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nfrom pandas_datareader import data as web\n\napp = dash.Dash(__name__)\napp.layout = html.Div([\n    dcc.Graph(\n        id='example-graph',\n        figure={\n            'data': [\n                {'x': [1, 2, 3], 'y': [4, 1, 2], 'type': 'bar', 'name': 'SF'},\n                {'x': [1, 2, 3], 'y': [2, 4, 5], 'type': 'bar', 'name': 'Montréal'},\n            ],\n            'layout': {\n                'title': 'Dash Data Visualization'\n            }\n        }\n    )\n])\n\nif __name__ == '__main__':\n    app.run_server(debug=True)\n\n\n\n\nAnimation de Graphiques\nLes animations peuvent aider à comprendre les tendances et les modèles au fil du temps.\n\nMatplotlib pour les Animations:\n\nMatplotlib peut être utilisé pour créer des animations de base.\nExemple d’animation d’un graphique linéaire :\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\nline, = ax.plot([], [], lw=2)\n\ndef init():\n    line.set_data([], [])\n    return line,\n\ndef animate(i):\n    x = np.linspace(0, 2, 1000)\n    y = np.sin(2 * np.pi * (x - 0.01 * i))\n    line.set_data(x, y)\n    return line,\n\nani = animation.FuncAnimation(fig, animate, init_func=init, frames=200, interval=20, blit=True)\nplt.show()\n\n\n\n\nIntégration de Visualisations dans des Applications Web\nL’intégration de graphiques dans des applications web rend les analyses de données plus accessibles et interactives.\n\nPlotly avec Flask ou Django:\n\nLes graphiques Plotly peuvent être intégrés dans des applications web Python utilisant Flask ou Django.\nExemple d’intégration Plotly avec Flask :\nfrom flask import Flask, render_template\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    bar = go.Bar(x=[1, 2, 3], y=[3, 1, 6])\n    graphJSON = pyo.plot([bar], auto_open=False, output_type='div')\n    return render_template('index.html', graphJSON=graphJSON)\n\nif __name__ == '__main__':\n    app.run(debug=True)\nindex.html contiendra le div pour afficher le graphique Plotly.\n\n\n\n\nConclusion\nLes techniques avancées de visualisation de données en Python, telles que la création de tableaux de bord interactifs avec Dash, l’animation de graphiques avec Matplotlib et l’intégration de visualisations dans des applications web, offrent des moyens puissants pour présenter et explorer des données complexes. Ces outils permettent aux utilisateurs de voir et d’interagir avec les données de manières innovantes, améliorant ainsi la compréhension et la prise de décisions basées sur les données.\n\n\n\nVisualisation de Données Géospatiales\n\nIntroduction à la Visualisation Géospatiale\nLa visualisation de données géospatiales implique la représentation de données ayant une composante géographique. Ces visualisations peuvent révéler des tendances et des modèles liés à l’emplacement.\n\n\nBibliothèques Clés pour la Visualisation Géospatiale\n\nGeopandas:\n\nExtension de Pandas pour faciliter le travail avec des données spatiales.\nPermet de lire, écrire et manipuler des données dans des formats géospatiaux variés.\nExemple d’utilisation de Geopandas :\nimport geopandas as gpd\nworld = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))\nworld.plot()\n\nFolium:\n\nBibliothèque qui crée des cartes interactives à l’aide de la plateforme Leaflet.js.\nIdéal pour les visualisations géospatiales interactives dans les notebooks Jupyter.\nExemple simple avec Folium :\nimport folium\n\nm = folium.Map(location=[45.5236, -122.6750])\nfolium.CircleMarker(location=[45.5215, -122.6261], radius=50, popup='Laurelhurst Park').add_to(m)\nm\n\n\n\n\nVisualisation 3D avec Python\n\n\nOutils pour la Visualisation 3D\n\nMatplotlib:\n\nMatplotlib propose également des fonctionnalités de base pour la visualisation 3D.\nExemple de graphique en 3D :\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.scatter(xs=[1,2,3], ys=[4,5,6], zs=[7,8,9])\nplt.show()\n\nPlotly:\n\nPlotly excelle également dans la création de visualisations 3D interactives.\nExemple de surface 3D avec Plotly :\nimport plotly.graph_objects as go\nimport numpy as np\n\nx = np.outer(np.linspace(-2, 2, 30), np.ones(30))\ny = x.copy().T\nz = np.cos(x ** 2 + y ** 2)\n\nfig = go.Figure(data=[go.Surface(z=z, x=x, y=y)])\nfig.show()\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Visualiser et présenter ces données avec Python"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html",
    "href": "content/Cours_3/5-Feed_Internet.html",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Python est une langue de choix pour le développement web backend en raison de sa simplicité, de sa lisibilité et de la richesse de ses frameworks web. Ces frameworks facilitent la création d’applications web robustes et évolutives.\n\n\n\n\nDjango:\n\nUn framework web haut niveau qui encourage un développement rapide et propre. Il est idéal pour les projets de grande envergure grâce à sa structure “batteries incluses”.\nFonctionnalités clés :\n\nORM (Object-Relational Mapping) intégré\nSystème d’administration robuste\nSécurité renforcée\n\n\nFlask:\n\nUn micro-framework léger, flexible et plus adapté aux petits projets ou aux applications avec des exigences spécifiques.\nPoints forts :\n\nSimplicité et flexibilité\nFacilité de déploiement\nExtensible avec de nombreux plugins\n\n\nFastAPI:\n\nUn framework moderne, rapide (basé sur Starlette et Pydantic) pour construire des API avec Python 3.7+. Il est conçu pour être facile à utiliser tout en offrant des performances élevées.\nAvantages :\n\nSupport natif pour les requêtes asynchrones\nGénération automatique de documentation (Swagger UI)\nValidation de données et sérialisation\n\n\n\n\n\n\n\nObjectif: Créer une simple API avec Flask.\nÉnoncé: Développez une API RESTful qui renvoie “Hello, World!” à chaque requête GET sur le chemin racine.\nSolution:\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return \"Hello, World!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n\n\n\nSécurité : Protéger les applications contre les attaques courantes telles que l’injection SQL, le cross-site scripting (XSS) et le cross-site request forgery (CSRF).\nGestion des Dépendances : Utiliser des environnements virtuels et gérer les dépendances pour assurer la cohérence des projets.\nTest et Débogage : Écrire des tests unitaires et utiliser des outils de débogage pour maintenir la qualité du code.\n\n\n\n\nLe développement web backend en Python, grâce à des frameworks comme Django, Flask et FastAPI, offre une grande flexibilité et une base solide pour construire des applications web. Que vous construisiez une simple application web ou une API complexe, Python a les outils et les bibliothèques nécessaires pour répondre aux besoins de votre projet.\n\n\n\n\n\n\nFastAPI est un framework moderne et rapide pour la construction d’APIs avec Python, qui offre une performance élevée et une écriture de code rapide et efficace. Il est particulièrement apprécié pour sa facilité d’intégration avec les systèmes asynchrones et ses fonctionnalités automatiques de documentation.\n\n\n\n\nCréation d’une API CRUD (Create, Read, Update, Delete):\n\nFastAPI simplifie la création d’APIs CRUD, qui sont essentielles dans de nombreuses applications web pour gérer les données.\nExemple de base : ```python from fastapi import FastAPI from pydantic import BaseModel\n\n\napp = FastAPI()\nclass Item(BaseModel): name: str description: str = None price: float tax: float = None\n@app.post(“/items/”) async def create_item(item: Item): return item\n@app.get(“/items/{item_id}”) async def read_item(item_id: int): return {“item_id”: item_id} ```\n\nIntégration avec des Bases de Données:\n\nFastAPI peut être facilement intégré avec des bases de données comme PostgreSQL, MySQL, ou MongoDB.\nUtilisation avec SQLAlchemy (pour les bases de données SQL) :\nfrom fastapi import FastAPI\nfrom sqlalchemy import create_engine\n\napp = FastAPI()\nengine = create_engine('postgresql://user:password@localhost/dbname')\n\n@app.get(\"/items/\")\nasync def read_items():\n    with engine.connect() as connection:\n        result = connection.execute(\"SELECT * FROM items\")\n        items = result.fetchall()\n    return items\n\nValidation et Sérialisation des Données:\n\nFastAPI utilise Pydantic pour la validation des données entrantes et la sérialisation des données sortantes.\nExemple avec un modèle Pydantic :\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    username: str\n    full_name: str = None\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return user\n\nAuthentification et Sécurité:\n\nFastAPI fournit plusieurs outils pour l’authentification et la gestion de la sécurité, y compris OAuth2.\nExemple d’authentification basique :\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@app.get(\"/users/me\")\nasync def read_users_me(token: str = Depends(oauth2_scheme)):\n    return {\"token\": token}\n\n\n\n\n\nFastAPI est un outil extrêmement puissant pour la création d’APIs modernes en Python. Sa facilité d’utilisation, sa performance élevée, et ses fonctionnalités intégrées comme la documentation automatique, la validation des données, et les fonctionnalités de sécurité, en font un choix idéal pour les développeurs souhaitant créer des APIs robustes et efficaces.\n\n\n\n\n\n\nLa mise en cache est une technique cruciale pour améliorer les performances des applications web en réduisant le temps de réponse des requêtes répétitives.\n\nMise en Cache avec Redis:\n\nRedis, en tant que magasin de données en mémoire, est souvent utilisé pour le cache dans les applications web.\nUtilisation avec FastAPI :\nimport redis\nfrom fastapi import FastAPI\n\napp = FastAPI()\nredis_client = redis.Redis(host='localhost', port=6379, db=0)\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    cached_item = redis_client.get(item_id)\n    if cached_item:\n        return cached_item\n    # Sinon, récupérer l'élément de la base de données, le mettre en cache, et le retourner\n\n\n\n\n\nLe traitement asynchrone est essentiel pour gérer les opérations I/O sans bloquer le serveur, en particulier dans les applications Web hautement scalables.\n\nUtilisation de async et await avec FastAPI:\n\nFastAPI prend en charge la programmation asynchrone native, ce qui permet de gérer facilement les requêtes asynchrones.\nExemple de requête asynchrone :\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    # Opération asynchrone, comme une requête de base de données\n    item = await get_item(item_id)\n    return item\n\n\n\n\n\nLa capacité à gérer une charge croissante de requêtes est un facteur clé pour le succès des applications web.\n\nUtilisation de Serveurs Asynchrones:\n\nDes serveurs tels que Uvicorn ou Hypercorn offrent des performances accrues pour les applications asynchrones en Python.\nExemple de déploiement avec Uvicorn :\nuvicorn myapp:app --host 0.0.0.0 --port 8000\n\nLoad Balancing:\n\nLe load balancing, avec des outils comme Nginx ou HAProxy, est crucial pour distribuer efficacement le trafic entre plusieurs instances de votre application.\n\nOptimisation des Bases de Données:\n\nUtiliser des techniques comme l’indexation, les requêtes optimisées et les pools de connexions pour améliorer les performances des bases de données.\n\n\n\n\n\nL’intégration web en Python, en utilisant des technologies telles que FastAPI, Redis, et des serveurs asynchrones, offre des moyens efficaces pour créer des applications web performantes et scalables. Les pratiques telles que la mise en cache, le traitement asynchrone, et la scalabilité sont essentielles pour répondre aux exigences des applications web modernes.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#introduction-au-développement-web-backend-avec-python",
    "href": "content/Cours_3/5-Feed_Internet.html#introduction-au-développement-web-backend-avec-python",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Python est une langue de choix pour le développement web backend en raison de sa simplicité, de sa lisibilité et de la richesse de ses frameworks web. Ces frameworks facilitent la création d’applications web robustes et évolutives.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#frameworks-web-python-populaires",
    "href": "content/Cours_3/5-Feed_Internet.html#frameworks-web-python-populaires",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Django:\n\nUn framework web haut niveau qui encourage un développement rapide et propre. Il est idéal pour les projets de grande envergure grâce à sa structure “batteries incluses”.\nFonctionnalités clés :\n\nORM (Object-Relational Mapping) intégré\nSystème d’administration robuste\nSécurité renforcée\n\n\nFlask:\n\nUn micro-framework léger, flexible et plus adapté aux petits projets ou aux applications avec des exigences spécifiques.\nPoints forts :\n\nSimplicité et flexibilité\nFacilité de déploiement\nExtensible avec de nombreux plugins\n\n\nFastAPI:\n\nUn framework moderne, rapide (basé sur Starlette et Pydantic) pour construire des API avec Python 3.7+. Il est conçu pour être facile à utiliser tout en offrant des performances élevées.\nAvantages :\n\nSupport natif pour les requêtes asynchrones\nGénération automatique de documentation (Swagger UI)\nValidation de données et sérialisation",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#exercice-pratique",
    "href": "content/Cours_3/5-Feed_Internet.html#exercice-pratique",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Objectif: Créer une simple API avec Flask.\nÉnoncé: Développez une API RESTful qui renvoie “Hello, World!” à chaque requête GET sur le chemin racine.\nSolution:\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return \"Hello, World!\"\n\nif __name__ == '__main__':\n    app.run(debug=True)",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#bonnes-pratiques-de-développement-web-backend",
    "href": "content/Cours_3/5-Feed_Internet.html#bonnes-pratiques-de-développement-web-backend",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Sécurité : Protéger les applications contre les attaques courantes telles que l’injection SQL, le cross-site scripting (XSS) et le cross-site request forgery (CSRF).\nGestion des Dépendances : Utiliser des environnements virtuels et gérer les dépendances pour assurer la cohérence des projets.\nTest et Débogage : Écrire des tests unitaires et utiliser des outils de débogage pour maintenir la qualité du code.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#conclusion",
    "href": "content/Cours_3/5-Feed_Internet.html#conclusion",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Le développement web backend en Python, grâce à des frameworks comme Django, Flask et FastAPI, offre une grande flexibilité et une base solide pour construire des applications web. Que vous construisiez une simple application web ou une API complexe, Python a les outils et les bibliothèques nécessaires pour répondre aux besoins de votre projet.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#introduction-à-fastapi",
    "href": "content/Cours_3/5-Feed_Internet.html#introduction-à-fastapi",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "FastAPI est un framework moderne et rapide pour la construction d’APIs avec Python, qui offre une performance élevée et une écriture de code rapide et efficace. Il est particulièrement apprécié pour sa facilité d’intégration avec les systèmes asynchrones et ses fonctionnalités automatiques de documentation.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#exemples-dutilisation-de-fastapi",
    "href": "content/Cours_3/5-Feed_Internet.html#exemples-dutilisation-de-fastapi",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Création d’une API CRUD (Create, Read, Update, Delete):\n\nFastAPI simplifie la création d’APIs CRUD, qui sont essentielles dans de nombreuses applications web pour gérer les données.\nExemple de base : ```python from fastapi import FastAPI from pydantic import BaseModel\n\n\napp = FastAPI()\nclass Item(BaseModel): name: str description: str = None price: float tax: float = None\n@app.post(“/items/”) async def create_item(item: Item): return item\n@app.get(“/items/{item_id}”) async def read_item(item_id: int): return {“item_id”: item_id} ```\n\nIntégration avec des Bases de Données:\n\nFastAPI peut être facilement intégré avec des bases de données comme PostgreSQL, MySQL, ou MongoDB.\nUtilisation avec SQLAlchemy (pour les bases de données SQL) :\nfrom fastapi import FastAPI\nfrom sqlalchemy import create_engine\n\napp = FastAPI()\nengine = create_engine('postgresql://user:password@localhost/dbname')\n\n@app.get(\"/items/\")\nasync def read_items():\n    with engine.connect() as connection:\n        result = connection.execute(\"SELECT * FROM items\")\n        items = result.fetchall()\n    return items\n\nValidation et Sérialisation des Données:\n\nFastAPI utilise Pydantic pour la validation des données entrantes et la sérialisation des données sortantes.\nExemple avec un modèle Pydantic :\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    username: str\n    full_name: str = None\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return user\n\nAuthentification et Sécurité:\n\nFastAPI fournit plusieurs outils pour l’authentification et la gestion de la sécurité, y compris OAuth2.\nExemple d’authentification basique :\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@app.get(\"/users/me\")\nasync def read_users_me(token: str = Depends(oauth2_scheme)):\n    return {\"token\": token}",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#conclusion-1",
    "href": "content/Cours_3/5-Feed_Internet.html#conclusion-1",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "FastAPI est un outil extrêmement puissant pour la création d’APIs modernes en Python. Sa facilité d’utilisation, sa performance élevée, et ses fonctionnalités intégrées comme la documentation automatique, la validation des données, et les fonctionnalités de sécurité, en font un choix idéal pour les développeurs souhaitant créer des APIs robustes et efficaces.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#mise-en-cache-pour-améliorer-les-performances",
    "href": "content/Cours_3/5-Feed_Internet.html#mise-en-cache-pour-améliorer-les-performances",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "La mise en cache est une technique cruciale pour améliorer les performances des applications web en réduisant le temps de réponse des requêtes répétitives.\n\nMise en Cache avec Redis:\n\nRedis, en tant que magasin de données en mémoire, est souvent utilisé pour le cache dans les applications web.\nUtilisation avec FastAPI :\nimport redis\nfrom fastapi import FastAPI\n\napp = FastAPI()\nredis_client = redis.Redis(host='localhost', port=6379, db=0)\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    cached_item = redis_client.get(item_id)\n    if cached_item:\n        return cached_item\n    # Sinon, récupérer l'élément de la base de données, le mettre en cache, et le retourner",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#traitement-asynchrone-des-données",
    "href": "content/Cours_3/5-Feed_Internet.html#traitement-asynchrone-des-données",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "Le traitement asynchrone est essentiel pour gérer les opérations I/O sans bloquer le serveur, en particulier dans les applications Web hautement scalables.\n\nUtilisation de async et await avec FastAPI:\n\nFastAPI prend en charge la programmation asynchrone native, ce qui permet de gérer facilement les requêtes asynchrones.\nExemple de requête asynchrone :\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    # Opération asynchrone, comme une requête de base de données\n    item = await get_item(item_id)\n    return item",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#scalabilité-et-performance",
    "href": "content/Cours_3/5-Feed_Internet.html#scalabilité-et-performance",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "La capacité à gérer une charge croissante de requêtes est un facteur clé pour le succès des applications web.\n\nUtilisation de Serveurs Asynchrones:\n\nDes serveurs tels que Uvicorn ou Hypercorn offrent des performances accrues pour les applications asynchrones en Python.\nExemple de déploiement avec Uvicorn :\nuvicorn myapp:app --host 0.0.0.0 --port 8000\n\nLoad Balancing:\n\nLe load balancing, avec des outils comme Nginx ou HAProxy, est crucial pour distribuer efficacement le trafic entre plusieurs instances de votre application.\n\nOptimisation des Bases de Données:\n\nUtiliser des techniques comme l’indexation, les requêtes optimisées et les pools de connexions pour améliorer les performances des bases de données.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Feed_Internet.html#conclusion-2",
    "href": "content/Cours_3/5-Feed_Internet.html#conclusion-2",
    "title": "Python - Aussi un language pour servir des données",
    "section": "",
    "text": "L’intégration web en Python, en utilisant des technologies telles que FastAPI, Redis, et des serveurs asynchrones, offre des moyens efficaces pour créer des applications web performantes et scalables. Les pratiques telles que la mise en cache, le traitement asynchrone, et la scalabilité sont essentielles pour répondre aux exigences des applications web modernes.",
    "crumbs": [
      "Python - Aussi un language pour servir des données"
    ]
  },
  {
    "objectID": "content/Cours_3/index.html",
    "href": "content/Cours_3/index.html",
    "title": "Les Librairies Python",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalcul Scientifique et Optimization\n\n\nNumpy, Scipy, pour ne cité qu’eux\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLes DataFrames\n\n\nLes DataFrames\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMachine Learning\n\n\nPython, où le ML à deux cliques de souris\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython - Aussi un language pour servir des données\n\n\nDjango, FastAPI, Flask, Bottle, Pyramid, Falcon, Sanic, Tornado, AIOHTTP, Starlette,… La liste est longue\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecupérer des données du net\n\n\nRequête HTTP, Webscrapping, websockets, API, JSON, XML, CSV, HTML, SQL, NoSQL, FTP, SSH, …\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP-3 Libraries\n\n\nMise en pratique simple des éléments vu aurparavant.\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVisualiser et présenter ces données avec Python\n\n\nMatplotlib, Plotly ou Seaborn ? Peut être Altair !\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Les Librairies Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Access_Internet.html",
    "href": "content/Cours_3/4-Access_Internet.html",
    "title": "Recupérer des données du net",
    "section": "",
    "text": "Recupérer des données du net\n\n\nChapitre sur l’Accès à Internet en Python\n\nIntroduction à l’Accès Internet en Python\nPython fournit plusieurs bibliothèques pour interagir avec le Web, permettant des opérations telles que le scraping de données, les requêtes Web, et l’interaction avec les API.\n\n\nBibliothèques Clés pour l’Accès à Internet\n\nRequests: Une bibliothèque Python simplifiée pour envoyer des requêtes HTTP. Elle est idéale pour interagir avec des API RESTful.\n\nExemple d’utilisation :\nimport requests\nresponse = requests.get('https://api.exemple.com/data')\ndata = response.json()\n\nBeautiful Soup: Utilisée pour le web scraping, Beautiful Soup permet d’analyser le contenu HTML et d’extraire les données nécessaires.\n\nExemple de scraping :\nfrom bs4 import BeautifulSoup\nsoup = BeautifulSoup(html_content, 'html.parser')\ntitles = soup.find_all('h1')\n\nScrapy: Un framework puissant pour créer des crawlers Web. Il est utilisé pour des scrapings plus complexes et des bots d’indexation.\n\nUtilisation typique :\nimport scrapy\n\nclass MySpider(scrapy.Spider):\n    name = 'exemple_spider'\n    start_urls = ['http://exemple.com']\n\n    def parse(self, response):\n        # Extraction de données\n        pass\n\n\n\n\nExercice Pratique\n\nObjectif: Se familiariser avec les requêtes Web et le scraping en Python.\nÉnoncé: Écrivez un script qui récupère les titres des dernières nouvelles d’un site d’actualités et les affiche.\nSolution:\nimport requests\nfrom bs4 import BeautifulSoup\n\nresponse = requests.get('https://news.exemple.com')\nsoup = BeautifulSoup(response.content, 'html.parser')\n\nfor title in soup.find_all('h2'):\n    print(title.text.strip())\n\n\n\nSécurité et Bonnes Pratiques\n\nRespecter les règles du robots.txt: S’assurer de respecter les directives du fichier robots.txt des sites Web lors du scraping.\nGestion des erreurs et des exceptions: Traiter correctement les réponses HTTP, comme les erreurs 404 ou 503.\nUtiliser des headers de requête appropriés: Inclure des informations d’en-tête comme User-Agent pour éviter d’être bloqué par les sites Web.\n\n\n\nConclusion\nL’accès à Internet en Python, grâce à des bibliothèques comme Requests, Beautiful Soup et Scrapy, offre un potentiel immense pour collecter et traiter des données du Web. Que ce soit pour des tâches simples comme récupérer des données d’une API ou pour des projets de scraping Web plus complexes, Python fournit les outils nécessaires pour interagir efficacement avec le Web.\n\nDans le prochain chapitre, nous explorerons comment Python peut être utilisé pour “alimenter” le Web, en se concentrant sur les frameworks Web et le développement backend en Python.\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Recupérer des données du net"
    ]
  },
  {
    "objectID": "content/Projets/index.html",
    "href": "content/Projets/index.html",
    "title": "Projets",
    "section": "",
    "text": "Projets\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProjets Introduction à Python - Millésime 2024\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La syntaxe de Python est conçue pour être lisible et concise. Comprendre ses particularités peut vous aider à écrire du code plus efficace et expressif.\n\n\n\nExpressions : En Python, chaque ligne de code est généralement une expression, par exemple a = 5 ou print(a).\nIndentations : Python utilise l’indentation pour définir des blocs de code. Contrairement à d’autres langages qui utilisent des accolades, l’indentation en Python n’est pas seulement pour la lisibilité mais est syntaxiquement significative.\n\n\na=10\nif a &gt; 5:\n    print(\"a est supérieur à 5\")\n\na est supérieur à 5\n\n\n\n\n\n\nEn Python, les commentaires commencent par #. Tout ce qui suit # sur la ligne est ignoré par l’interpréteur.\n\n\n# Ceci est un commentaire\nprint(\"Hello, World!\")  # Ceci est un commentaire en fin de ligne\n\nHello, World!\n\n\n\nNB: L’utilisation du # est utilisé dans de nombreux langages de programmation, comme le C, le C++, le Java, le PHP, le Perl, le Ruby, le Python, etc. pour définir les commentaires\n\n\n\n\n\nNombres : Python supporte int, float, et plus rarement utilisés, complex.\nChaînes de Caractères : Déclarées avec des guillemets simples 'texte' ou doubles \"texte\". Le + peut concaténer des chaînes.\nBooléens : True et False. Intéressant, en Python, 0, None, un string vide '', et les collections vides comme [], {} sont considérés comme équivalents à False.\n\n\n\n\n\n\nLes variables en Python sont des identificateurs liés à des valeurs. Elles ne nécessitent pas de déclaration explicite de type.\n\n\n\nLes noms de variables doivent commencer par une lettre ou un underscore _, suivis de lettres, chiffres, ou underscores.\nLes conventions de nommage courantes incluent snake_case pour les variables et fonctions, CamelCase pour les classes.\n\nma_variable = 10\nuneAutreVariable = \"Bonjour\"\n\n\n\n\n\n\nPython offre une gamme complète d’opérateurs arithmétiques (+, -, *, /, // pour la division entière, % pour le modulo, ** pour la puissance) et de comparaison (==, !=, &gt;, &lt;, &gt;=, &lt;=).\n\n\n\n\n\nLes opérateurs logiques incluent and, or, et not.\n\n\n\n\n\nOpérateurs Bitwise : Opèrent sur des bits et incluent & (ET), | (OU), ^ (XOR), ~ (NON), &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite).\nOpérateur d’Identité : is et is not vérifient si deux variables pointent vers le même objet.\nOpérateur d’Appartenance : in et not in vérifient si une valeur est présente dans une séquence.\n\n\n\n\n\n\nLes structures de contrôle en Python permettent d’exécuter conditionnellement des blocs de code ou de répéter des opérations.\n\n\n\nif, else, elif permettent d’exécuter des blocs de code basés sur des conditions.\nif condition:\n    # code si condition est vraie\nelif autre_condition:\n    # code si autre_condition est vraie\nelse:\n    # code si aucune des conditions précédentes n'est vraie\n\n\n\n\n\nBoucle For : Itère sur une séquence (comme une liste, un tuple, un dictionnaire, un ensemble, ou une chaîne de caractères).\nfor element in sequence:\n    # code exécuté pour chaque élément\nBoucle While : Continue à exécuter un bloc de code tant qu’une condition est vraie.\nwhile condition:\n    # code exécuté tant que la condition est vraie\n\nCompréhensions de Liste\n\nUne façon concise de créer des listes. Par exemple, [x for x in range(10)] crée une liste des nombres de 0 à 9.\n\n\n\n\n\n\nLa gestion des erreurs est cruciale pour écrire des applications robustes. Python fournit un mécanisme de gestion des exceptions pour gérer les erreurs de manière contrôlée.\n\n\n\nUn bloc try permet de tester un bloc de code pour les erreurs, et le bloc except permet de gérer l’erreur.\n\ntry:\n    # Code à essayer d'exécuter\n    resultat = 10 / 0\nexcept ZeroDivisionError:\n    # Code exécuté en cas de ZeroDivisionError\n    print(\"Division par zéro!\")\n\nDivision par zéro!\n\n\n\n\n\n\nVous pouvez spécifier plusieurs blocs except pour gérer différentes exceptions.\ntry:\n    # Tentative d'exécution de code\nexcept TypeError:\n    # Gestion d'une TypeError\nexcept ValueError:\n    # Gestion d'une ValueError\n\n\n\nLe bloc finally est facultatif et exécuté quel que soit le résultat des blocs try et except.\ntry:\n    # Code à essayer\nexcept:\n    # Gestion d'une exception\nfinally:\n    # Code exécuté après les blocs try et except\n\n\n\n\nVoyons comment on peut combiner les concepts abordés précédemment dans un exemple pratique. Cet exemple utilise une boucle while, une instruction conditionnelle if, et gère une éventuelle exception.\n\n\nImaginons un scénario où nous avons deux variables x et y. Nous voulons exécuter une boucle qui continue tant que la somme de x et y est supérieure à 8. Dans la boucle, nous effectuons une opération qui peut potentiellement lever une exception.\nx = 10\ny = 1\n\nwhile x + y &gt; 8:\n    try:\n        # Si x est impair, essayez de diviser par zéro (pour générer une exception)\n        if x % 2 != 0:\n            resultat = x / 0\n        # Autrement, décrémentez x\n        else:\n            x -= 1\n    except ZeroDivisionError:\n        print(\"Tentative de division par zéro. 'x' était impair.\")\n        break\n    finally:\n        # Décrémentez y à chaque itération\n        y -= 1\n\nprint(f\"Fin de la boucle avec x = {x} et y = {y}\")\nDans cet exemple, la boucle while continue de s’exécuter tant que la condition x + y &gt; 8 est vraie. Si x est impair, le code essaie de diviser par zéro, ce qui lève une ZeroDivisionError. Dans ce cas, le message d’erreur est imprimé, et le mot-clé break interrompt la boucle. Le bloc finally est exécuté après chaque itération, peu importe les erreurs.\n\n\n\n\nPython offre plusieurs structures de données intégrées, comme les listes et les tuples, qui sont essentielles pour le stockage et la manipulation de données.\n\n\n\nLes listes en Python sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de différents types.\n\nma_liste = [1, 2, 3, \"Python\", True]\n\nOpérations de Base sur les Listes :\n\nAjout d’éléments (append, extend).\nSuppression d’éléments (remove, pop).\nAccès et slicing (ma_liste[0], ma_liste[1:3]).\n\n\n\n\n\n\nLes tuples sont similaires aux listes, mais ils sont immuables (leurs valeurs ne peuvent pas être modifiées après leur création).\n\nmon_tuple = (1, 2, 3, \"Python\")\n\nUtilisés pour des données qui ne doivent pas être modifiées, comme les clés dans les dictionnaires.\n\n\n\n\n\nLes dictionnaires et les ensembles sont des structures de données puissantes pour stocker et gérer des ensembles de données.\n\n\n\nLes dictionnaires stockent des paires clé-valeur. Ils sont mutables et non ordonnés.\n\nmon_dictionnaire = {\"nom\": \"Alice\", \"age\": 30, \"langage\": \"Python\"}\n\nManipulation de Dictionnaires :\n\nAjout et modification d’éléments (mon_dictionnaire[\"nom\"] = \"Bob\").\nSuppression d’éléments (del mon_dictionnaire[\"age\"], mon_dictionnaire.pop(\"langage\")).\nAccès sécurisé (get).\n\n\n\n\n\n\nLes ensembles sont des collections non ordonnées de valeurs uniques. Utiles pour les opérations mathématiques comme les unions, intersections, et différences.\n\nmon_ensemble = {1, 2, 3, 4, 5}\n\nOpérations sur les Ensembles :\n\nAjout (add) et suppression (remove) d’éléments.\nOpérations comme union, intersection, et difference.\n\n\n\n\n\n\nVoyons comment combiner listes, tuples, dictionnaires et ensembles dans un exemple pratique.\n\n\nSupposons que nous avons une liste de tuples, chaque tuple contenant le nom d’un étudiant et son score. Nous voulons créer un dictionnaire où chaque clé est un score unique, et la valeur est la liste des noms d’étudiants ayant ce score.\n::: {#aa4fd0f8 .cell execution_count=9} ``` {.python .cell-code} etudiants = [(“Alice”, 85), (“Bob”, 90), (“Eve”, 85), (“Dave”, 90), (“Carol”, 75)] scores = {}\nfor nom, score in etudiants: if score not in scores: scores[score] = [nom] else: scores[score].append(nom)\nprint(scores) # {85: [‘Alice’, ‘Eve’], 90: [‘Bob’, ‘Dave’], 75: [‘Carol’]} ```\n::: {.cell-output .cell-output-stdout} {85: ['Alice', 'Eve'], 90: ['Bob', 'Dave'], 75: ['Carol']} ::: :::\nDans cet exemple, nous parcourons la liste etudiants. Pour chaque tuple, nous vérifions si le score est déjà une clé dans le dictionnaire scores. Si ce n’est pas le cas, nous ajoutons une nouvelle clé avec le score et initialisons sa valeur avec une liste contenant le nom de l’étudiant. Si le score existe déjà, nous ajoutons simplement le nom de l’étudiant à la liste correspondante.\n\n\n\n\n\nLes compréhensions en Python sont un moyen concis et puissant de créer de nouvelles listes, dictionnaires ou ensembles à partir de séquences ou d’autres structures itérables.\n\n\n\nLes compréhensions de liste fournissent une façon concise de créer des listes. Elles consistent en une expression suivie par une clause for, puis zéro ou plusieurs clauses for ou if.\n\n# Création d'une liste des carrés des nombres de 0 à 9\ncarres = [x**2 for x in range(10)]\n\n\n\n\n\n\nSemblables aux compréhensions de liste, mais créent des dictionnaires. Elles sont entourées de {} avec une paire clé-valeur suivie d’une clause for.\n\n# Création d'un dictionnaire avec des nombres et leurs carrés\ncarres_dict = {x: x**2 for x in range(5)}\n\n\n\n\n\n\nUtilisées pour créer des ensembles de manière similaire aux compréhensions de liste, mais avec des éléments uniques.\n\n# Création d'un ensemble de carrés des nombres impairs\ncarres_impairs = {x**2 for x in range(10) if x % 2 != 0}\n\n\n\n\n\n\nLes compréhensions peuvent être particulièrement utiles pour transformer et filtrer des données. Voici un exemple qui utilise des compréhensions de liste et de dictionnaire pour traiter des données.\n\n\nImaginons que nous avons une liste de mots et que nous voulons créer un dictionnaire qui associe chaque mot à sa longueur, mais seulement pour les mots de plus de trois lettres.\n::: {#eec9808c .cell execution_count=13} ``` {.python .cell-code} mots = [“python”, “est”, “un”, “langage”, “puissant”] longueur_mots = {mot: len(mot) for mot in mots if len(mot) &gt; 3}\nprint(longueur_mots) # {‘python’: 6, ‘langage’: 7, ‘puissant’: 8} ```\n::: {.cell-output .cell-output-stdout} {'python': 6, 'langage': 7, 'puissant': 8} ::: :::\nDans cet exemple, la compréhension de dictionnaire parcourt la liste mots, incluant uniquement les mots dont la longueur dépasse trois lettres. Pour chaque mot éligible, le dictionnaire longueur_mots est construit avec le mot comme clé et sa longueur comme valeur.\n\n\n\n\nLes opérateurs ternaires et les expressions lambda en Python offrent des moyens concis d’effectuer des opérations conditionnelles et de créer de petites fonctions anonymes.\n\n\n\nLes opérateurs ternaires permettent d’écrire des instructions conditionnelles en une seule ligne. La syntaxe est : [valeur_si_vrai] if [condition] else [valeur_si_faux].\n\n# Exemple d'opérateur ternaire\nage = 20\nstatut = \"majeur\" if age &gt;= 18 else \"mineur\"\n\n\n\n\n\n\nLes expressions lambda permettent de créer de petites fonctions anonymes. Elles sont utiles pour des opérations simples nécessitant une fonction.\n\n# Exemple d'expression lambda\nadditionner = lambda x, y: x + y\nprint(additionner(5, 3))  # Affiche 8\n\n8\n\n\n\n\n\n\n\nPython fournit des outils puissants pour manipuler des listes, des tuples et d’autres séquences de manière expressive.\n\n\n\nLe slicing permet de sélectionner des sous-parties d’une séquence. En plus des bases, Python permet des slicings plus complexes.\n\nma_liste = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsous_liste = ma_liste[::2]  # Sélectionne chaque élément pair\n\n\n\n\n\n\nLes listes et dictionnaires peuvent être imbriqués pour créer des structures de données complexes.\n\n# Exemple de dictionnaire contenant des listes\ninformations = {\n    \"nom\": \"Alice\",\n    \"hobbies\": [\"programmation\", \"jeux vidéo\", \"lecture\"]\n}\n\n\n\n\n\n\nPour conclure ce chapitre, combinons plusieurs des concepts abordés dans un exemple illustrant leur utilité pratique.\n\n\nSupposons que nous avons une liste de dictionnaires représentant des livres, et nous voulons extraire les titres des livres publiés après 2000.\n::: {#cd67f5e5 .cell execution_count=18} ``` {.python .cell-code} livres = [ {“titre”: “Python 101”, “année”: 1999}, {“titre”: “Le Guide du Voyageur Galactique”, “année”: 1979}, {“titre”: “Apprendre la Programmation”, “année”: 2015} ]\ntitres_recent = [livre[“titre”] for livre in livres if livre[“année”] &gt; 2000] print(titres_recent) # Affiche [‘Apprendre la Programmation’] ```\n::: {.cell-output .cell-output-stdout} ['Apprendre la Programmation'] ::: :::\nDans cet exemple, une compréhension de liste est utilisée pour parcourir livres, en extrayant le titre de chaque livre dont l’année est supérieure à 2000. Cela démontre comment les compréhensions de liste peuvent être utilisées pour filtrer et transformer des données de manière concise et lisible. ```\nPour vous entrainez à pratiquer ces notions:\n Telecharger le premier jeu d'exercice \n Telecharger le premier second d'exercice",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.1-les-bases-de-la-syntaxe-python",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.1-les-bases-de-la-syntaxe-python",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La syntaxe de Python est conçue pour être lisible et concise. Comprendre ses particularités peut vous aider à écrire du code plus efficace et expressif.\n\n\n\nExpressions : En Python, chaque ligne de code est généralement une expression, par exemple a = 5 ou print(a).\nIndentations : Python utilise l’indentation pour définir des blocs de code. Contrairement à d’autres langages qui utilisent des accolades, l’indentation en Python n’est pas seulement pour la lisibilité mais est syntaxiquement significative.\n\n\na=10\nif a &gt; 5:\n    print(\"a est supérieur à 5\")\n\na est supérieur à 5\n\n\n\n\n\n\nEn Python, les commentaires commencent par #. Tout ce qui suit # sur la ligne est ignoré par l’interpréteur.\n\n\n# Ceci est un commentaire\nprint(\"Hello, World!\")  # Ceci est un commentaire en fin de ligne\n\nHello, World!\n\n\n\nNB: L’utilisation du # est utilisé dans de nombreux langages de programmation, comme le C, le C++, le Java, le PHP, le Perl, le Ruby, le Python, etc. pour définir les commentaires\n\n\n\n\n\nNombres : Python supporte int, float, et plus rarement utilisés, complex.\nChaînes de Caractères : Déclarées avec des guillemets simples 'texte' ou doubles \"texte\". Le + peut concaténer des chaînes.\nBooléens : True et False. Intéressant, en Python, 0, None, un string vide '', et les collections vides comme [], {} sont considérés comme équivalents à False.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.2-variables-et-opérateurs",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.2-variables-et-opérateurs",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les variables en Python sont des identificateurs liés à des valeurs. Elles ne nécessitent pas de déclaration explicite de type.\n\n\n\nLes noms de variables doivent commencer par une lettre ou un underscore _, suivis de lettres, chiffres, ou underscores.\nLes conventions de nommage courantes incluent snake_case pour les variables et fonctions, CamelCase pour les classes.\n\nma_variable = 10\nuneAutreVariable = \"Bonjour\"\n\n\n\n\n\n\nPython offre une gamme complète d’opérateurs arithmétiques (+, -, *, /, // pour la division entière, % pour le modulo, ** pour la puissance) et de comparaison (==, !=, &gt;, &lt;, &gt;=, &lt;=).\n\n\n\n\n\nLes opérateurs logiques incluent and, or, et not.\n\n\n\n\n\nOpérateurs Bitwise : Opèrent sur des bits et incluent & (ET), | (OU), ^ (XOR), ~ (NON), &lt;&lt; (décalage à gauche), &gt;&gt; (décalage à droite).\nOpérateur d’Identité : is et is not vérifient si deux variables pointent vers le même objet.\nOpérateur d’Appartenance : in et not in vérifient si une valeur est présente dans une séquence.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.3-structures-de-contrôle",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.3-structures-de-contrôle",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les structures de contrôle en Python permettent d’exécuter conditionnellement des blocs de code ou de répéter des opérations.\n\n\n\nif, else, elif permettent d’exécuter des blocs de code basés sur des conditions.\nif condition:\n    # code si condition est vraie\nelif autre_condition:\n    # code si autre_condition est vraie\nelse:\n    # code si aucune des conditions précédentes n'est vraie\n\n\n\n\n\nBoucle For : Itère sur une séquence (comme une liste, un tuple, un dictionnaire, un ensemble, ou une chaîne de caractères).\nfor element in sequence:\n    # code exécuté pour chaque élément\nBoucle While : Continue à exécuter un bloc de code tant qu’une condition est vraie.\nwhile condition:\n    # code exécuté tant que la condition est vraie\n\nCompréhensions de Liste\n\nUne façon concise de créer des listes. Par exemple, [x for x in range(10)] crée une liste des nombres de 0 à 9.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.4-gestion-des-erreurs-et-exceptions",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.4-gestion-des-erreurs-et-exceptions",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "La gestion des erreurs est cruciale pour écrire des applications robustes. Python fournit un mécanisme de gestion des exceptions pour gérer les erreurs de manière contrôlée.\n\n\n\nUn bloc try permet de tester un bloc de code pour les erreurs, et le bloc except permet de gérer l’erreur.\n\ntry:\n    # Code à essayer d'exécuter\n    resultat = 10 / 0\nexcept ZeroDivisionError:\n    # Code exécuté en cas de ZeroDivisionError\n    print(\"Division par zéro!\")\n\nDivision par zéro!\n\n\n\n\n\n\nVous pouvez spécifier plusieurs blocs except pour gérer différentes exceptions.\ntry:\n    # Tentative d'exécution de code\nexcept TypeError:\n    # Gestion d'une TypeError\nexcept ValueError:\n    # Gestion d'une ValueError\n\n\n\nLe bloc finally est facultatif et exécuté quel que soit le résultat des blocs try et except.\ntry:\n    # Code à essayer\nexcept:\n    # Gestion d'une exception\nfinally:\n    # Code exécuté après les blocs try et except",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.5-exemple-concret-mélangeant-les-concepts",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.5-exemple-concret-mélangeant-les-concepts",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Voyons comment on peut combiner les concepts abordés précédemment dans un exemple pratique. Cet exemple utilise une boucle while, une instruction conditionnelle if, et gère une éventuelle exception.\n\n\nImaginons un scénario où nous avons deux variables x et y. Nous voulons exécuter une boucle qui continue tant que la somme de x et y est supérieure à 8. Dans la boucle, nous effectuons une opération qui peut potentiellement lever une exception.\nx = 10\ny = 1\n\nwhile x + y &gt; 8:\n    try:\n        # Si x est impair, essayez de diviser par zéro (pour générer une exception)\n        if x % 2 != 0:\n            resultat = x / 0\n        # Autrement, décrémentez x\n        else:\n            x -= 1\n    except ZeroDivisionError:\n        print(\"Tentative de division par zéro. 'x' était impair.\")\n        break\n    finally:\n        # Décrémentez y à chaque itération\n        y -= 1\n\nprint(f\"Fin de la boucle avec x = {x} et y = {y}\")\nDans cet exemple, la boucle while continue de s’exécuter tant que la condition x + y &gt; 8 est vraie. Si x est impair, le code essaie de diviser par zéro, ce qui lève une ZeroDivisionError. Dans ce cas, le message d’erreur est imprimé, et le mot-clé break interrompt la boucle. Le bloc finally est exécuté après chaque itération, peu importe les erreurs.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.6-structures-de-données-de-base---listes-et-tuples",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.6-structures-de-données-de-base---listes-et-tuples",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Python offre plusieurs structures de données intégrées, comme les listes et les tuples, qui sont essentielles pour le stockage et la manipulation de données.\n\n\n\nLes listes en Python sont des collections ordonnées et modifiables. Elles peuvent contenir des éléments de différents types.\n\nma_liste = [1, 2, 3, \"Python\", True]\n\nOpérations de Base sur les Listes :\n\nAjout d’éléments (append, extend).\nSuppression d’éléments (remove, pop).\nAccès et slicing (ma_liste[0], ma_liste[1:3]).\n\n\n\n\n\n\nLes tuples sont similaires aux listes, mais ils sont immuables (leurs valeurs ne peuvent pas être modifiées après leur création).\n\nmon_tuple = (1, 2, 3, \"Python\")\n\nUtilisés pour des données qui ne doivent pas être modifiées, comme les clés dans les dictionnaires.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.7-structures-de-données-de-base---dictionnaires-et-ensembles",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.7-structures-de-données-de-base---dictionnaires-et-ensembles",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les dictionnaires et les ensembles sont des structures de données puissantes pour stocker et gérer des ensembles de données.\n\n\n\nLes dictionnaires stockent des paires clé-valeur. Ils sont mutables et non ordonnés.\n\nmon_dictionnaire = {\"nom\": \"Alice\", \"age\": 30, \"langage\": \"Python\"}\n\nManipulation de Dictionnaires :\n\nAjout et modification d’éléments (mon_dictionnaire[\"nom\"] = \"Bob\").\nSuppression d’éléments (del mon_dictionnaire[\"age\"], mon_dictionnaire.pop(\"langage\")).\nAccès sécurisé (get).\n\n\n\n\n\n\nLes ensembles sont des collections non ordonnées de valeurs uniques. Utiles pour les opérations mathématiques comme les unions, intersections, et différences.\n\nmon_ensemble = {1, 2, 3, 4, 5}\n\nOpérations sur les Ensembles :\n\nAjout (add) et suppression (remove) d’éléments.\nOpérations comme union, intersection, et difference.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.8-exemple-pratique-mélangeant-les-structures-de-données",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.8-exemple-pratique-mélangeant-les-structures-de-données",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Voyons comment combiner listes, tuples, dictionnaires et ensembles dans un exemple pratique.\n\n\nSupposons que nous avons une liste de tuples, chaque tuple contenant le nom d’un étudiant et son score. Nous voulons créer un dictionnaire où chaque clé est un score unique, et la valeur est la liste des noms d’étudiants ayant ce score.\n::: {#aa4fd0f8 .cell execution_count=9} ``` {.python .cell-code} etudiants = [(“Alice”, 85), (“Bob”, 90), (“Eve”, 85), (“Dave”, 90), (“Carol”, 75)] scores = {}\nfor nom, score in etudiants: if score not in scores: scores[score] = [nom] else: scores[score].append(nom)\nprint(scores) # {85: [‘Alice’, ‘Eve’], 90: [‘Bob’, ‘Dave’], 75: [‘Carol’]} ```\n::: {.cell-output .cell-output-stdout} {85: ['Alice', 'Eve'], 90: ['Bob', 'Dave'], 75: ['Carol']} ::: :::\nDans cet exemple, nous parcourons la liste etudiants. Pour chaque tuple, nous vérifions si le score est déjà une clé dans le dictionnaire scores. Si ce n’est pas le cas, nous ajoutons une nouvelle clé avec le score et initialisons sa valeur avec une liste contenant le nom de l’étudiant. Si le score existe déjà, nous ajoutons simplement le nom de l’étudiant à la liste correspondante.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.9-compréhensions-de-liste-de-dictionnaire-et-densemble",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.9-compréhensions-de-liste-de-dictionnaire-et-densemble",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les compréhensions en Python sont un moyen concis et puissant de créer de nouvelles listes, dictionnaires ou ensembles à partir de séquences ou d’autres structures itérables.\n\n\n\nLes compréhensions de liste fournissent une façon concise de créer des listes. Elles consistent en une expression suivie par une clause for, puis zéro ou plusieurs clauses for ou if.\n\n# Création d'une liste des carrés des nombres de 0 à 9\ncarres = [x**2 for x in range(10)]\n\n\n\n\n\n\nSemblables aux compréhensions de liste, mais créent des dictionnaires. Elles sont entourées de {} avec une paire clé-valeur suivie d’une clause for.\n\n# Création d'un dictionnaire avec des nombres et leurs carrés\ncarres_dict = {x: x**2 for x in range(5)}\n\n\n\n\n\n\nUtilisées pour créer des ensembles de manière similaire aux compréhensions de liste, mais avec des éléments uniques.\n\n# Création d'un ensemble de carrés des nombres impairs\ncarres_impairs = {x**2 for x in range(10) if x % 2 != 0}",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.10-exemple-concret-utilisant-les-compréhensions",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.10-exemple-concret-utilisant-les-compréhensions",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les compréhensions peuvent être particulièrement utiles pour transformer et filtrer des données. Voici un exemple qui utilise des compréhensions de liste et de dictionnaire pour traiter des données.\n\n\nImaginons que nous avons une liste de mots et que nous voulons créer un dictionnaire qui associe chaque mot à sa longueur, mais seulement pour les mots de plus de trois lettres.\n::: {#eec9808c .cell execution_count=13} ``` {.python .cell-code} mots = [“python”, “est”, “un”, “langage”, “puissant”] longueur_mots = {mot: len(mot) for mot in mots if len(mot) &gt; 3}\nprint(longueur_mots) # {‘python’: 6, ‘langage’: 7, ‘puissant’: 8} ```\n::: {.cell-output .cell-output-stdout} {'python': 6, 'langage': 7, 'puissant': 8} ::: :::\nDans cet exemple, la compréhension de dictionnaire parcourt la liste mots, incluant uniquement les mots dont la longueur dépasse trois lettres. Pour chaque mot éligible, le dictionnaire longueur_mots est construit avec le mot comme clé et sa longueur comme valeur.",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.11-opérateurs-ternaires-et-expressions-lambda",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.11-opérateurs-ternaires-et-expressions-lambda",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Les opérateurs ternaires et les expressions lambda en Python offrent des moyens concis d’effectuer des opérations conditionnelles et de créer de petites fonctions anonymes.\n\n\n\nLes opérateurs ternaires permettent d’écrire des instructions conditionnelles en une seule ligne. La syntaxe est : [valeur_si_vrai] if [condition] else [valeur_si_faux].\n\n# Exemple d'opérateur ternaire\nage = 20\nstatut = \"majeur\" if age &gt;= 18 else \"mineur\"\n\n\n\n\n\n\nLes expressions lambda permettent de créer de petites fonctions anonymes. Elles sont utiles pour des opérations simples nécessitant une fonction.\n\n# Exemple d'expression lambda\nadditionner = lambda x, y: x + y\nprint(additionner(5, 3))  # Affiche 8\n\n8",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.12-techniques-avancées-de-manipulation-de-séquences",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.12-techniques-avancées-de-manipulation-de-séquences",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Python fournit des outils puissants pour manipuler des listes, des tuples et d’autres séquences de manière expressive.\n\n\n\nLe slicing permet de sélectionner des sous-parties d’une séquence. En plus des bases, Python permet des slicings plus complexes.\n\nma_liste = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nsous_liste = ma_liste[::2]  # Sélectionne chaque élément pair\n\n\n\n\n\n\nLes listes et dictionnaires peuvent être imbriqués pour créer des structures de données complexes.\n\n# Exemple de dictionnaire contenant des listes\ninformations = {\n    \"nom\": \"Alice\",\n    \"hobbies\": [\"programmation\", \"jeux vidéo\", \"lecture\"]\n}",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.13-exemple-pratique-combinant-plusieurs-concepts",
    "href": "content/Cours_2/1-FondamentauxSyntaxique.html#section-1.13-exemple-pratique-combinant-plusieurs-concepts",
    "title": "Syntaxe et objets de Base Python",
    "section": "",
    "text": "Pour conclure ce chapitre, combinons plusieurs des concepts abordés dans un exemple illustrant leur utilité pratique.\n\n\nSupposons que nous avons une liste de dictionnaires représentant des livres, et nous voulons extraire les titres des livres publiés après 2000.\n::: {#cd67f5e5 .cell execution_count=18} ``` {.python .cell-code} livres = [ {“titre”: “Python 101”, “année”: 1999}, {“titre”: “Le Guide du Voyageur Galactique”, “année”: 1979}, {“titre”: “Apprendre la Programmation”, “année”: 2015} ]\ntitres_recent = [livre[“titre”] for livre in livres if livre[“année”] &gt; 2000] print(titres_recent) # Affiche [‘Apprendre la Programmation’] ```\n::: {.cell-output .cell-output-stdout} ['Apprendre la Programmation'] ::: :::\nDans cet exemple, une compréhension de liste est utilisée pour parcourir livres, en extrayant le titre de chaque livre dont l’année est supérieure à 2000. Cela démontre comment les compréhensions de liste peuvent être utilisées pour filtrer et transformer des données de manière concise et lisible. ```\nPour vous entrainez à pratiquer ces notions:\n Telecharger le premier jeu d'exercice \n Telecharger le premier second d'exercice",
    "crumbs": [
      "Syntaxe et objets de Base Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La Programmation Orientée Objet (POO) est un paradigme de programmation basé sur le concept d’« objets », qui peuvent contenir des données sous forme d’attributs, et du code sous forme de méthodes. En Python, la POO offre une approche flexible et puissante pour structurer et concevoir des applications.\n\n\n\nEncapsulation: Regroupe les données et les méthodes qui manipulent ces données au sein d’une unité appelée « classe ». Cela permet de cacher la représentation interne des données à l’extérieur de la classe, une pratique connue sous le nom de “cachette d’information”.\nHéritage: Permet à une classe de hériter des attributs et méthodes d’une autre classe. Cela facilite la réutilisation du code et la création d’une hiérarchie de classes.\nPolymorphisme: Signifie que des fonctions ou des méthodes peuvent être utilisées avec des objets de différents types. Il s’appuie sur l’héritage pour fournir cette flexibilité.\n\n\n\n\n\nPython est un langage multi-paradigme qui supporte à la fois la programmation procédurale et la POO. Ce qui le rend particulièrement puissant est sa capacité à offrir une syntaxe claire et une grande flexibilité dans la conception de classes et d’objets.\nContrairement à d’autres langages où les objets et les types de base sont distincts, en Python, tout est un objet. Cela inclut les types de base comme les nombres, les chaînes et les listes. Cette uniformité rend le langage cohérent et élégant.\n\n\n  a = 10\n  print(a.__class__)  # Affiche &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;\n\n\n\nEn Python, même les fonctions sont des objets. Cela permet des concepts avancés comme les décorateurs et les fonctions de première classe.\n\n\n\n\n\nLa POO offre plusieurs avantages qui la rendent idéale pour un large éventail d’applications de programmation.\n\n\n\nModularité et Réutilisation du Code**: La POO en Python permet de créer des modules et des bibliothèques réutilisables. Les classes peuvent être conçues comme des composants réutilisables dans différents projets.\nSimplicité et Clarté: La structure de classe en POO permet une organisation claire du code. Cela facilite la maintenance et la mise à jour des applications.\nExtensibilité: La capacité à étendre les classes existantes via l’héritage rend le code adaptable et évolutif.\nAdaptabilité à de Multiples Domaines: De la conception de jeux à l’intelligence artificielle et au développement web, la POO est utilisée dans de nombreux domaines, reflétant sa polyvalence et son adaptabilité.\n\n\n\n\n\nPython ajoute une touche de flexibilité et de simplicité à la POO, rendant l’apprentissage et l’utilisation de ce paradigme plus accessibles par rapport à des langages plus stricts et formels.\nLes mécanismes avancés de Python, tels que le duck typing et les méthodes magiques, ouvrent des possibilités de conception et d’implémentation qui vont au-delà des approches traditionnelles de la POO.\nL’écosystème riche de Python en frameworks et bibliothèques orientés objet (comme Django pour le web ou Pandas pour la manipulation de données) montre l’efficacité et la popularité de la POO dans la communauté Python.\n\n\n\n\n\n\nLes classes sont au cœur de la POO en Python. Elles servent de modèle pour créer des objets (instances).\n\n\n\nUne classe en Python est définie en utilisant le mot-clé class. Elle peut contenir des attributs (variables) et des méthodes (fonctions).\n\n\nclass Voiture:\n    def __init__(self, marque, modele):\n        self.marque = marque\n        self.modele = modele\n\n    def afficher_info(self):\n        print(f\"Marque: {self.marque}, Modèle: {self.modele}\")\n\n# Création d'une instance de Voiture\nma_voiture = Voiture(\"Toyota\", \"Corolla\")\nma_voiture.afficher_info()  # Affiche \"Marque: Toyota, Modèle: Corolla\"\n\nMarque: Toyota, Modèle: Corolla\n\n\n\nLa méthode __init__ est un constructeur. Elle est appelée lors de la création d’une nouvelle instance de la classe.\n\n\n\n\n\nAprès avoir défini une classe, vous pouvez créer des instances (objets) et accéder à leurs attributs et méthodes.\n\n\n# Création d'une autre instance de Voiture\nautre_voiture = Voiture(\"Honda\", \"Civic\")\nautre_voiture.afficher_info()  # Affiche \"Marque: Honda, Modèle: Civic\"\n\nMarque: Honda, Modèle: Civic\n\n\n\n\n\n\nL’héritage permet à une classe de hériter des attributs et méthodes d’une autre classe.\n\n\n\nEn Python, une classe peut hériter d’une autre classe, ce qui lui permet de reprendre ses attributs et méthodes.\n\n\nclass VehiculeElectrique(Voiture):\n    def __init__(self, marque, modele, autonomie):\n        super().__init__(marque, modele)\n        self.autonomie = autonomie\n\n    def afficher_autonomie(self):\n        print(f\"Autonomie: {self.autonomie} km\")\n\ntesla = VehiculeElectrique(\"Tesla\", \"Model S\", 600)\ntesla.afficher_info()        # Hérité de la classe Voiture\ntesla.afficher_autonomie()   # Spécifique à VehiculeElectrique\n\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction super() est utilisée pour appeler le constructeur de la classe parente.\n\n\n\n\n\nLe polymorphisme permet d’utiliser des objets de différentes classes de manière interchangeable.\n\n\n\nLe polymorphisme se manifeste lorsqu’une interface commune (comme une méthode) est implémentée de différentes manières par différentes classes.\n\n\ndef afficher_details_vehicule(vehicule):\n    vehicule.afficher_info()\n    if isinstance(vehicule, VehiculeElectrique):\n        vehicule.afficher_autonomie()\n\nafficher_details_vehicule(ma_voiture)      # Affiche les détails de la voiture\nafficher_details_vehicule(tesla)           # Affiche les détails du véhicule électrique\n\nMarque: Toyota, Modèle: Corolla\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction isinstance() est utilisée pour vérifier le type d’une instance.\n\n\n\n\n\n\nL’encapsulation et l’abstraction sont des principes de POO essentiels pour créer des modèles financiers robustes et flexibles.\n\n\n\nL’encapsulation consiste à regrouper les données et les méthodes qui les manipulent, et à restreindre l’accès direct aux données d’une classe. Cela est crucial pour la sécurité et l’intégrité des modèles financiers.\n\n\nclass Obligation:\n    def __init__(self, principal, taux_interet, maturite):\n        self.__principal = principal          # Encapsulé (attribut privé)\n        self.__taux_interet = taux_interet    # Encapsulé\n        self.__maturite = maturite            # Encapsulé\n\n    def calculer_prix(self):\n        # Méthode pour calculer le prix de l'obligation\n        # Utilise les attributs encapsulés\n        return self.__principal * (1 + self.__taux_interet) ** self.__maturite\n\nobligation = Obligation(1000, 0.05, 5)\nprint(obligation.calculer_prix())  # Affiche le prix calculé\n\n1276.2815625000003\n\n\n\nLes attributs précédés de __ sont considérés comme privés et ne sont pas accessibles directement en dehors de la classe.\n\n\n\n\n\nL’abstraction permet de créer des modèles simplifiés en ne retenant que les détails pertinents. Elle est utile pour modéliser des produits financiers complexes.\n\nPar exemple, une classe abstraite ProduitFinancier peut définir une interface pour le calcul du prix, tandis que les sous-classes concrétisent ces calculs pour différents produits.\n\n\n\n\n\n\nUtilisons la POO pour modéliser un scénario financier concret, comme le pricing d’obligations.\n\n\n\nImaginons que nous devons calculer le prix de différentes obligations avec des caractéristiques variées. Nous pouvons utiliser des classes pour modéliser ces obligations et effectuer les calculs nécessaires.\n\n\nclass Obligation:\n    def __init__(self, nominal, coupon, maturite):\n        self.nominal = nominal\n        self.coupon = coupon\n        self.maturite = maturite\n\n    def prix(self, taux_marche):\n        cash_flows = [self.coupon * self.nominal for _ in range(self.maturite)]\n        cash_flows[-1] += self.nominal\n        return sum(cf / (1 + taux_marche)**t for t, cf in enumerate(cash_flows, 1))\n\n# Exemple d'utilisation\nobligation1 = Obligation(1000, 0.05, 3)\nobligation2 = Obligation(1000, 0.06, 5)\nprint(\"Prix Obligation 1:\", obligation1.prix(0.04))\nprint(\"Prix Obligation 2:\", obligation2.prix(0.04))\n\nPrix Obligation 1: 1027.7509103322711\nPrix Obligation 2: 1089.036446620324\n\n\n\nDans cet exemple, chaque instance de Obligation représente une obligation distincte. La méthode prix calcule le prix actuel de l’obligation en actualisant ses flux de trésorerie futurs au taux du marché.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.1-introduction-à-la-poo-et-son-application-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.1-introduction-à-la-poo-et-son-application-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La Programmation Orientée Objet (POO) est un paradigme de programmation basé sur le concept d’« objets », qui peuvent contenir des données sous forme d’attributs, et du code sous forme de méthodes. En Python, la POO offre une approche flexible et puissante pour structurer et concevoir des applications.\n\n\n\nEncapsulation: Regroupe les données et les méthodes qui manipulent ces données au sein d’une unité appelée « classe ». Cela permet de cacher la représentation interne des données à l’extérieur de la classe, une pratique connue sous le nom de “cachette d’information”.\nHéritage: Permet à une classe de hériter des attributs et méthodes d’une autre classe. Cela facilite la réutilisation du code et la création d’une hiérarchie de classes.\nPolymorphisme: Signifie que des fonctions ou des méthodes peuvent être utilisées avec des objets de différents types. Il s’appuie sur l’héritage pour fournir cette flexibilité.\n\n\n\n\n\nPython est un langage multi-paradigme qui supporte à la fois la programmation procédurale et la POO. Ce qui le rend particulièrement puissant est sa capacité à offrir une syntaxe claire et une grande flexibilité dans la conception de classes et d’objets.\nContrairement à d’autres langages où les objets et les types de base sont distincts, en Python, tout est un objet. Cela inclut les types de base comme les nombres, les chaînes et les listes. Cette uniformité rend le langage cohérent et élégant.\n\n\n  a = 10\n  print(a.__class__)  # Affiche &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;\n\n\n\nEn Python, même les fonctions sont des objets. Cela permet des concepts avancés comme les décorateurs et les fonctions de première classe.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.2-lintérêt-et-les-avantages-de-la-poo-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.2-lintérêt-et-les-avantages-de-la-poo-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "La POO offre plusieurs avantages qui la rendent idéale pour un large éventail d’applications de programmation.\n\n\n\nModularité et Réutilisation du Code**: La POO en Python permet de créer des modules et des bibliothèques réutilisables. Les classes peuvent être conçues comme des composants réutilisables dans différents projets.\nSimplicité et Clarté: La structure de classe en POO permet une organisation claire du code. Cela facilite la maintenance et la mise à jour des applications.\nExtensibilité: La capacité à étendre les classes existantes via l’héritage rend le code adaptable et évolutif.\nAdaptabilité à de Multiples Domaines: De la conception de jeux à l’intelligence artificielle et au développement web, la POO est utilisée dans de nombreux domaines, reflétant sa polyvalence et son adaptabilité.\n\n\n\n\n\nPython ajoute une touche de flexibilité et de simplicité à la POO, rendant l’apprentissage et l’utilisation de ce paradigme plus accessibles par rapport à des langages plus stricts et formels.\nLes mécanismes avancés de Python, tels que le duck typing et les méthodes magiques, ouvrent des possibilités de conception et d’implémentation qui vont au-delà des approches traditionnelles de la POO.\nL’écosystème riche de Python en frameworks et bibliothèques orientés objet (comme Django pour le web ou Pandas pour la manipulation de données) montre l’efficacité et la popularité de la POO dans la communauté Python.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.3-définition-et-utilisation-des-classes-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.3-définition-et-utilisation-des-classes-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Les classes sont au cœur de la POO en Python. Elles servent de modèle pour créer des objets (instances).\n\n\n\nUne classe en Python est définie en utilisant le mot-clé class. Elle peut contenir des attributs (variables) et des méthodes (fonctions).\n\n\nclass Voiture:\n    def __init__(self, marque, modele):\n        self.marque = marque\n        self.modele = modele\n\n    def afficher_info(self):\n        print(f\"Marque: {self.marque}, Modèle: {self.modele}\")\n\n# Création d'une instance de Voiture\nma_voiture = Voiture(\"Toyota\", \"Corolla\")\nma_voiture.afficher_info()  # Affiche \"Marque: Toyota, Modèle: Corolla\"\n\nMarque: Toyota, Modèle: Corolla\n\n\n\nLa méthode __init__ est un constructeur. Elle est appelée lors de la création d’une nouvelle instance de la classe.\n\n\n\n\n\nAprès avoir défini une classe, vous pouvez créer des instances (objets) et accéder à leurs attributs et méthodes.\n\n\n# Création d'une autre instance de Voiture\nautre_voiture = Voiture(\"Honda\", \"Civic\")\nautre_voiture.afficher_info()  # Affiche \"Marque: Honda, Modèle: Civic\"\n\nMarque: Honda, Modèle: Civic",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.4-héritage-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.4-héritage-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "L’héritage permet à une classe de hériter des attributs et méthodes d’une autre classe.\n\n\n\nEn Python, une classe peut hériter d’une autre classe, ce qui lui permet de reprendre ses attributs et méthodes.\n\n\nclass VehiculeElectrique(Voiture):\n    def __init__(self, marque, modele, autonomie):\n        super().__init__(marque, modele)\n        self.autonomie = autonomie\n\n    def afficher_autonomie(self):\n        print(f\"Autonomie: {self.autonomie} km\")\n\ntesla = VehiculeElectrique(\"Tesla\", \"Model S\", 600)\ntesla.afficher_info()        # Hérité de la classe Voiture\ntesla.afficher_autonomie()   # Spécifique à VehiculeElectrique\n\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction super() est utilisée pour appeler le constructeur de la classe parente.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.5-polymorphisme-en-python",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.5-polymorphisme-en-python",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Le polymorphisme permet d’utiliser des objets de différentes classes de manière interchangeable.\n\n\n\nLe polymorphisme se manifeste lorsqu’une interface commune (comme une méthode) est implémentée de différentes manières par différentes classes.\n\n\ndef afficher_details_vehicule(vehicule):\n    vehicule.afficher_info()\n    if isinstance(vehicule, VehiculeElectrique):\n        vehicule.afficher_autonomie()\n\nafficher_details_vehicule(ma_voiture)      # Affiche les détails de la voiture\nafficher_details_vehicule(tesla)           # Affiche les détails du véhicule électrique\n\nMarque: Toyota, Modèle: Corolla\nMarque: Tesla, Modèle: Model S\nAutonomie: 600 km\n\n\n\nLa fonction isinstance() est utilisée pour vérifier le type d’une instance.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.6-encapsulation-et-abstraction-dans-la-modélisation-financière",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.6-encapsulation-et-abstraction-dans-la-modélisation-financière",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "L’encapsulation et l’abstraction sont des principes de POO essentiels pour créer des modèles financiers robustes et flexibles.\n\n\n\nL’encapsulation consiste à regrouper les données et les méthodes qui les manipulent, et à restreindre l’accès direct aux données d’une classe. Cela est crucial pour la sécurité et l’intégrité des modèles financiers.\n\n\nclass Obligation:\n    def __init__(self, principal, taux_interet, maturite):\n        self.__principal = principal          # Encapsulé (attribut privé)\n        self.__taux_interet = taux_interet    # Encapsulé\n        self.__maturite = maturite            # Encapsulé\n\n    def calculer_prix(self):\n        # Méthode pour calculer le prix de l'obligation\n        # Utilise les attributs encapsulés\n        return self.__principal * (1 + self.__taux_interet) ** self.__maturite\n\nobligation = Obligation(1000, 0.05, 5)\nprint(obligation.calculer_prix())  # Affiche le prix calculé\n\n1276.2815625000003\n\n\n\nLes attributs précédés de __ sont considérés comme privés et ne sont pas accessibles directement en dehors de la classe.\n\n\n\n\n\nL’abstraction permet de créer des modèles simplifiés en ne retenant que les détails pertinents. Elle est utile pour modéliser des produits financiers complexes.\n\nPar exemple, une classe abstraite ProduitFinancier peut définir une interface pour le calcul du prix, tandis que les sous-classes concrétisent ces calculs pour différents produits.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.7-exemple-pratique-en-finance-de-marché",
    "href": "content/Cours_2/3-IntroducingPOOConcept.html#section-3.7-exemple-pratique-en-finance-de-marché",
    "title": "Introduction à la POO en Python",
    "section": "",
    "text": "Utilisons la POO pour modéliser un scénario financier concret, comme le pricing d’obligations.\n\n\n\nImaginons que nous devons calculer le prix de différentes obligations avec des caractéristiques variées. Nous pouvons utiliser des classes pour modéliser ces obligations et effectuer les calculs nécessaires.\n\n\nclass Obligation:\n    def __init__(self, nominal, coupon, maturite):\n        self.nominal = nominal\n        self.coupon = coupon\n        self.maturite = maturite\n\n    def prix(self, taux_marche):\n        cash_flows = [self.coupon * self.nominal for _ in range(self.maturite)]\n        cash_flows[-1] += self.nominal\n        return sum(cf / (1 + taux_marche)**t for t, cf in enumerate(cash_flows, 1))\n\n# Exemple d'utilisation\nobligation1 = Obligation(1000, 0.05, 3)\nobligation2 = Obligation(1000, 0.06, 5)\nprint(\"Prix Obligation 1:\", obligation1.prix(0.04))\nprint(\"Prix Obligation 2:\", obligation2.prix(0.04))\n\nPrix Obligation 1: 1027.7509103322711\nPrix Obligation 2: 1089.036446620324\n\n\n\nDans cet exemple, chaque instance de Obligation représente une obligation distincte. La méthode prix calcule le prix actuel de l’obligation en actualisant ses flux de trésorerie futurs au taux du marché.",
    "crumbs": [
      "Introduction à la POO en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html",
    "href": "content/Cours_2/2-FonctionsEtModules.html",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les fonctions en Python sont des blocs de code réutilisables conçus pour effectuer une tâche spécifique. La création de fonctions bien définies est un élément clé de la programmation efficace et lisible.\n\n\n\nPour définir une fonction en Python, utilisez le mot-clé def, suivi du nom de la fonction, des parenthèses et des paramètres.\n\n\n  def ma_fonction(param1, param2):\n      # Corps de la fonction\n      return param1 + param2\n\n\n\n\n\nAppelez une fonction en utilisant son nom suivi des arguments entre parenthèses.\n\n\n    resultat = ma_fonction(5, 3)  # Appel de la fonction avec 5 et 3 comme arguments\n\n\n\n\n\n\n\n\nLes fonctions peuvent avoir des arguments par défaut, qui prennent une valeur spécifiée si aucun argument n’est fourni.\nLes arguments nommés permettent de passer des arguments dans n’importe quel ordre en spécifiant leur nom.\n\n\n    def saluer(nom, message=\"Bonjour\"):\n        return f\"{message}, {nom}\"\n\n    saluer(\"Alice\")             # Utilise le message par défaut\n    saluer(\"Bob\", \"Salut\")      # Utilise un message personnalisé\n    saluer(nom=\"Carol\", message=\"Bienvenue\")  # Arguments nommés\n\n'Bienvenue, Carol'\n\n\n\n\n\n\nLes variables définies dans une fonction ont une portée locale à cette fonction. Les variables définies en dehors ont une portée globale.\n\n\n    x = \"global\"\n\n    def exemple_scope():\n        y = \"local\"\n        print(x)  # Accède à la variable globale x\n        print(y)  # Accède à la variable locale y\n\n    exemple_scope()\n\nglobal\nlocal\n\n\n\n\n\n\nLes modules et packages en Python permettent de structurer et d’organiser le code de manière logique et réutilisable.\n\n\n\nUn module est un fichier Python contenant des fonctions, des classes et des variables, ainsi que du code exécutable.\n\n\n  import math\n  print(math.sqrt(16))  # Utilise la fonction s²qrt du module math\n\n4.0\n\n\n\n\n\n\nUn package est une collection de modules. Il contient un fichier spécial nommé __init__.py.\n\nPour créer un package, créez un répertoire portant le nom du package, puis ajoutez-y des modules et un fichier __init__.py.\nImportez des modules spécifiques du package :\n\n\n    from monpackage import monmodule\n\n\n\n\nPython propose des fonctions intégrées et des expressions lambda pour effectuer des opérations fonctionnelles courantes comme le mappage, le filtrage et la réduction des données.\n\n\n\nLes expressions lambda sont de petites fonctions anonymes.\n\n\n  doubler = lambda x: x * 2\n  print(doubler(5))  # Affiche 10\n\n10\n\n\n\n\n\n\nmap() applique une fonction à chaque élément d’une séquence.\nfilter() crée une liste de tous les éléments pour lesquels une fonction renvoie True.\nreduce() applique une fonction cumulativement aux éléments d’une séquence, de gauche à droite, pour réduire la séquence à une seule valeur.\n\n  # Exemple d'utilisation de map et filter\n  nombres = [1, 2, 3, 4, 5]\n\n  carres = list(map(lambda x: x2, nombres))\n  pairs = list(filter(lambda x: x % 2 == 0, carres))\n\n  # Utilisation de reduce\n  from functools import reduce\n  somme = reduce(lambda x, y: x + y, nombres)\n\n\n\n\n\nEn Python, *args et kwargs permettent de gérer de manière flexible un nombre variable d’arguments dans les fonctions.\n\n\n\n*args est utilisé pour passer une liste variable d’arguments non-nommés à une fonction. Les arguments sont accessibles comme une tuple.\n\n\ndef fonction_avec_args(*args):\n    for arg in args:\n        print(arg)\n\nfonction_avec_args('Python', 'est', 'génial')\n\nPython\nest\ngénial\n\n\n\n\n\n\nkwargs permet de passer une liste variable d’arguments nommés. Les arguments sont accessibles comme un dictionnaire.\n\n\ndef fonction_avec_kwargs(**kwargs):\n    for cle, valeur in kwargs.items():\n        print(f\"{cle}: {valeur}\")\n\nfonction_avec_kwargs(premier='Python', deuxieme='est', troisieme='génial')\n\npremier: Python\ndeuxieme: est\ntroisieme: génial\n\n\n\n\n\n\nLes expressions lambda en Python offrent un moyen compact de créer des fonctions anonymes pour des opérations simples.\n\n\n\nLes expressions lambda sont souvent utilisées pour des fonctions courtes et simples, comme des arguments pour des fonctions comme map, filter, et sorted.\n\n\n# Tri d'une liste de tuples basé sur le deuxième élément\nliste = [(1, 'd'), (2, 'b'), (3, 'c'), (4, 'a')]\nliste.sort(key=lambda x: x[1])\nprint(liste)  # Affiche [(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]\n\n[(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]\n\n\n\n\n\n\nL’organisation des projets en modules et packages est essentielle pour maintenir une structure claire et une maintenance facile du code.\n\n\n\nUn module en Python est simplement un fichier .py. Pour utiliser un module, utilisez import nom_du_module.\nUn package est un répertoire contenant un fichier spécial __init__.py et un ou plusieurs modules.\n\n\n\n\n\nUtilisez import pour accéder aux fonctions, classes et variables d’un module ou package. Les alias peuvent être utilisés pour simplifier les noms.\n\nimport mon_module as mm\nfrom mon_package import mon_module\n\n\n\n\nLes packages permettent de regrouper des modules logiquement liés, facilitant ainsi la réutilisation et la distribution du code.\nIls aident à éviter les conflits de noms et rendent le code plus organisable et maintenable.\n\n\n\n\n\nLa compréhension de la façon dont Python importe des modules et gère les chemins d’accès aux packages est essentielle pour éviter des erreurs courantes, notamment les dépendances circulaires.\n\n\n\nLorsque vous importez un module, Python recherche d’abord dans le répertoire courant, puis dans les répertoires listés dans la variable d’environnement PYTHONPATH, et enfin dans les emplacements par défaut.\n\n\nimport sys\nprint(sys.path)  # Affiche les chemins où Python recherche les modules\n\n['/home/remi/PhDWork/Introduction-Python/content/Cours_2', '/home/remi/.pyenv/versions/3.11.6/lib/python311.zip', '/home/remi/.pyenv/versions/3.11.6/lib/python3.11', '/home/remi/.pyenv/versions/3.11.6/lib/python3.11/lib-dynload', '', '/home/remi/.local/lib/python3.11/site-packages', '/home/remi/.pyenv/versions/3.11.6/lib/python3.11/site-packages']\n\n\n\nPYTHONPATH est similaire à PATH vu précédemment. Il s’agit d’une liste de répertoires dans lesquels Python cherche des modules à importer.\n\n\n\n\n\nLorsque vous utilisez from X import Y, Python exécute tout le code à la racine du module X. Cela signifie que tout code au niveau du module, y compris les importations, sera exécuté lors de l’importation.\n\n# Dans le module X.py\nprint(\"Module X importé\")\ndef fonction_Y():\n    print(\"Fonction Y exécutée\")\n\n# Dans un autre module\nfrom X import fonction_Y  # Affiche \"Module X importé\" lors de l'exécution\n\n\n\n\nUne dépendance circulaire se produit lorsque deux modules s’importent mutuellement. Cela peut entraîner des erreurs d’exécution car l’ordre d’importation peut affecter la disponibilité des fonctions et des classes.\n\nPour éviter cela, structurez votre code pour minimiser les dépendances inter-modules.\nConsidérez l’utilisation de l’importation à l’intérieur des fonctions ou des classes si l’importation est nécessaire uniquement dans une portée locale.\n\n\n\n\n\n\nÉvitez les importations génériques (from module import *) car elles peuvent polluer l’espace de noms.\nUtilisez des alias pour clarifier l’origine des modules ou pour éviter des conflits de noms.\n\n\nimport numpy as np  # Utilisation d'un alias pour numpy\n\n\n\n\n\nComprendre les subtilités des importations en Python, y compris leur coût et les conventions d’abréviation, peut améliorer la lisibilité et l’efficacité du code.\n\n\n\nEn Python, importer plusieurs fois le même module ne pénalise pas les performances de manière significative. Lorsqu’un module est importé pour la première fois, il est compilé en bytecode et stocké en mémoire. Les importations suivantes du même module font simplement référence à la version en mémoire.\n\n\nimport math  # Le module est chargé en mémoire\nimport math  # Référence le module déjà chargé, sans coût supplémentaire\n\n\nCela signifie que vous pouvez importer le même module dans différents fichiers ou plusieurs fois dans le même fichier sans vous soucier d’un impact négatif sur les performances.\n\n\n\n\n\nIl existe des conventions d’abréviations pour certains modules fréquemment utilisés en Python. Utiliser ces abréviations peut rendre votre code plus lisible et conforme aux standards de la communauté.\n\n\n\nModule\nAbréviation Standard\n\n\n\n\npandas\npd\n\n\nnumpy\nnp\n\n\nmatplotlib.pyplot\nplt\n\n\nseaborn\nsns\n\n\ntensorflow\ntf\n\n\nscikit-learn\nskl\n\n\nscipy\nsp\n\n\nos\nos (généralement utilisé tel quel)\n\n\nsys\nsys (généralement utilisé tel quel)\n\n\n\nCes abréviations sont largement reconnues et leur utilisation est recommandée pour maintenir la cohérence avec les pratiques de la communauté Python.\n\n\n\n\n\nEn plus d’utiliser des abréviations standard, il est également conseillé de regrouper les importations en haut du fichier.\nSéparez les importations standard, tierces et locales par des lignes vides pour une meilleure lisibilité.\n\n  # Importations standard\nimport os\nimport sys\n\n# Importations tierces\nimport numpy as np\nimport pandas as pd\n\n# Importations locales\nfrom mon_module import ma_fonction\n```",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.1-définition-et-appel-de-fonctions",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.1-définition-et-appel-de-fonctions",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les fonctions en Python sont des blocs de code réutilisables conçus pour effectuer une tâche spécifique. La création de fonctions bien définies est un élément clé de la programmation efficace et lisible.\n\n\n\nPour définir une fonction en Python, utilisez le mot-clé def, suivi du nom de la fonction, des parenthèses et des paramètres.\n\n\n  def ma_fonction(param1, param2):\n      # Corps de la fonction\n      return param1 + param2\n\n\n\n\n\nAppelez une fonction en utilisant son nom suivi des arguments entre parenthèses.\n\n\n    resultat = ma_fonction(5, 3)  # Appel de la fonction avec 5 et 3 comme arguments\n\n\n\n\n\n\n\n\nLes fonctions peuvent avoir des arguments par défaut, qui prennent une valeur spécifiée si aucun argument n’est fourni.\nLes arguments nommés permettent de passer des arguments dans n’importe quel ordre en spécifiant leur nom.\n\n\n    def saluer(nom, message=\"Bonjour\"):\n        return f\"{message}, {nom}\"\n\n    saluer(\"Alice\")             # Utilise le message par défaut\n    saluer(\"Bob\", \"Salut\")      # Utilise un message personnalisé\n    saluer(nom=\"Carol\", message=\"Bienvenue\")  # Arguments nommés\n\n'Bienvenue, Carol'\n\n\n\n\n\n\nLes variables définies dans une fonction ont une portée locale à cette fonction. Les variables définies en dehors ont une portée globale.\n\n\n    x = \"global\"\n\n    def exemple_scope():\n        y = \"local\"\n        print(x)  # Accède à la variable globale x\n        print(y)  # Accède à la variable locale y\n\n    exemple_scope()\n\nglobal\nlocal",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.2-modules-et-packages",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.2-modules-et-packages",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les modules et packages en Python permettent de structurer et d’organiser le code de manière logique et réutilisable.\n\n\n\nUn module est un fichier Python contenant des fonctions, des classes et des variables, ainsi que du code exécutable.\n\n\n  import math\n  print(math.sqrt(16))  # Utilise la fonction s²qrt du module math\n\n4.0\n\n\n\n\n\n\nUn package est une collection de modules. Il contient un fichier spécial nommé __init__.py.\n\nPour créer un package, créez un répertoire portant le nom du package, puis ajoutez-y des modules et un fichier __init__.py.\nImportez des modules spécifiques du package :\n\n\n    from monpackage import monmodule",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.3-lambda-map-filter-et-reduce",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.3-lambda-map-filter-et-reduce",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Python propose des fonctions intégrées et des expressions lambda pour effectuer des opérations fonctionnelles courantes comme le mappage, le filtrage et la réduction des données.\n\n\n\nLes expressions lambda sont de petites fonctions anonymes.\n\n\n  doubler = lambda x: x * 2\n  print(doubler(5))  # Affiche 10\n\n10\n\n\n\n\n\n\nmap() applique une fonction à chaque élément d’une séquence.\nfilter() crée une liste de tous les éléments pour lesquels une fonction renvoie True.\nreduce() applique une fonction cumulativement aux éléments d’une séquence, de gauche à droite, pour réduire la séquence à une seule valeur.\n\n  # Exemple d'utilisation de map et filter\n  nombres = [1, 2, 3, 4, 5]\n\n  carres = list(map(lambda x: x2, nombres))\n  pairs = list(filter(lambda x: x % 2 == 0, carres))\n\n  # Utilisation de reduce\n  from functools import reduce\n  somme = reduce(lambda x, y: x + y, nombres)",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.7-manipulation-des-arguments-de-fonction-avec-args-et-kwargs",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.7-manipulation-des-arguments-de-fonction-avec-args-et-kwargs",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "En Python, *args et kwargs permettent de gérer de manière flexible un nombre variable d’arguments dans les fonctions.\n\n\n\n*args est utilisé pour passer une liste variable d’arguments non-nommés à une fonction. Les arguments sont accessibles comme une tuple.\n\n\ndef fonction_avec_args(*args):\n    for arg in args:\n        print(arg)\n\nfonction_avec_args('Python', 'est', 'génial')\n\nPython\nest\ngénial\n\n\n\n\n\n\nkwargs permet de passer une liste variable d’arguments nommés. Les arguments sont accessibles comme un dictionnaire.\n\n\ndef fonction_avec_kwargs(**kwargs):\n    for cle, valeur in kwargs.items():\n        print(f\"{cle}: {valeur}\")\n\nfonction_avec_kwargs(premier='Python', deuxieme='est', troisieme='génial')\n\npremier: Python\ndeuxieme: est\ntroisieme: génial",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.8-expressions-lambda-pour-des-fonctions-anonymes",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.8-expressions-lambda-pour-des-fonctions-anonymes",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Les expressions lambda en Python offrent un moyen compact de créer des fonctions anonymes pour des opérations simples.\n\n\n\nLes expressions lambda sont souvent utilisées pour des fonctions courtes et simples, comme des arguments pour des fonctions comme map, filter, et sorted.\n\n\n# Tri d'une liste de tuples basé sur le deuxième élément\nliste = [(1, 'd'), (2, 'b'), (3, 'c'), (4, 'a')]\nliste.sort(key=lambda x: x[1])\nprint(liste)  # Affiche [(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]\n\n[(4, 'a'), (2, 'b'), (3, 'c'), (1, 'd')]",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.9-modules-et-packages-pour-structurer-les-projets",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.9-modules-et-packages-pour-structurer-les-projets",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "L’organisation des projets en modules et packages est essentielle pour maintenir une structure claire et une maintenance facile du code.\n\n\n\nUn module en Python est simplement un fichier .py. Pour utiliser un module, utilisez import nom_du_module.\nUn package est un répertoire contenant un fichier spécial __init__.py et un ou plusieurs modules.\n\n\n\n\n\nUtilisez import pour accéder aux fonctions, classes et variables d’un module ou package. Les alias peuvent être utilisés pour simplifier les noms.\n\nimport mon_module as mm\nfrom mon_package import mon_module\n\n\n\n\nLes packages permettent de regrouper des modules logiquement liés, facilitant ainsi la réutilisation et la distribution du code.\nIls aident à éviter les conflits de noms et rendent le code plus organisable et maintenable.",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.10-mécanisme-dimportation-en-python-et-gestion-des-dépendances",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.10-mécanisme-dimportation-en-python-et-gestion-des-dépendances",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "La compréhension de la façon dont Python importe des modules et gère les chemins d’accès aux packages est essentielle pour éviter des erreurs courantes, notamment les dépendances circulaires.\n\n\n\nLorsque vous importez un module, Python recherche d’abord dans le répertoire courant, puis dans les répertoires listés dans la variable d’environnement PYTHONPATH, et enfin dans les emplacements par défaut.\n\n\nimport sys\nprint(sys.path)  # Affiche les chemins où Python recherche les modules\n\n['/home/remi/PhDWork/Introduction-Python/content/Cours_2', '/home/remi/.pyenv/versions/3.11.6/lib/python311.zip', '/home/remi/.pyenv/versions/3.11.6/lib/python3.11', '/home/remi/.pyenv/versions/3.11.6/lib/python3.11/lib-dynload', '', '/home/remi/.local/lib/python3.11/site-packages', '/home/remi/.pyenv/versions/3.11.6/lib/python3.11/site-packages']\n\n\n\nPYTHONPATH est similaire à PATH vu précédemment. Il s’agit d’une liste de répertoires dans lesquels Python cherche des modules à importer.\n\n\n\n\n\nLorsque vous utilisez from X import Y, Python exécute tout le code à la racine du module X. Cela signifie que tout code au niveau du module, y compris les importations, sera exécuté lors de l’importation.\n\n# Dans le module X.py\nprint(\"Module X importé\")\ndef fonction_Y():\n    print(\"Fonction Y exécutée\")\n\n# Dans un autre module\nfrom X import fonction_Y  # Affiche \"Module X importé\" lors de l'exécution\n\n\n\n\nUne dépendance circulaire se produit lorsque deux modules s’importent mutuellement. Cela peut entraîner des erreurs d’exécution car l’ordre d’importation peut affecter la disponibilité des fonctions et des classes.\n\nPour éviter cela, structurez votre code pour minimiser les dépendances inter-modules.\nConsidérez l’utilisation de l’importation à l’intérieur des fonctions ou des classes si l’importation est nécessaire uniquement dans une portée locale.\n\n\n\n\n\n\nÉvitez les importations génériques (from module import *) car elles peuvent polluer l’espace de noms.\nUtilisez des alias pour clarifier l’origine des modules ou pour éviter des conflits de noms.\n\n\nimport numpy as np  # Utilisation d'un alias pour numpy",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_2/2-FonctionsEtModules.html#section-2.11-coût-des-importations-répétées-et-abréviations-standard-en-python",
    "href": "content/Cours_2/2-FonctionsEtModules.html#section-2.11-coût-des-importations-répétées-et-abréviations-standard-en-python",
    "title": "Fonctions et Modules",
    "section": "",
    "text": "Comprendre les subtilités des importations en Python, y compris leur coût et les conventions d’abréviation, peut améliorer la lisibilité et l’efficacité du code.\n\n\n\nEn Python, importer plusieurs fois le même module ne pénalise pas les performances de manière significative. Lorsqu’un module est importé pour la première fois, il est compilé en bytecode et stocké en mémoire. Les importations suivantes du même module font simplement référence à la version en mémoire.\n\n\nimport math  # Le module est chargé en mémoire\nimport math  # Référence le module déjà chargé, sans coût supplémentaire\n\n\nCela signifie que vous pouvez importer le même module dans différents fichiers ou plusieurs fois dans le même fichier sans vous soucier d’un impact négatif sur les performances.\n\n\n\n\n\nIl existe des conventions d’abréviations pour certains modules fréquemment utilisés en Python. Utiliser ces abréviations peut rendre votre code plus lisible et conforme aux standards de la communauté.\n\n\n\nModule\nAbréviation Standard\n\n\n\n\npandas\npd\n\n\nnumpy\nnp\n\n\nmatplotlib.pyplot\nplt\n\n\nseaborn\nsns\n\n\ntensorflow\ntf\n\n\nscikit-learn\nskl\n\n\nscipy\nsp\n\n\nos\nos (généralement utilisé tel quel)\n\n\nsys\nsys (généralement utilisé tel quel)\n\n\n\nCes abréviations sont largement reconnues et leur utilisation est recommandée pour maintenir la cohérence avec les pratiques de la communauté Python.\n\n\n\n\n\nEn plus d’utiliser des abréviations standard, il est également conseillé de regrouper les importations en haut du fichier.\nSéparez les importations standard, tierces et locales par des lignes vides pour une meilleure lisibilité.\n\n  # Importations standard\nimport os\nimport sys\n\n# Importations tierces\nimport numpy as np\nimport pandas as pd\n\n# Importations locales\nfrom mon_module import ma_fonction\n```",
    "crumbs": [
      "Fonctions et Modules"
    ]
  },
  {
    "objectID": "content/Cours_5/3-patterndesign.html",
    "href": "content/Cours_5/3-patterndesign.html",
    "title": "POO - Les Design Pattern",
    "section": "",
    "text": "POO - Python Orienté Objet”\n\n\n\n\n\n Back to top",
    "crumbs": [
      "POO - Les Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_5/index.html",
    "href": "content/Cours_5/index.html",
    "title": "Concepts avancés",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL’arbre Syntaxique Abstrait ou AST\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPOO - Les Design Pattern\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPOO - Python Orienté Objet\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP-5\n\n\n\n\n\n\nRemi Genet\n\n\n2024-01-06\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html",
    "href": "content/Cours_1/3-ManyPythons.html",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Python, en tant que langage, existe sous différentes implémentations, chacune ayant des caractéristiques uniques adaptées à des besoins spécifiques. Voici quelques-unes des plus connues :\n\n\n\nDescription: C’est l’implémentation standard et la plus répandue de Python, écrite en C. CPython est souvent le choix par défaut pour le développement général en Python, bien qu’il soit limité par le Global Interpreter Lock (GIL).\nUtilisation: Idéal pour des applications générales, CPython est souvent utilisé pour le développement de logiciels et l’écriture de scripts.\nCaractéristiques: Il offre un bon équilibre entre performance et facilité d’utilisation et possède le plus grand nombre de bibliothèques tierces disponibles. Mais, comme vu dans la partie 1, c’est aussi une version qui repose actuellement sur le GIL.\n\n\n\n\n\nDescription: Jython est conçu pour la machine virtuelle Java (JVM), permettant l’intégration avec des environnements Java. Contrairement à CPython, Jython n’est pas restreint par le GIL, ce qui le rend plus adapté pour des applications nécessitant du multithreading.\nUtilisation: Elle permet aux développeurs d’utiliser des bibliothèques Java dans leurs programmes Python et vice-versa.\nCaractéristiques: Jython est particulièrement utile pour les applications nécessitant l’intégration de Python avec des environnements Java existants.\n\n\n\n\n\nDescription: IronPython est conçu pour être compatible avec le Common Language Runtime (CLR) de Microsoft .NET.\nUtilisation: Cette implémentation permet d’utiliser des bibliothèques .NET dans des programmes Python et d’intégrer Python dans des applications .NET.\nCaractéristiques: IronPython est idéal pour les développeurs travaillant dans l’écosystème .NET et souhaitant utiliser Python.\n\n\n\n\n\nDescription: PyPy est une implémentation de Python axée sur la performance et l’efficacité.\nUtilisation: Utilisée principalement lorsque la vitesse d’exécution est critique.\nCaractéristiques: PyPy utilise la compilation JIT (Just-In-Time) pour accélérer l’exécution des programmes Python. Cela peut entraîner des performances nettement meilleures, en particulier pour les programmes lourds en calcul. Attention toutefois à ne pas confondre vitesse et précipitations, cette versions repose toutefois toujours sur le GIL.\n\nChaque implémentation a ses avantages et peut être choisie selon les exigences spécifiques d’un projet. CPython reste l’implémentation dominante, mais les autres offrent des alternatives précieuses pour divers cas d’utilisation.\n\n\n\n\nUne question vient évidemment, pourquoi si PyPy offre des améliorations significatives en termes de performance, alors ne remplace-t-il pas CPython ? Bien que grâce à son approche JIT (Just-In-Time), il y a plusieurs raisons pour lesquelles il ne remplace pas complètement CPython :\n\n\n\nCPython: Étant l’implémentation de référence, CPython jouit d’une excellente compatibilité avec les extensions écrites en C. Ces extensions sont largement utilisées dans l’écosystème Python pour améliorer les performances et pour l’interaction avec des systèmes de bas niveau.\nPyPy: PyPy a des difficultés à intégrer certaines extensions C, notamment celles qui sont étroitement liées aux détails internes de CPython. Cette limitation peut poser des problèmes de compatibilité avec des bibliothèques importantes.\n\n\n\n\n\nCPython: Fournit des performances stables et prévisibles sur une large gamme d’applications. Pour des tâches spécifiques, en particulier celles qui impliquent beaucoup d’appels à des bibliothèques C, CPython peut être plus rapide.\nPyPy: Excellente performance pour les programmes Python purs, mais peut être moins performant dans des scénarios mixtes (Python et C) ou pour des scripts courts où l’overhead de JIT n’est pas amorti.\n\n\n\n\n\nPyPy: En raison de sa nature JIT, PyPy peut consommer plus de mémoire que CPython, en particulier pour des programmes de longue durée où le compilateur JIT génère et stocke de nombreuses versions optimisées de morceaux de code.\n\n\n\n\n\nCPython: Bénéficie d’une adoption massive et d’un support étendu de la part de la communauté Python. La plupart des développements, des tutoriels, et des supports se concentrent sur CPython.\nPyPy: Bien que gagnant en popularité, PyPy ne jouit pas du même niveau de support communautaire, et certains développeurs peuvent être moins familiers avec ses particularités.\n\n\n\n\n\nPyPy: Idéal pour des applications à longue durée d’exécution et intensives en calcul, où les avantages de JIT peuvent être pleinement exploités.\nCPython: Mieux adapté pour des applications générales, des scripts de courte durée, et des cas où la compatibilité avec l’écosystème existant est cruciale.\n\nEn résumé, bien que PyPy soit une alternative puissante à CPython, surtout en termes de vitesse d’exécution pour certains types de programmes, il ne peut pas remplacer complètement CPython en raison de problèmes de compatibilité, de différences de performance dans certains scénarios, et de la prévalence de CPython dans la communauté Python.\n\n\n\n\nBien que ces versions n’offrent pas toujours les même possibilités, le language reste strictement le même. Ainsi, dans certains cas où le besoin de performance est plus important, le fait de simplement changé d’interpreteur peut si il n’y a pas de conflit permettre de gagner de très nombreuses heures d’optimisation!\n\n\n\nNous avons vu la théorie, mais dans la pratique, très peu de développeur ont recompiler leur binaire de python. Mais, où trouver le code ? Le compilateur ? Y-a-t-il un interet à compiler Python soit même, dans la vie de tout les jours du développeur NON, l’intérêt reste marginale, mais pour autant: - Il y a un interet pédagogique - cela permet de comprendre comment compiler depuis la source (le code brut), installer un binaire etc… Ainsi cela peut vous permettre d’ajouter par exemple sans droit administrateur des versions de python de votre choix, par exemple à l’université ! - Cela peut permettre d’améliorer la performance de votre intepreteur, celui-ci étant alors compilé spécficiquement pour votre PC, les compilateurs proposant par exemple l’utilisation de la PGO (Profile Guided Optimization), où l’interet est d’améliorer le premier binaire créer après l’avoir fait tourner sur la machine sur une charge de travail représentative pour le rendre plus performant. - Profiter des améliorations de Python qui n’ont pas encore été intégré - possiblements des mois avant qu’ils ne soient disponibles\n\n\n\nCompiler Python à partir du code source permet de comprendre le processus sous-jacent et d’adapter l’installation aux besoins spécifiques. Les étapes sont détaillé dans le TP Constuire son python",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.1---les-différentes-saveurs-de-python-cpython-jython-ironpython-pypy",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.1---les-différentes-saveurs-de-python-cpython-jython-ironpython-pypy",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Python, en tant que langage, existe sous différentes implémentations, chacune ayant des caractéristiques uniques adaptées à des besoins spécifiques. Voici quelques-unes des plus connues :\n\n\n\nDescription: C’est l’implémentation standard et la plus répandue de Python, écrite en C. CPython est souvent le choix par défaut pour le développement général en Python, bien qu’il soit limité par le Global Interpreter Lock (GIL).\nUtilisation: Idéal pour des applications générales, CPython est souvent utilisé pour le développement de logiciels et l’écriture de scripts.\nCaractéristiques: Il offre un bon équilibre entre performance et facilité d’utilisation et possède le plus grand nombre de bibliothèques tierces disponibles. Mais, comme vu dans la partie 1, c’est aussi une version qui repose actuellement sur le GIL.\n\n\n\n\n\nDescription: Jython est conçu pour la machine virtuelle Java (JVM), permettant l’intégration avec des environnements Java. Contrairement à CPython, Jython n’est pas restreint par le GIL, ce qui le rend plus adapté pour des applications nécessitant du multithreading.\nUtilisation: Elle permet aux développeurs d’utiliser des bibliothèques Java dans leurs programmes Python et vice-versa.\nCaractéristiques: Jython est particulièrement utile pour les applications nécessitant l’intégration de Python avec des environnements Java existants.\n\n\n\n\n\nDescription: IronPython est conçu pour être compatible avec le Common Language Runtime (CLR) de Microsoft .NET.\nUtilisation: Cette implémentation permet d’utiliser des bibliothèques .NET dans des programmes Python et d’intégrer Python dans des applications .NET.\nCaractéristiques: IronPython est idéal pour les développeurs travaillant dans l’écosystème .NET et souhaitant utiliser Python.\n\n\n\n\n\nDescription: PyPy est une implémentation de Python axée sur la performance et l’efficacité.\nUtilisation: Utilisée principalement lorsque la vitesse d’exécution est critique.\nCaractéristiques: PyPy utilise la compilation JIT (Just-In-Time) pour accélérer l’exécution des programmes Python. Cela peut entraîner des performances nettement meilleures, en particulier pour les programmes lourds en calcul. Attention toutefois à ne pas confondre vitesse et précipitations, cette versions repose toutefois toujours sur le GIL.\n\nChaque implémentation a ses avantages et peut être choisie selon les exigences spécifiques d’un projet. CPython reste l’implémentation dominante, mais les autres offrent des alternatives précieuses pour divers cas d’utilisation.",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.2---pourquoi-pypy-ne-remplace-pas-complètement-cpython-différences-et-limitations",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.2---pourquoi-pypy-ne-remplace-pas-complètement-cpython-différences-et-limitations",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Une question vient évidemment, pourquoi si PyPy offre des améliorations significatives en termes de performance, alors ne remplace-t-il pas CPython ? Bien que grâce à son approche JIT (Just-In-Time), il y a plusieurs raisons pour lesquelles il ne remplace pas complètement CPython :\n\n\n\nCPython: Étant l’implémentation de référence, CPython jouit d’une excellente compatibilité avec les extensions écrites en C. Ces extensions sont largement utilisées dans l’écosystème Python pour améliorer les performances et pour l’interaction avec des systèmes de bas niveau.\nPyPy: PyPy a des difficultés à intégrer certaines extensions C, notamment celles qui sont étroitement liées aux détails internes de CPython. Cette limitation peut poser des problèmes de compatibilité avec des bibliothèques importantes.\n\n\n\n\n\nCPython: Fournit des performances stables et prévisibles sur une large gamme d’applications. Pour des tâches spécifiques, en particulier celles qui impliquent beaucoup d’appels à des bibliothèques C, CPython peut être plus rapide.\nPyPy: Excellente performance pour les programmes Python purs, mais peut être moins performant dans des scénarios mixtes (Python et C) ou pour des scripts courts où l’overhead de JIT n’est pas amorti.\n\n\n\n\n\nPyPy: En raison de sa nature JIT, PyPy peut consommer plus de mémoire que CPython, en particulier pour des programmes de longue durée où le compilateur JIT génère et stocke de nombreuses versions optimisées de morceaux de code.\n\n\n\n\n\nCPython: Bénéficie d’une adoption massive et d’un support étendu de la part de la communauté Python. La plupart des développements, des tutoriels, et des supports se concentrent sur CPython.\nPyPy: Bien que gagnant en popularité, PyPy ne jouit pas du même niveau de support communautaire, et certains développeurs peuvent être moins familiers avec ses particularités.\n\n\n\n\n\nPyPy: Idéal pour des applications à longue durée d’exécution et intensives en calcul, où les avantages de JIT peuvent être pleinement exploités.\nCPython: Mieux adapté pour des applications générales, des scripts de courte durée, et des cas où la compatibilité avec l’écosystème existant est cruciale.\n\nEn résumé, bien que PyPy soit une alternative puissante à CPython, surtout en termes de vitesse d’exécution pour certains types de programmes, il ne peut pas remplacer complètement CPython en raison de problèmes de compatibilité, de différences de performance dans certains scénarios, et de la prévalence de CPython dans la communauté Python.",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.3---et-pour-vous-comment-utiliser-cette-information",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.3---et-pour-vous-comment-utiliser-cette-information",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Bien que ces versions n’offrent pas toujours les même possibilités, le language reste strictement le même. Ainsi, dans certains cas où le besoin de performance est plus important, le fait de simplement changé d’interpreteur peut si il n’y a pas de conflit permettre de gagner de très nombreuses heures d’optimisation!",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.4---compiler-un-code-python-cloner-et-construire-cpython",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.4---compiler-un-code-python-cloner-et-construire-cpython",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Nous avons vu la théorie, mais dans la pratique, très peu de développeur ont recompiler leur binaire de python. Mais, où trouver le code ? Le compilateur ? Y-a-t-il un interet à compiler Python soit même, dans la vie de tout les jours du développeur NON, l’intérêt reste marginale, mais pour autant: - Il y a un interet pédagogique - cela permet de comprendre comment compiler depuis la source (le code brut), installer un binaire etc… Ainsi cela peut vous permettre d’ajouter par exemple sans droit administrateur des versions de python de votre choix, par exemple à l’université ! - Cela peut permettre d’améliorer la performance de votre intepreteur, celui-ci étant alors compilé spécficiquement pour votre PC, les compilateurs proposant par exemple l’utilisation de la PGO (Profile Guided Optimization), où l’interet est d’améliorer le premier binaire créer après l’avoir fait tourner sur la machine sur une charge de travail représentative pour le rendre plus performant. - Profiter des améliorations de Python qui n’ont pas encore été intégré - possiblements des mois avant qu’ils ne soient disponibles",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/3-ManyPythons.html#section-3.5---les-étapes",
    "href": "content/Cours_1/3-ManyPythons.html#section-3.5---les-étapes",
    "title": "Versions et Compilation de Python",
    "section": "",
    "text": "Compiler Python à partir du code source permet de comprendre le processus sous-jacent et d’adapter l’installation aux besoins spécifiques. Les étapes sont détaillé dans le TP Constuire son python",
    "crumbs": [
      "Versions et Compilation de Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html",
    "href": "content/Cours_1/2-Python_Execution.html",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’apprentissage de la programmation en Python ne nécessite pas de connaissances préalables en informatique, mais comprendre comment un programme est exécuté est essentiel. Cette compréhension aide à gérer les packages, à résoudre les problèmes de version et à collaborer efficacement.\nUn programme est une série d’instructions écrites dans un langage compréhensible par un ordinateur, connu sous le nom de langage machine, composé de séquences binaires (0 et 1). Pour traduire un langage de haut niveau en langage machine, un processus de compilation est nécessaire.\n\n\n\nLa compilation est le processus qui consiste à traduire le code source en code machine, mais cela ne fait pas “que” cela, il va aussi vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, le compilateur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur de compilation. C’est une erreur qui se produit avant l’exécution du programme.\nMais la compilation va également permettre d’optimiser le code source. C’est à dire qu’il va le rendre plus rapide à l’exécution. Durant cette phase le compilateur va, en fonction des options choisi par le développeur, optimiser le code source, en supprimant par exemple les lignes de code qui ne sont pas utilisées, en supprimant des boucles ou recursion, en réduisant le nombre de variables, en réduisant le nombre d’instructions, en réduisant le nombre de sauts, en réduisant le nombre d’opérations, en réduisant le nombre de tests, en réduisant le nombre de fonctions, en réduisant le nombre de paramètres, en réduisant le nombre de variables locales, …\nC’est optimisation prennent cependant du temps, et ne sont pas toutes sans risques et les erreurs de compilations peuvent être nombreuses sur des programmes complexes, et la compilations peut demander un temps considérable à chaque fois que l’on apporte une modification.\nMais en Python, il n’y a pas de compilation ! Magie ?\n\n\n\nPython, comme tout les programmes qui s’execute sur l’ordinateur, provient bien d’un code qui a été compilé à un moment. La différence vient du fait que c’est l’interpreteur qui a été compilé, et qui est un programme va être capable de lire le code python et de le transformé au fur et à mesure en code machine. C’est ce que l’on appelle l’interprétation. C’est un processus qui se fait en deux étapes.\nLa première étape est l’analyse lexicale. C’est à dire que l’interpreteur va lire le code source et le découper en morceaux. C’est ce que l’on appelle les tokens. Il va ensuite les analyser pour vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, l’interpreteur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur d’analyse lexicale. C’est une erreur qui se produit avant l’exécution du programme.\nEn Python, l’interpreteur va alors produire un Bytecode. C’est un code intermédiaire qui est plus proche du language machine que le code source, mais qui n’est pas encore du language machine. C’est ce que l’on appelle parfois la compilation, mais cette étape est presque instantanée. Toutefois l’interpreteur stocke quand même ce bytecode pour ne pas le recalculer à chaque fois, vous le verrez dans le dossier pycache de vos projets python, qui sera crée automatiquement dès que vous lancerez un code.\nL’interpréteur exécute ce bytecode, ce qui entraîne l’exécution des instructions écrites dans le fichier source. Ce processus diffère de celui des langages compilés comme C ou Java, où le code source est d’abord entièrement transformé en code machine avant l’exécution. En Python, la compilation en bytecode et l’exécution sont des étapes dynamiques, ce qui confère au langage sa flexibilité et sa facilité de débogage, mais aussi impacte sa vitesse d’exécution.\n\n\n\nL’exécution d’un programme Python implique l’utilisation d’un binaire compilé de l’interpréteur Python. Ce processus est fondamental pour comprendre comment Python fonctionne sous le capot.\n\nLe Binaire Compilé: Lorsqu’on installe Python, on télécharge en fait un binaire compilé de l’interpréteur Python, ou selon les cas l’ensemble des morceaux necessaire pour que notre machine le construise. Ce binaire est spécifique à chaque système d’exploitation et architecture matérielle. Par exemple, les binaires pour Windows diffèrent de ceux pour Linux ou MacOS, comme les binaires des Mac M1 sont très différents de ceux des Mac avec les anciens processeurs Intel.\nAvantages du Binaire Compilé: Le fait d’avoir un binaire compilé spécifique à chaque plateforme permet à Python d’être portable et facile à déployer. Les développeurs peuvent écrire un script Python et s’attendre à ce qu’il fonctionne de la même manière sur différentes machines, à condition que l’interpréteur Python approprié soit installé.\n\nCe mécanisme d’interprétation via un binaire compilé est une caractéristique clé de Python, contribuant à sa polyvalence et sa facilité d’utilisation dans divers environnements de développement.\nMais donc, qui produit se binaire ? Y’en a-t-il une seule implémentation ? Puis-je le compiler moi même ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.1---un-programme---comment-ca-marche",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.1---un-programme---comment-ca-marche",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’apprentissage de la programmation en Python ne nécessite pas de connaissances préalables en informatique, mais comprendre comment un programme est exécuté est essentiel. Cette compréhension aide à gérer les packages, à résoudre les problèmes de version et à collaborer efficacement.\nUn programme est une série d’instructions écrites dans un langage compréhensible par un ordinateur, connu sous le nom de langage machine, composé de séquences binaires (0 et 1). Pour traduire un langage de haut niveau en langage machine, un processus de compilation est nécessaire.",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.2---la-compilation",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.2---la-compilation",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "La compilation est le processus qui consiste à traduire le code source en code machine, mais cela ne fait pas “que” cela, il va aussi vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, le compilateur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur de compilation. C’est une erreur qui se produit avant l’exécution du programme.\nMais la compilation va également permettre d’optimiser le code source. C’est à dire qu’il va le rendre plus rapide à l’exécution. Durant cette phase le compilateur va, en fonction des options choisi par le développeur, optimiser le code source, en supprimant par exemple les lignes de code qui ne sont pas utilisées, en supprimant des boucles ou recursion, en réduisant le nombre de variables, en réduisant le nombre d’instructions, en réduisant le nombre de sauts, en réduisant le nombre d’opérations, en réduisant le nombre de tests, en réduisant le nombre de fonctions, en réduisant le nombre de paramètres, en réduisant le nombre de variables locales, …\nC’est optimisation prennent cependant du temps, et ne sont pas toutes sans risques et les erreurs de compilations peuvent être nombreuses sur des programmes complexes, et la compilations peut demander un temps considérable à chaque fois que l’on apporte une modification.\nMais en Python, il n’y a pas de compilation ! Magie ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.3---linterprétation",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.3---linterprétation",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "Python, comme tout les programmes qui s’execute sur l’ordinateur, provient bien d’un code qui a été compilé à un moment. La différence vient du fait que c’est l’interpreteur qui a été compilé, et qui est un programme va être capable de lire le code python et de le transformé au fur et à mesure en code machine. C’est ce que l’on appelle l’interprétation. C’est un processus qui se fait en deux étapes.\nLa première étape est l’analyse lexicale. C’est à dire que l’interpreteur va lire le code source et le découper en morceaux. C’est ce que l’on appelle les tokens. Il va ensuite les analyser pour vérifier que le code source est correcte. C’est à dire qu’il va vérifier que le code source est bien écrit dans le language que l’on a choisi. C’est ce que l’on appelle la syntaxe. Il va aussi vérifier que le code source est logique. C’est à dire qu’il va vérifier que le code source est bien écrit dans le bon ordre. C’est ce que l’on appelle la sémantique. Si le code source n’est pas correcte, l’interpreteur va nous renvoyer une erreur. C’est ce que l’on appelle une erreur d’analyse lexicale. C’est une erreur qui se produit avant l’exécution du programme.\nEn Python, l’interpreteur va alors produire un Bytecode. C’est un code intermédiaire qui est plus proche du language machine que le code source, mais qui n’est pas encore du language machine. C’est ce que l’on appelle parfois la compilation, mais cette étape est presque instantanée. Toutefois l’interpreteur stocke quand même ce bytecode pour ne pas le recalculer à chaque fois, vous le verrez dans le dossier pycache de vos projets python, qui sera crée automatiquement dès que vous lancerez un code.\nL’interpréteur exécute ce bytecode, ce qui entraîne l’exécution des instructions écrites dans le fichier source. Ce processus diffère de celui des langages compilés comme C ou Java, où le code source est d’abord entièrement transformé en code machine avant l’exécution. En Python, la compilation en bytecode et l’exécution sont des étapes dynamiques, ce qui confère au langage sa flexibilité et sa facilité de débogage, mais aussi impacte sa vitesse d’exécution.",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Python_Execution.html#section-2.4---binaire-compilé-et-interprétation-du-code-python",
    "href": "content/Cours_1/2-Python_Execution.html#section-2.4---binaire-compilé-et-interprétation-du-code-python",
    "title": "Exécution d’un Programme Python",
    "section": "",
    "text": "L’exécution d’un programme Python implique l’utilisation d’un binaire compilé de l’interpréteur Python. Ce processus est fondamental pour comprendre comment Python fonctionne sous le capot.\n\nLe Binaire Compilé: Lorsqu’on installe Python, on télécharge en fait un binaire compilé de l’interpréteur Python, ou selon les cas l’ensemble des morceaux necessaire pour que notre machine le construise. Ce binaire est spécifique à chaque système d’exploitation et architecture matérielle. Par exemple, les binaires pour Windows diffèrent de ceux pour Linux ou MacOS, comme les binaires des Mac M1 sont très différents de ceux des Mac avec les anciens processeurs Intel.\nAvantages du Binaire Compilé: Le fait d’avoir un binaire compilé spécifique à chaque plateforme permet à Python d’être portable et facile à déployer. Les développeurs peuvent écrire un script Python et s’attendre à ce qu’il fonctionne de la même manière sur différentes machines, à condition que l’interpréteur Python approprié soit installé.\n\nCe mécanisme d’interprétation via un binaire compilé est une caractéristique clé de Python, contribuant à sa polyvalence et sa facilité d’utilisation dans divers environnements de développement.\nMais donc, qui produit se binaire ? Y’en a-t-il une seule implémentation ? Puis-je le compiler moi même ?",
    "crumbs": [
      "Exécution d'un Programme Python"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html",
    "href": "content/Cours_1/4-Path.html",
    "title": "Le PATH",
    "section": "",
    "text": "PATH est une variable d’environnement utilisée par le système d’exploitation pour localiser les fichiers exécutables requis pour lancer des programmes ou des commandes.\nElle contient une liste de répertoires séparés par un délimiteur spécifique au système d’exploitation : point-virgule (;) pour Windows et deux-points (:) pour Unix/Linux.\n\n\n\n\n\nLorsqu’une commande est saisie dans le terminal ou l’invite de commande, le système parcourt les répertoires listés dans PATH à la recherche d’un fichier exécutable correspondant au nom de la commande.\nSi le fichier est trouvé, il est exécuté. Sinon, un message d’erreur indique que la commande est introuvable.\n\n\n\n\n\n\n\nAjouter de nouveaux chemins à PATH est souvent nécessaire après l’installation de nouveaux logiciels ou scripts pour permettre leur exécution depuis n’importe quel répertoire.\nLa modification de PATH facilite l’accès à ces programmes sans avoir besoin de naviguer vers leur répertoire d’installation ou de spécifier leur chemin complet.\n\n\n\n\n\nSous Windows, PATH peut être modifié via les Propriétés Système ou l’Éditeur de Registre.\nSous Unix/Linux et MacOS, PATH est généralement modifié en éditant les fichiers de configuration de l’interpréteur de commandes, tels que .bashrc, .bash_profile, ou .zshrc.\n\n\n\n\n\n\n\n\nPATH permet de lancer des applications et des scripts facilement depuis n’importe quel répertoire dans le terminal, en supprimant le besoin de saisir des chemins complets.\n\n\n\n\n\nUne gestion efficace de PATH aide à maintenir une organisation claire des programmes et scripts fréquemment utilisés, en centralisant leur accès.\n\n\n\n\nRisques de Sécurité - Ajouter des répertoires non sécurisés ou de sources inconnues à PATH peut exposer le système à des risques de sécurité. Des exécutables malveillants dans ces répertoires pourraient être lancés involontairement.\nBonnes Pratiques - Il est recommandé de n’ajouter que des répertoires de confiance à PATH et de vérifier régulièrement son contenu pour éviter des risques de sécurité.\n\n\n\n\n\n\n\nAccès à PATH : Accessible via Panneau de configuration &gt; Système &gt; Paramètres système avancés &gt; Variables d’environnement.\nModification : Ajouter ou modifier les valeurs dans la variable Path sous Variables d’environnement.\nApplication des Changements : Les modifications prennent effet après redémarrage de l’invite de commande ou redémarrage du système.\n\n\n\n\n\nFichiers de Configuration : .bashrc, .bash_profile, ou .profile dans le répertoire personnel de l’utilisateur.\nModification : Ajouter export PATH=\"/nouveau/chemin:$PATH\" au fichier correspondant.\nApplication des Changements : Exécuter source ~/.bashrc ou ouvrir un nouveau terminal.\n\n\n\n\n\nSimilaire à Linux, MacOS utilise .bash_profile ou .zshrc pour les utilisateurs de zsh.\nLa modification et l’application des changements sont identiques à celles de Linux.\n\n\n\n\nLa configuration de la variable PATH pour une version de Python compilée manuellement est un processus essentiel pour s’assurer que le système utilise la bonne version de Python. Voici des instructions spécifiques pour Windows, Linux et MacOS.\n\n\n\nLocalisation de l’Exécutable Python:\n\nTrouvez le chemin où Python a été compilé et installé, par exemple, C:\\Users\\VotreNom\\mon_python.\n\nModification de PATH:\n\nOuvrez les Propriétés Système &gt; Variables d’environnement.\nSous “Variables système”, trouvez et sélectionnez la variable Path, puis cliquez sur Modifier.\nAjoutez le chemin vers le dossier contenant l’exécutable Python, par exemple, C:\\Users\\VotreNom\\mon_python.\nCliquez sur OK pour fermer les fenêtres.\n\nApplication des Changements:\n\nOuvrez une nouvelle invite de commande pour que les changements prennent effet.\nTapez python --version pour vérifier que la bonne version de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nSupposons que Python soit installé dans ~/mon_python/.\n\nModification de PATH:\n\nOuvrez le fichier .bashrc ou .bash_profile dans votre répertoire personnel avec un éditeur de texte.\nAjoutez la ligne export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier.\nEnregistrez et fermez le fichier.\n\nApplication des Changements:\n\nExécutez source ~/.bashrc ou redémarrez le terminal.\nVérifiez avec python --version que la version correcte de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nComme pour Linux, identifiez où Python a été installé, par exemple, ~/mon_python/.\n\nModification de PATH:\n\nSi vous utilisez Bash, modifiez .bash_profile ; si vous utilisez Zsh, modifiez .zshrc.\nAjoutez export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier correspondant.\nSauvegardez et fermez l’éditeur de texte.\n\nApplication des Changements:\n\nExécutez source ~/.bash_profile ou source ~/.zshrc, selon l’interpréteur de commandes que vous utilisez.\nUtilisez python --version pour confirmer que le système utilise la version Python compilée manuellement.\n\n\n\n\n\n\n\nOrdre dans PATH : L’ordre des chemins dans PATH est crucial. Le système recherche les exécutables dans l’ordre où les chemins apparaissent. Si vous voulez que votre version compilée de Python soit prioritaire, assurez-vous qu’elle apparaisse en premier dans la liste.\nSécurité : Soyez prudent lors de la modification de PATH, surtout sous Unix/Linux et MacOS, car une mauvaise configuration peut affecter le fonctionnement du système.\nVersion par Défaut : Si plusieurs versions de Python sont installées, la version exécutée par défaut sera celle trouvée en premier dans PATH.\n\nEn suivant ces étapes, vous pouvez configurer votre système pour utiliser une version spécifique de Python, vous offrant ainsi une plus grande flexibilité et contrôle sur votre environnement de développement.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.1---définition-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.1---définition-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "PATH est une variable d’environnement utilisée par le système d’exploitation pour localiser les fichiers exécutables requis pour lancer des programmes ou des commandes.\nElle contient une liste de répertoires séparés par un délimiteur spécifique au système d’exploitation : point-virgule (;) pour Windows et deux-points (:) pour Unix/Linux.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.2---fonctionnement-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.2---fonctionnement-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "Lorsqu’une commande est saisie dans le terminal ou l’invite de commande, le système parcourt les répertoires listés dans PATH à la recherche d’un fichier exécutable correspondant au nom de la commande.\nSi le fichier est trouvé, il est exécuté. Sinon, un message d’erreur indique que la commande est introuvable.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.3---modification-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.3---modification-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "Ajouter de nouveaux chemins à PATH est souvent nécessaire après l’installation de nouveaux logiciels ou scripts pour permettre leur exécution depuis n’importe quel répertoire.\nLa modification de PATH facilite l’accès à ces programmes sans avoir besoin de naviguer vers leur répertoire d’installation ou de spécifier leur chemin complet.\n\n\n\n\n\nSous Windows, PATH peut être modifié via les Propriétés Système ou l’Éditeur de Registre.\nSous Unix/Linux et MacOS, PATH est généralement modifié en éditant les fichiers de configuration de l’interpréteur de commandes, tels que .bashrc, .bash_profile, ou .zshrc.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.4---importance-et-utilisation-de-path",
    "href": "content/Cours_1/4-Path.html#section-4.4---importance-et-utilisation-de-path",
    "title": "Le PATH",
    "section": "",
    "text": "PATH permet de lancer des applications et des scripts facilement depuis n’importe quel répertoire dans le terminal, en supprimant le besoin de saisir des chemins complets.\n\n\n\n\n\nUne gestion efficace de PATH aide à maintenir une organisation claire des programmes et scripts fréquemment utilisés, en centralisant leur accès.\n\n\n\n\nRisques de Sécurité - Ajouter des répertoires non sécurisés ou de sources inconnues à PATH peut exposer le système à des risques de sécurité. Des exécutables malveillants dans ces répertoires pourraient être lancés involontairement.\nBonnes Pratiques - Il est recommandé de n’ajouter que des répertoires de confiance à PATH et de vérifier régulièrement son contenu pour éviter des risques de sécurité.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/4-Path.html#section-4.5---configuration-de-path-pour-windows-linux-et-macos",
    "href": "content/Cours_1/4-Path.html#section-4.5---configuration-de-path-pour-windows-linux-et-macos",
    "title": "Le PATH",
    "section": "",
    "text": "Accès à PATH : Accessible via Panneau de configuration &gt; Système &gt; Paramètres système avancés &gt; Variables d’environnement.\nModification : Ajouter ou modifier les valeurs dans la variable Path sous Variables d’environnement.\nApplication des Changements : Les modifications prennent effet après redémarrage de l’invite de commande ou redémarrage du système.\n\n\n\n\n\nFichiers de Configuration : .bashrc, .bash_profile, ou .profile dans le répertoire personnel de l’utilisateur.\nModification : Ajouter export PATH=\"/nouveau/chemin:$PATH\" au fichier correspondant.\nApplication des Changements : Exécuter source ~/.bashrc ou ouvrir un nouveau terminal.\n\n\n\n\n\nSimilaire à Linux, MacOS utilise .bash_profile ou .zshrc pour les utilisateurs de zsh.\nLa modification et l’application des changements sont identiques à celles de Linux.\n\n\n\n\nLa configuration de la variable PATH pour une version de Python compilée manuellement est un processus essentiel pour s’assurer que le système utilise la bonne version de Python. Voici des instructions spécifiques pour Windows, Linux et MacOS.\n\n\n\nLocalisation de l’Exécutable Python:\n\nTrouvez le chemin où Python a été compilé et installé, par exemple, C:\\Users\\VotreNom\\mon_python.\n\nModification de PATH:\n\nOuvrez les Propriétés Système &gt; Variables d’environnement.\nSous “Variables système”, trouvez et sélectionnez la variable Path, puis cliquez sur Modifier.\nAjoutez le chemin vers le dossier contenant l’exécutable Python, par exemple, C:\\Users\\VotreNom\\mon_python.\nCliquez sur OK pour fermer les fenêtres.\n\nApplication des Changements:\n\nOuvrez une nouvelle invite de commande pour que les changements prennent effet.\nTapez python --version pour vérifier que la bonne version de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nSupposons que Python soit installé dans ~/mon_python/.\n\nModification de PATH:\n\nOuvrez le fichier .bashrc ou .bash_profile dans votre répertoire personnel avec un éditeur de texte.\nAjoutez la ligne export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier.\nEnregistrez et fermez le fichier.\n\nApplication des Changements:\n\nExécutez source ~/.bashrc ou redémarrez le terminal.\nVérifiez avec python --version que la version correcte de Python est utilisée.\n\n\n\n\n\n\nLocalisation de l’Exécutable Python:\n\nComme pour Linux, identifiez où Python a été installé, par exemple, ~/mon_python/.\n\nModification de PATH:\n\nSi vous utilisez Bash, modifiez .bash_profile ; si vous utilisez Zsh, modifiez .zshrc.\nAjoutez export PATH=\"~/mon_python/bin:$PATH\" à la fin du fichier correspondant.\nSauvegardez et fermez l’éditeur de texte.\n\nApplication des Changements:\n\nExécutez source ~/.bash_profile ou source ~/.zshrc, selon l’interpréteur de commandes que vous utilisez.\nUtilisez python --version pour confirmer que le système utilise la version Python compilée manuellement.\n\n\n\n\n\n\n\nOrdre dans PATH : L’ordre des chemins dans PATH est crucial. Le système recherche les exécutables dans l’ordre où les chemins apparaissent. Si vous voulez que votre version compilée de Python soit prioritaire, assurez-vous qu’elle apparaisse en premier dans la liste.\nSécurité : Soyez prudent lors de la modification de PATH, surtout sous Unix/Linux et MacOS, car une mauvaise configuration peut affecter le fonctionnement du système.\nVersion par Défaut : Si plusieurs versions de Python sont installées, la version exécutée par défaut sera celle trouvée en premier dans PATH.\n\nEn suivant ces étapes, vous pouvez configurer votre système pour utiliser une version spécifique de Python, vous offrant ainsi une plus grande flexibilité et contrôle sur votre environnement de développement.",
    "crumbs": [
      "Le PATH"
    ]
  },
  {
    "objectID": "content/Cours_1/IDEs/VsCode.html",
    "href": "content/Cours_1/IDEs/VsCode.html",
    "title": "VsCode - L’IDE Flexible et Polyvalent",
    "section": "",
    "text": "Présentation Générale de Visual Studio Code (VS Code)\nVisual Studio Code, communément appelé VS Code, est un IDE largement adopté par la communauté des développeurs Python. Sa réputation repose sur sa légèreté, sa flexibilité et ses capacités de personnalisation. Examinons en détail les caractéristiques qui font de VS Code un choix privilégié pour le développement Python.\n\n\n\n1. Caractéristiques Principales de VS Code\n\nÉditeur Polyvalent :\n\nVS Code est un éditeur de code source léger et performant, supportant Python ainsi que de nombreux autres langages de programmation.\nSon interface utilisateur épurée et réactive convient aussi bien aux petits scripts qu’aux grands projets.\n\nExtensions et Personnalisation :\n\nLa force de VS Code réside dans sa capacité à intégrer une multitude d’extensions, dont une extension Python officielle qui enrichit l’IDE de fonctionnalités dédiées à Python.\nLes utilisateurs peuvent personnaliser presque tous les aspects de l’IDE, des thèmes visuels aux fonctionnalités spécifiques grâce à des extensions.\n\nIntégration Git :\n\nVS Code intègre nativement le support de Git, offrant un contrôle de version efficace et directement accessible depuis l’interface de l’IDE.\n\n\n\n\n2. Débogage et Tests\n\nFonctionnalités Avancées de Débogage :\n\nVS Code propose des outils de débogage sophistiqués pour Python, permettant l’inspection de code, le suivi des variables, et l’exécution pas à pas.\nCes outils de débogage facilitent la résolution des erreurs et des problèmes complexes dans le code.\n\nSupport des Frameworks de Test :\n\nL’IDE prend en charge divers frameworks de test unitaire pour Python, permettant de créer, d’exécuter et de visualiser les résultats des tests directement dans l’interface.\n\n\n\n\n3. Gestion des Environnements Virtuels\n\nVS Code détecte automatiquement les environnements virtuels Python, les rendant facilement accessibles pour la gestion des dépendances et l’exécution du code.\n\n\n\n4. Personnalisation et Productivité\n\nLes utilisateurs peuvent personnaliser VS Code selon leurs préférences, avec des thèmes, des raccourcis clavier, et une multitude de réglages pour optimiser l’expérience de développement.\nDes fonctionnalités comme l’auto-complétion, la navigation intelligente dans le code et les snippets personnalisés augmentent la productivité des développeurs.\n\n\n\n5. Support pour la Data Science et le Développement Web\n\nData Science :\n\nVS Code intègre des outils pour la data science, notamment le support pour Jupyter Notebooks, offrant une expérience de travail interactive avec les données.\n\nDéveloppement Web :\n\nL’IDE fournit un support exhaustif pour les technologies web, facilitant le développement tant sur le front-end que le back-end.\n\n\n\n\n\n6. Communauté Active et Mises à Jour Constantes\n\nAvec une communauté dynamique et des mises à jour régulières, VS Code continue d’évoluer, ajoutant continuellement de nouvelles fonctionnalités et améliorations.\n\n\n\nConclusion\nVisual Studio Code se distingue comme un environnement de développement hautement personnalisable et polyvalent, adapté à une vaste gamme de projets Python. Que ce soit pour la data science, le développement web, ou des applications générales, VS Code offre un ensemble d’outils et de fonctionnalités qui répondent aux besoins des développeurs de tous niveaux.\n\n\n\n\n Back to top",
    "crumbs": [
      "Quelques IDEs en Python",
      "VsCode - L'IDE Flexible et Polyvalent"
    ]
  },
  {
    "objectID": "content/Cours_1/TP-ConstruireSonPython.html",
    "href": "content/Cours_1/TP-ConstruireSonPython.html",
    "title": "TP - Construire son python depuis la source",
    "section": "",
    "text": "TP - Construire Python depuis la Source\nAfin de vous aider pour réaliser ce TP, vous trouverez une fiche sur l’utilisation de git ici, ainsi qu’une fiche sur les commandes de base du terminal Linux pour ceux qui n’en ont pas l’habitude ici. Pour ceux ayant déjà fait du C ce TP devrait être assez simple, pour les autres, il vous faudra un peu plus de temps pour comprendre les différentes étapes.\n\nPartie 1 : Préparation et Clonage du Répertoire Git de CPython\nLe but de cette première partie est de préparer votre environnement pour la compilation de Python et de cloner le répertoire Git de CPython.\n\nPréparation de l’Environnement :\n\nAvant de cloner le répertoire, assurez-vous que Git est installé sur votre système. Sous Linux et MacOS, Git est souvent préinstallé. Sous Windows, vous devrez peut-être l’installer manuellement.\nVérifiez également que vous disposez des outils de compilation nécessaires. Sous Linux, il s’agit généralement du package build-essential. Sous MacOS, vous aurez besoin de Xcode ou des outils de ligne de commande pour Xcode.\n\nClonage du Répertoire Git de CPython :\n\nOuvrez un terminal ou une invite de commande.\nExécutez la commande suivante pour cloner le répertoire Git de CPython :\ngit clone https://github.com/python/cpython.git\nCette commande télécharge le code source de Python dans un dossier cpython sur votre machine.\nVous pouvez choisir une branche spécifique si vous le souhaitez, mais la branche par défaut vous donnera accès à la dernière version de développement.\n\n\n\n\nPartie 2 : Configuration du Build\nCette partie implique de configurer le code source pour la compilation.\n\nNavigation dans le Dossier :\n\nAccédez au dossier cloné en utilisant la commande cd cpython.\n\nConfiguration du Build :\n\nDans le dossier cpython, exécutez la commande ./configure.\nCette étape vérifie les outils et bibliothèques disponibles sur votre système. Elle configure le processus de build pour qu’il soit adapté à votre environnement spécifique.\nLa commande ./configure peut être personnalisée avec diverses options, telles que l’activation ou la désactivation de certaines fonctionnalités de Python.\n\n\n\n\nPartie 3 : Compilation de Python\nLa compilation est le processus de transformation du code source en un exécutable.\nLancement de la Compilation : - Dans le même dossier, exécutez la commande make. - Cette commande compile le code source de Python. Selon la puissance de votre machine, cela peut prendre un certain temps.\n\n\nPartie 4 : Installation de Python\nAprès avoir compilé le code source, l’étape suivante est d’installer Python sur votre système.\n\nInstallation :\n\nExécutez make install dans le terminal. Cette commande copiera les fichiers exécutables et les bibliothèques dans les répertoires appropriés sur votre système.\nSi vous ne souhaitez pas écraser la version Python existante, vous pouvez utiliser make altinstall à la place.\n\nVérification de l’Installation :\n\nUne fois l’installation terminée, vérifiez que Python est correctement installé en exécutant python --version ou python3 --version dans votre terminal. Vous devriez voir la version que vous venez de compiler.\n\n\n\n\nPartie 5 : Personnalisation et Observations pendant la Compilation\nLors de la compilation de Python, plusieurs aspects peuvent être personnalisés pour répondre à des besoins spécifiques ou optimiser le build.\n\nVariables d’Environnement et Options de Compilation :\n\nCC : Vous pouvez définir la variable d’environnement CC pour spécifier le compilateur à utiliser. Par exemple, export CC=gcc utilise GCC.\nFlags d’Optimisation : Les flags comme -O2 ou -O3 peuvent être ajoutés pour optimiser le build. Ces flags peuvent être définis en modifiant la variable CFLAGS.\nExemple : export CFLAGS=\"-O3\" pour une optimisation de niveau 3.\n\nModification du Makefile :\n\nLe Makefile généré par ./configure peut être modifié pour un contrôle plus fin sur le processus de build.\nVous pouvez ouvrir le Makefile dans un éditeur de texte et examiner les différents targets de build, les variables et les options configurées.\n\nObserver le Processus de Compilation :\n\nPendant la compilation avec make, observez les sorties dans le terminal. Elles fournissent des informations sur les fichiers en cours de compilation, les avertissements, et les erreurs éventuelles.\nLes messages d’erreur, en particulier, peuvent vous aider à identifier des problèmes spécifiques liés aux dépendances ou à la configuration de votre système.\n\n\n\n\nConseils Supplémentaires et Ressources pour la Compilation de Python\nAprès avoir compilé et installé votre version personnalisée de Python, voici quelques conseils et ressources supplémentaires pour approfondir vos connaissances et compétences en matière de compilation.\n\nExploration Approfondie du Makefile :\n\nPrenez le temps d’étudier le Makefile généré par ./configure. Il contient des informations précieuses sur les processus de build et les targets.\nExplorer le Makefile vous aidera à comprendre comment les différentes parties de Python sont compilées et liées ensemble.\n\nPersonnalisation Avancée :\n\nEn plus des flags d’optimisation et du choix du compilateur, envisagez d’explorer d’autres options de configuration. Par exemple, vous pouvez activer ou désactiver des modules spécifiques de Python lors de la compilation.\nLes options de configuration peuvent être explorées en exécutant ./configure --help.\n\nGestion des Dépendances :\n\nAssurez-vous que toutes les dépendances nécessaires sont installées sur votre système. Certaines fonctionnalités de Python peuvent nécessiter des bibliothèques externes.\nLes erreurs lors de la compilation sont souvent dues à l’absence de certaines bibliothèques de développement.\n\nRessources et Documentation :\n\nLa documentation officielle de Python est une ressource précieuse pour comprendre les différents aspects de la compilation de Python.\nDes forums et des communautés en ligne, comme Stack Overflow et les groupes Python, peuvent être des lieux d’échange d’informations et de conseils. #### Conclusion\n\n\nCompiler Python depuis la source offre non seulement une compréhension approfondie du fonctionnement interne de Python, mais permet également une personnalisation avancée du build. Cela peut être particulièrement utile pour les développeurs souhaitant contribuer au code source de Python ou nécessitant des versions spécifiques pour leurs projets.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP - Construire son python depuis la source"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html",
    "href": "content/Cours_1/1-Histoire.html",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Python, un langage de programmation de haut niveau, a été inventé par Guido van Rossum, dont la première version a été publiée en 1991. Ce langage, nommé d’après la série télévisée britannique “Monty Python’s Flying Circus”, a été conçu pour allier clarté syntaxique et puissance fonctionnelle.\nPython a évolué au fil des années, en gardant son principe directeur : une syntaxe qui favorise la lisibilité et la simplicité. Cette approche a conduit à un langage qui est à la fois facile à apprendre pour les débutants et puissant pour les développeurs expérimentés. Python est interprété, ce qui signifie que les scripts sont exécutés ligne par ligne, permettant une débogage et une interaction faciles.\nSa philosophie, encapsulée dans le “Zen de Python” (PEP 20)\n, guide la rédaction de programmes efficaces et lisibles. Il s’agit un ensemble de 19 aphorismes pour écrire de bons programmes en Python. Parmi les plus célèbres, on trouve “Beautiful is better than ugly”, “Explicit is better than implicit” et “Simple is better than complex”. Cette philosophie a été un facteur clé dans le succès de Python, en particulier pour les débutants qui peuvent facilement apprendre le langage et écrire des programmes simples et lisibles et est à garder en tête lors de l’écriture de code Python.\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nPour autant, bien que simple à prendre en main, Python est un langage puissant qui pour être réellement maîtrisé et compris dans sa globalité nécessite de la pratique et de l’expérience. De par son fonctionnement interne, le language permet ainsi à des développeurs expérimentés de trouver des solutions élégantes et efficaces à des problèmes complexes, qui serviront ensuite de base à des bibliothèques et frameworks utilisés par des développeurs bien moins expérimentés qui ne se douteront pas une seconde de ce qui se cache en dessous.\nEn résumé, le succès de Python repose sur plusieurs facteurs : sa simplicité, sa polyvalence (il est utilisé dans le développement web, l’analyse de données, l’intelligence artificielle, la science des données, et bien d’autres domaines), et une communauté active qui contribue à un écosystème riche en bibliothèques et frameworks.\n\n\n\nMais le language existe depuis 1991, et a donc évolué au fil des années. En effet, les besoins comme les machines ont changé, et comme la langue humaine, le language de programmation a évolué pour s’adapter à ces changements.\nCe qui est connu de presque tous, c’est que Python a deux grandes versions : Python 2 et Python 3. Python 2 a été largement utilisé et apprécié, mais en 2020, il a été officiellement abandonné au profit de Python 3, qui a été publié en 2008. Et oui, il a fallu 12 ans pour que Python 3 devienne la version officielle de Python, car les différences entre les versions 2 et 3 étaient importantes, et il a fallu du temps pour que les développeurs s’adaptent.\nCela va de la syntaxe à la gestion de la mémoire, en passant par la gestion des chaînes de caractères et des bibliothèques, et l’un des exemples les plus connus est le passage de print à une fonction, qui a été introduit dans Python 3: - Python 2 : print \"Hello World\" - Python 3 : print(\"Hello World\")\nD’exterieur, cela peut sembler être un changement mineur, mais au niveau de ce que cela signifie en terme de fonctionnement interne, c’est un changement majeur. En effet, dans Python 2, print est un mot clé, alors que dans Python 3, c’est une fonction. Cela signifie que dans Python 2, print est un mot clé qui est interprété par l’interpréteur Python, alors que dans Python 3, print est une fonction qui est appelée par l’interpréteur Python.\nCela cache en fait une forme d’uniformisation du code, car Python a la particularité d’être un language objet, et donc tout est un objet, y compris les fonctions. Cela signifie que les fonctions peuvent être passées en paramètre, et donc que les fonctions peuvent être appelées par d’autres fonctions. Cela permet de créer des fonctions qui peuvent être utilisées dans des contextes différents, et donc de réduire la duplication de code.\nEt bien qu’il ai fallu 12 ans pour que Python 3 devienne la version officielle de Python, il a continué d’évoluer, et continue encore aujourd’hui. En effet, Python en est à sa version 3.12, et bien que les changements ne soient pas aussi fondamentaux, les nouvelles capacités dont se dotent le language reste puissantes. On peut ainsi citer l’évolution continue de L’Asynchronisme en Python : - Emergence de l’Asynchronisme: Python a intégré des concepts d’asynchronisme pour répondre aux besoins modernes en programmation, notamment pour la gestion efficace des opérations I/O et pour le développement d’applications web. - asyncio en Python 3.5: Le module asyncio a été introduit dans Python 3.5, marquant un changement significatif dans la gestion de la concurrence et des opérations asynchrones. Il permet d’écrire du code asynchrone en utilisant la syntaxe async/await, facilitant la création de programmes non bloquants. - Améliorations continues: Depuis Python 3.5, il y a eu des améliorations continues dans les fonctionnalités asynchrones, rendant Python plus adapté pour des applications nécessitant de hautes performances en matière de concurrence et d’asynchronisme.\n\n\n\nPourquoi Python est largement adopté : 1. Facilité d’apprentissage et de lecture: La syntaxe de Python est conçue pour être intuitive et lisible, ce qui rend l’apprentissage du langage plus accessible aux débutants. 2. Polyvalence: Python est utilisé dans divers domaines, tels que le développement web, l’analyse de données, l’intelligence artificielle, et la science des données. 3. Bibliothèques et Frameworks: Python bénéficie d’un écosystème riche, avec des bibliothèques comme NumPy, Pandas, TensorFlow, et Flask, qui étendent ses capacités. 4. Communauté active: Une vaste communauté de développeurs contribue à l’amélioration continue de Python et offre un soutien important via des forums et des ressources en ligne. 5. Interopérabilité: Python peut être intégré avec d’autres langages de programmation, ce qui lui permet de s’adapter à divers environnements et exigences de projet.\nCritiques courantes de Python : 1. Vitesse d’exécution: Étant un langage interprété, Python peut être plus lent que les langages compilés comme C ou Java, particulièrement dans les applications nécessitant de lourds calculs. 2. Gestion de la mémoire: Python utilise une gestion de mémoire automatique qui peut entraîner une consommation de mémoire plus élevée. 3. Dépendance aux bibliothèques: La richesse des bibliothèques Python est à double tranchant. Certains développeurs critiquent la dépendance excessive à des bibliothèques externes pour des fonctionnalités de base. 4. Limitations en matière de programmation mobile et de jeux: Python n’est pas le choix principal pour le développement d’applications mobiles et de jeux en raison de sa vitesse et de sa consommation de ressources. 5. Versionnage: La transition de Python 2 à Python 3 a créé des problèmes de compatibilité, bien que cela se soit amélioré avec le temps.\n\n\n\nCes limites viennent de l’histoire du language, et de ses choix de conception. D’une part, Python est un language interprété, et donc il est plus lent que les languages compilés. Cela vient du fait que l’interpréteur Python doit lire le code, le comprendre, et l’exécuter, alors qu’un compilateur va transformer le code en langage machine, et donc le code est directement exécutable.\nCela vient du typage dynamique de Python, qui permet de ne pas avoir à déclarer le type des variables, et donc de ne pas avoir à réserver de la mémoire pour ces variables. Cela permet de ne pas avoir à se soucier de la mémoire, mais cela a un coût, car l’interpréteur Python doit déterminer le type des variables à l’exécution, et donc cela prend du temps.\nEt cela vient du fait que la language a été développé à une époque où les ordinateurs n’avaient qu’un seul CPU, et donc ne pouvaient exécuter qu’une seule instruction à la fois. Cela a conduit à un language qui n’est pas adapté à la programmation parallèle, et donc qui ne peut pas tirer parti des architectures modernes qui ont plusieurs CPU, et donc peuvent exécuter plusieurs instructions en même temps, du moins pas de la même façon que le peut un language comme C. Ce problème est très connu et se nomme le GIL (Global Interpreter Lock), il est un problème qui est connu depuis longtemps, mais qui n’a pas encore été résolu. Un peu de lecture, pour les plus curieux : Python GIL, Python GIL, Python GIL\n\n\n\nLes PEPs (Python Enhancement Proposals) sont des propositions d’amélioration du langage Python. Ils sont utilisés pour discuter des nouvelles fonctionnalités et des changements de comportement du langage. Ils sont également utilisés pour décrire les normes de codage, les processus de développement et les décisions de conception. Les PEPs sont des documents vivants et peuvent être modifiés à mesure que de nouvelles informations sont disponibles.\nLes PEPs sont numérotés et organisés dans une hiérarchie. Les PEPs sont numérotés de 0 à 9999, et sont organisés en trois catégories : - Informational PEPs (PEP 0-99): Les PEPs informatifs fournissent des informations sur le langage Python ou sur les processus de développement. Ils ne décrivent pas de nouvelles fonctionnalités ou de changements de comportement. - Process PEPs (PEP 100-199): Les PEPs de processus décrivent les processus de développement, les normes de codage et les décisions de conception. - Standards Track PEPs (PEP 200-9999): Les PEPs de la norme de suivi décrivent les nouvelles fonctionnalités et les changements de comportement du langage Python.\nLes PEPs sont écrits en utilisant le format reStructuredText, et sont publiés sur le site web officiel de Python. Les PEPs sont discutés et révisés par la communauté Python, et sont acceptés ou rejetés par le BDFL (Benevolent Dictator For Life), Guido van Rossum.\nDans les derniers PEPs, l’un pourrait changer radicalement Python, le PEP 703 – Making the Global Interpreter Lock Optional in CPython] qui propose de supprimer le GIL, et donc de permettre à Python d’être utilisé pour de la programmation parallèle. Cela permettrait à Python de tirer parti des architectures modernes.\nCela en tête nous pouvons donc commencer à apprendre Python, et à comprendre comment il fonctionne.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.1---origines",
    "href": "content/Cours_1/1-Histoire.html#section-1.1---origines",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Python, un langage de programmation de haut niveau, a été inventé par Guido van Rossum, dont la première version a été publiée en 1991. Ce langage, nommé d’après la série télévisée britannique “Monty Python’s Flying Circus”, a été conçu pour allier clarté syntaxique et puissance fonctionnelle.\nPython a évolué au fil des années, en gardant son principe directeur : une syntaxe qui favorise la lisibilité et la simplicité. Cette approche a conduit à un langage qui est à la fois facile à apprendre pour les débutants et puissant pour les développeurs expérimentés. Python est interprété, ce qui signifie que les scripts sont exécutés ligne par ligne, permettant une débogage et une interaction faciles.\nSa philosophie, encapsulée dans le “Zen de Python” (PEP 20)\n, guide la rédaction de programmes efficaces et lisibles. Il s’agit un ensemble de 19 aphorismes pour écrire de bons programmes en Python. Parmi les plus célèbres, on trouve “Beautiful is better than ugly”, “Explicit is better than implicit” et “Simple is better than complex”. Cette philosophie a été un facteur clé dans le succès de Python, en particulier pour les débutants qui peuvent facilement apprendre le langage et écrire des programmes simples et lisibles et est à garder en tête lors de l’écriture de code Python.\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nPour autant, bien que simple à prendre en main, Python est un langage puissant qui pour être réellement maîtrisé et compris dans sa globalité nécessite de la pratique et de l’expérience. De par son fonctionnement interne, le language permet ainsi à des développeurs expérimentés de trouver des solutions élégantes et efficaces à des problèmes complexes, qui serviront ensuite de base à des bibliothèques et frameworks utilisés par des développeurs bien moins expérimentés qui ne se douteront pas une seconde de ce qui se cache en dessous.\nEn résumé, le succès de Python repose sur plusieurs facteurs : sa simplicité, sa polyvalence (il est utilisé dans le développement web, l’analyse de données, l’intelligence artificielle, la science des données, et bien d’autres domaines), et une communauté active qui contribue à un écosystème riche en bibliothèques et frameworks.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.2---et-évolution",
    "href": "content/Cours_1/1-Histoire.html#section-1.2---et-évolution",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Mais le language existe depuis 1991, et a donc évolué au fil des années. En effet, les besoins comme les machines ont changé, et comme la langue humaine, le language de programmation a évolué pour s’adapter à ces changements.\nCe qui est connu de presque tous, c’est que Python a deux grandes versions : Python 2 et Python 3. Python 2 a été largement utilisé et apprécié, mais en 2020, il a été officiellement abandonné au profit de Python 3, qui a été publié en 2008. Et oui, il a fallu 12 ans pour que Python 3 devienne la version officielle de Python, car les différences entre les versions 2 et 3 étaient importantes, et il a fallu du temps pour que les développeurs s’adaptent.\nCela va de la syntaxe à la gestion de la mémoire, en passant par la gestion des chaînes de caractères et des bibliothèques, et l’un des exemples les plus connus est le passage de print à une fonction, qui a été introduit dans Python 3: - Python 2 : print \"Hello World\" - Python 3 : print(\"Hello World\")\nD’exterieur, cela peut sembler être un changement mineur, mais au niveau de ce que cela signifie en terme de fonctionnement interne, c’est un changement majeur. En effet, dans Python 2, print est un mot clé, alors que dans Python 3, c’est une fonction. Cela signifie que dans Python 2, print est un mot clé qui est interprété par l’interpréteur Python, alors que dans Python 3, print est une fonction qui est appelée par l’interpréteur Python.\nCela cache en fait une forme d’uniformisation du code, car Python a la particularité d’être un language objet, et donc tout est un objet, y compris les fonctions. Cela signifie que les fonctions peuvent être passées en paramètre, et donc que les fonctions peuvent être appelées par d’autres fonctions. Cela permet de créer des fonctions qui peuvent être utilisées dans des contextes différents, et donc de réduire la duplication de code.\nEt bien qu’il ai fallu 12 ans pour que Python 3 devienne la version officielle de Python, il a continué d’évoluer, et continue encore aujourd’hui. En effet, Python en est à sa version 3.12, et bien que les changements ne soient pas aussi fondamentaux, les nouvelles capacités dont se dotent le language reste puissantes. On peut ainsi citer l’évolution continue de L’Asynchronisme en Python : - Emergence de l’Asynchronisme: Python a intégré des concepts d’asynchronisme pour répondre aux besoins modernes en programmation, notamment pour la gestion efficace des opérations I/O et pour le développement d’applications web. - asyncio en Python 3.5: Le module asyncio a été introduit dans Python 3.5, marquant un changement significatif dans la gestion de la concurrence et des opérations asynchrones. Il permet d’écrire du code asynchrone en utilisant la syntaxe async/await, facilitant la création de programmes non bloquants. - Améliorations continues: Depuis Python 3.5, il y a eu des améliorations continues dans les fonctionnalités asynchrones, rendant Python plus adapté pour des applications nécessitant de hautes performances en matière de concurrence et d’asynchronisme.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.3-----popularité-et-critiques",
    "href": "content/Cours_1/1-Histoire.html#section-1.3-----popularité-et-critiques",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Pourquoi Python est largement adopté : 1. Facilité d’apprentissage et de lecture: La syntaxe de Python est conçue pour être intuitive et lisible, ce qui rend l’apprentissage du langage plus accessible aux débutants. 2. Polyvalence: Python est utilisé dans divers domaines, tels que le développement web, l’analyse de données, l’intelligence artificielle, et la science des données. 3. Bibliothèques et Frameworks: Python bénéficie d’un écosystème riche, avec des bibliothèques comme NumPy, Pandas, TensorFlow, et Flask, qui étendent ses capacités. 4. Communauté active: Une vaste communauté de développeurs contribue à l’amélioration continue de Python et offre un soutien important via des forums et des ressources en ligne. 5. Interopérabilité: Python peut être intégré avec d’autres langages de programmation, ce qui lui permet de s’adapter à divers environnements et exigences de projet.\nCritiques courantes de Python : 1. Vitesse d’exécution: Étant un langage interprété, Python peut être plus lent que les langages compilés comme C ou Java, particulièrement dans les applications nécessitant de lourds calculs. 2. Gestion de la mémoire: Python utilise une gestion de mémoire automatique qui peut entraîner une consommation de mémoire plus élevée. 3. Dépendance aux bibliothèques: La richesse des bibliothèques Python est à double tranchant. Certains développeurs critiquent la dépendance excessive à des bibliothèques externes pour des fonctionnalités de base. 4. Limitations en matière de programmation mobile et de jeux: Python n’est pas le choix principal pour le développement d’applications mobiles et de jeux en raison de sa vitesse et de sa consommation de ressources. 5. Versionnage: La transition de Python 2 à Python 3 a créé des problèmes de compatibilité, bien que cela se soit amélioré avec le temps.",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.4---comprendre-ces-limites",
    "href": "content/Cours_1/1-Histoire.html#section-1.4---comprendre-ces-limites",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Ces limites viennent de l’histoire du language, et de ses choix de conception. D’une part, Python est un language interprété, et donc il est plus lent que les languages compilés. Cela vient du fait que l’interpréteur Python doit lire le code, le comprendre, et l’exécuter, alors qu’un compilateur va transformer le code en langage machine, et donc le code est directement exécutable.\nCela vient du typage dynamique de Python, qui permet de ne pas avoir à déclarer le type des variables, et donc de ne pas avoir à réserver de la mémoire pour ces variables. Cela permet de ne pas avoir à se soucier de la mémoire, mais cela a un coût, car l’interpréteur Python doit déterminer le type des variables à l’exécution, et donc cela prend du temps.\nEt cela vient du fait que la language a été développé à une époque où les ordinateurs n’avaient qu’un seul CPU, et donc ne pouvaient exécuter qu’une seule instruction à la fois. Cela a conduit à un language qui n’est pas adapté à la programmation parallèle, et donc qui ne peut pas tirer parti des architectures modernes qui ont plusieurs CPU, et donc peuvent exécuter plusieurs instructions en même temps, du moins pas de la même façon que le peut un language comme C. Ce problème est très connu et se nomme le GIL (Global Interpreter Lock), il est un problème qui est connu depuis longtemps, mais qui n’a pas encore été résolu. Un peu de lecture, pour les plus curieux : Python GIL, Python GIL, Python GIL",
    "crumbs": [
      "Histoire du Langage"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#section-1.5---les-peps",
    "href": "content/Cours_1/1-Histoire.html#section-1.5---les-peps",
    "title": "Histoire du Langage",
    "section": "",
    "text": "Les PEPs (Python Enhancement Proposals) sont des propositions d’amélioration du langage Python. Ils sont utilisés pour discuter des nouvelles fonctionnalités et des changements de comportement du langage. Ils sont également utilisés pour décrire les normes de codage, les processus de développement et les décisions de conception. Les PEPs sont des documents vivants et peuvent être modifiés à mesure que de nouvelles informations sont disponibles.\nLes PEPs sont numérotés et organisés dans une hiérarchie. Les PEPs sont numérotés de 0 à 9999, et sont organisés en trois catégories : - Informational PEPs (PEP 0-99): Les PEPs informatifs fournissent des informations sur le langage Python ou sur les processus de développement. Ils ne décrivent pas de nouvelles fonctionnalités ou de changements de comportement. - Process PEPs (PEP 100-199): Les PEPs de processus décrivent les processus de développement, les normes de codage et les décisions de conception. - Standards Track PEPs (PEP 200-9999): Les PEPs de la norme de suivi décrivent les nouvelles fonctionnalités et les changements de comportement du langage Python.\nLes PEPs sont écrits en utilisant le format reStructuredText, et sont publiés sur le site web officiel de Python. Les PEPs sont discutés et révisés par la communauté Python, et sont acceptés ou rejetés par le BDFL (Benevolent Dictator For Life), Guido van Rossum.\nDans les derniers PEPs, l’un pourrait changer radicalement Python, le PEP 703 – Making the Global Interpreter Lock Optional in CPython] qui propose de supprimer le GIL, et donc de permettre à Python d’être utilisé pour de la programmation parallèle. Cela permettrait à Python de tirer parti des architectures modernes.\nCela en tête nous pouvons donc commencer à apprendre Python, et à comprendre comment il fonctionne.",
    "crumbs": [
      "Histoire du Langage"
    ]
  }
]